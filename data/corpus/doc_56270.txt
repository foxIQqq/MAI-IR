Выпуск языка программирования Rust 1.57

Опубликован релиз языка системного программирования Rust 1.57, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Автоматическое управление памятью в Rust избавляет разработчика от ошибок при манипулировании указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Стабилизировано использование макроса "panic!" в контекстах, создаваемых при компиляции, таких как объявления "const fn". Кроме того, помимо использования "panic!" в const-объявлениях разрешено использование макроса "assert!" и некоторых других API стандартной библиотеки. Стабилизация пока не охватывает всю инфраструктуру форматирования, поэтому в текущем виде макрос "panic!" может использоваться только со статическими строками (panic!("...")) или с одним интерполированным значением "&str" при подстановке (panic!("{}", a)), которое должно ограничиваться подстановкой "{}" без спецификаторов форматирования и других типажей. В будущем применимость макросов в константных контекстах будет расширена, но стабилизированных возможностей уже достаточно для выполнения assert-проверок на этапе компиляции: const _: () = assert!(std::mem::size_of::<u64>() == 8); const _: () = assert!(std::mem::size_of::<u8>() == 1); В пакетном менеджере Cargo разрешено использование профилей с произвольными именами, не ограниченными "dev", "release", "test" и "bench". Например, для включения оптимизации на этапе связывания (LTO) только при формировании финальных сборок продукта можно в Cargo.toml создать профиль "production" и добавить в него флаг "lto = true". При этом при определении собственных профилей обязательно требуется указать существующий профиль для наследования из него настроек по умолчанию. В примере ниже создаётся профиль "production", который дополняет профиль "release" включением флага "lto = true". Сам профиль активируется при вызове cargo с опцией "--profile production", а сборочные артефакты будут размещены в каталоге "target/production". [profile.production] inherits = "release" lto = true Стабилизировано использование try_reserve для типов Vec, String, HashMap, HashSet и VecDeque, что позволяет заранее резервировать место для определённого числа элементов заданного типа для того, чтобы снизить частоту выполнения операций выделения памяти и избежать аварийного завершения в процессе работы из-за нехватки памяти. Разрешено указание макросов с фигурными скобками в выражениях подобных "m!{ .. }.method()" и "m!{ .. }?". Оптимизировано выполнение функций File::read_to_end и read_to_string. Поддержка спецификации Unicode обновлена до версии 14.0. Расширено число функций, помеченных "#[must_use]" для вывода предупреждения в случае игнорирования возвращаемого значения, что помогает выявить ошибки, вызванные предположением, что функция изменит значения, а не вернёт новое значение. Добавлен экспериментальный бэкенд для генерации кода с использованием libgccjit. В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: [T; N]::as_mut_slice [T; N]::as_slice collections::TryReserveError HashMap::try_reserve HashSet::try_reserve String::try_reserve String::try_reserve_exact Vec::try_reserve Vec::try_reserve_exact VecDeque::try_reserve VecDeque::try_reserve_exact Iterator::map_while iter::MapWhile proc_macro::is_available Command::get_program Command::get_args Command::get_envs Command::get_current_dir CommandArgs CommandEnvs Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в функции hint::unreachable_unchecked. Реализован третий уровень поддержки для платформ armv6k-nintendo-3ds, armv7-unknown-linux-uclibceabihf, m68k-unknown-linux-gnu, aarch64-kmc-solid_asp3, armv7a-kmc-solid_asp3-eabi и armv7a-kmc-solid_asp3-eabihf. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования, публикации официальных сборок и проверки возможности сборки кода.