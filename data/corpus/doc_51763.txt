Релиз языка программирования Haxe 4.0

Доступен релиз тулкита Haxe 4.0, включающего одноимённый мультипарадигменный высокоуровневый язык программирования со строгой типизацией, кросс-компилятор и стандартную библиотеку функций. Проектом поддерживается трансляция в С++, HashLink/C, JavaScript, C#, Java, PHP, Python и Lua, а также компиляция в байт-код JVM, HashLink/JIT, Flash и Neko, с доступом к родным возможностям каждой целевой платформы. Код компилятора распространяется под лицензией GPLv2, а стандартной библиотеки и развиваемой для Haxe виртуальной машины Neko под лицензией MIT. Язык является expression-ориентированным со строгой типизацией. Поддерживаются приёмы объектно-ориентированного, обобщённого и функционального программирования. Синтаксис Haxe близок к ECMAScript и расширяет его такими возможностями, как статическая типизация, автовывод типов, сопоставление шаблонов, дженерики, основанный на итераторах цикл "for", AST-макросы, GADT (Generalized Algebraic Data Types), абстрактные типы, анонимные структуры, упрощённые определения массивов, выражения для условной компиляции, прикрепление метаданных к полям, классам и выражениям, интерполяция строк ('My name is $name'), параметры типов ("new Main<String>('foo')") и многое другое. class Test { static function main() { var people = [ "Elizabeth" => "Programming", "Joel" => "Design" ]; for (name in people.keys()) { var job = people[name]; trace('$name does $job for a living!'); } } } Основные нововведения версии 4.0: Новый синтаксис для указания типа функций "(name:String, age:Int)->Bool" или "(String, Int)->Bool" вместо "String->Int->Bool". Синтаксис стрелочных функций "(a, b) -> a + b" вместо "function(a, b) return a + b". Защита от проблем, связанных с использованием значений Null (экспериментальная функция, включается при желании для определённых полей, классов или пакетов). Ключевое слово "final" для полей классов и локальных переменных, которые являются иммутабельными. "final" также можно использовать для определения функций чтобы запретить их переопределение при наследовании и для классов/интерфейсов, которые не могут быть унаследованы. Поддержка стандарта Unicode для базового типа "String" на всех целей компиляции за исключением Neko. Переписанный с нуля встроенный интерпретатор, который теперь поставляется под именем Eval. Благодаря новому интерпретатору скрипты и макросы выполняются намного быстрее. Поддерживается режим интерактивной отладки. Новая целевая система для компиляции (target) Hashlink - высокопроизводительный runtime, разработанный специально для Haxe, поддерживающий компиляцию в байткод для JIT или C, имеет простую интеграцию с C, а также доступ к низкоуровневым числовым типам и указателям. Реализована новая целевая система JVM, которая позволяет генерировать байткод jvm, пропуская этап компиляции Java-кода через добавление флага "-D jvm" при таргетировании в Java. Возможность inline-развёртывания на месте вызова функций или конструкторов, даже если они не объявлены таковыми. Возможность включения статических расширений при объявлении типа (например "enum") с помощью "@:using(path.ToExtension)". Абстрактные типы теперь поддерживают "set"-версию оператора "@:op(a.b)" для перезагрузки выражений "obj.foo = bar". Синтаксис цикла "for" теперь поддерживает итерацию "ключ-значение": "for (key => value in collection) {}". Поддержка использования xml-like разметки в выражениях: "var a = <hi/>;". Пока эта возможность доступна только для парсинга макросами и находится на этапе дизайна. Синтаксис для опциональных полей в "полной" нотации типов анонимных структур: "{ var ?f:Int; }" (альтернатива "краткой" "{ ?f:Int }"). Значения перечислений теперь могут быть значениями по умолчанию для аргументов функции: "function foo<T>(option:Option<T> = None)". Синтаксис "enum abstract Name(BasicType) {}" больше не требует префикса "@:" в "enum". Авто-нумерация для абстрактных перечислений: enum abstract Foo(Int) { var A; // 0 var B; // 1 } enum abstract Bar(String) { var A; // "A" var B; // "B" } Ключевое слово "extern" больше не требует использование префикса "@:". Удалена возможность "implements Dynamic" для доступа к полям класса через строки. Доступно для extern-классов или через реализацию абстрактным типом. Добавлен синтаксис "A & B" для пересечения типов, который на данный момент применяется только для анонимных структур и ограничений параметров типа. Старый синтаксис ограничений удалён. Создание пустых экземпляров "Map" доступно через синтаксис "var map:Map<Int, String> = [];" по аналогии с массивом. Добавлена структура данных "haxe.ds.ReadOnlyArray". Метаданные теперь могут иметь пространства имен ("@:prefix.name function() {...}"). Аналогично с определениями: "#if (some.flag ... #end". Новый протокол сервисов для IDE, используемых в плагине к VSCode. Обновлены внешние определения (extern) для Web APIs и добавлены отсутствующие.