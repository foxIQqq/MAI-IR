Представлен TuxClocker 1.0, интерфейс для разгона видеокарт NVIDIA

После четырёх с половиной лет разработки опубликован выпуск проекта TuxClocker 1.0, предоставляющего инструменты для оверклокинга (overclock) и мониторинга работы видеокарт. TuxClocker состоит из фонового процесса, управляющего тактовой частотой, напряжением и параметрами системы охлаждения видеокарты, а также графического интерфейса на базе библиотеки Qt. Код написан на С++ и распространяется под лицензией GPLv3. TuxClocker позволяет изменять подаваемое напряжение и частоту работы видеопамяти и ядра GPU, настраивать скорость вращения кулера в зависимости от температуры, ограничивать максимальное энергопотребление в ваттах, создавать профили с сохранёнными настройками и наглядно отслеживать изменение температуры и энергопотребления на графиках. Имеется возможность работы с несколькими GPU (multi-GPU). Новая версия почти полностью переписана. Реализована новая архитектура, в которой выполнение привилегированных операций и взаимодействия с оборудованием вынесено в отдельный фоновый процесс. Предоставлена возможность добавления поддержки нового оборудования через подключение плагинов. В текущем виде в TuxClocker пока поддерживаются только видеокарты NVIDIA (начиная с серии GeForce 600), но разработчики планируют в будущем добавить поддержку и карт AMD. Для управления подготовлен новый интерфейс, использующий иерархическую компоновку, поддерживающую работу одновременно с несколькими GPU и несколькими кулерами. В интерфейсе унифицирована работа со свойствами доступными на запись или допускающими только на чтение. Добавлена возможность автоматического применения значений из профиля. Реализована поддержка рекурсивного сброса настроек в значения по умолчанию и привязки свойств, определяющих диапазоны значений, к любым свойствам, доступным только для чтения, что позволяет создавать гибкие правила разгона, выбирающие пограничные параметры потребления энергии в привязке к температуре. Управляющий интерфейс выполняется с правами непривилегированного пользователя и коммуницирует с фоновым процессом через DBus.