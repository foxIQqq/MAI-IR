Релиз языка программирования Rust 1.20

Доступен релиз языка программирования Rust 1.20, развиваемого проектом Mozilla, обеспечивающего автоматическое управление памятью и предоставляющего средства для высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime. Параллельно с Rust совместно с компанией Samsung развивается экспериментальный браузерный движок Servo, написанный на языке Rust и отличающийся поддержкой многопоточного рендеринга web-страниц и распараллеливанием операций с DOM (Document Object Model). На Rust также разрабатывается операционная система Redox, использующая концепцию микроядра и продвигающая принцип "все есть URL". В подготовке нового выпуска приняли участие 118 разработчиков. Основные новшества: В дополнение к ранее доступной поддержке ассоциированных функций (функции, привязанные непосредственно к типу) в новом выпуске реализована возможность создавать ассоциированные константы. Например, в примере ниже константа ID прикреплена к типу Struct: struct Struct; impl Struct { const ID: u32 = 0; } fn main() { println!("the ID of Struct is: {}", Struct::ID); } Ассоциированные константы также могут быть использованы с типажами (traits) и перечислениями (enum), при этом для типажей допускается определение ассоциированных констант без непосредственного присвоения значения (значение может быть присвоено во время привязки типажа): trait Trait { const ID: u32; } struct Struct; imp Trait for Struct { const ID: u32 = 5; } fn main() { println!("{}", Struct::ID); } В разряд стабильных переведена новая порция функций и методов, в том числе CString::as_c_str, Chain::get_ref, Take::get_ref, f32/64::from_bits, f32/64::to_bits, slice::sort_unstable_*, str::as_bytes_mut, str::get_mut, str::get_* и т.п. В макросе "unimplemented!" обеспечена возможность определения сообщений, информирующих что именно пока не реализовано; Поддержка Unicode обновлена до версии спецификации 10.0.0; Реализация функций min и max для типов с плавающей запятой переписана на языке Rust и больше не связана с cmath; Обеспечена дополнительная защита от атаки Stack Сlash, в результате которой содержимое переполненной кучи может оказаться в области стека или, наоборот, стек может переписать область кучи; В стандартной библиотеке представлены новые функции нестабильной сортировки: slice::sort_unstable_by_key, slice::sort_unstable_by и slice::sort_unstable, которые отличаются от стабильных тем, что работают быстрее, но не гарантируют сохранение порядка следования элементов в группе; Существенно увеличена скорость (до 29 раз) раскрытия макроподстановок в процессе работы компилятора rustc; В пакетном менеджере Cargo хранение параметров аутентификации к crates.io перенесено из общего файла с настройками ~/.cargo/config, который часто доступен на чтение всем пользователям, в специальный файл ~/.cargo/credentials; В Cargo обеспечена сборка бинарных файлов main.rs, размещённых в подкаталогах src/bin, например, на базе src/bin/server/main.rs и src/bin/client/main.rs будут сгенерированы исполняемые файлы target/debug/server и target/debug/client; Добавлена возможность указания версии устанавливаемого исполняемого файла при указании опции "--vers" в "cargo install"; Добавлена новая целевая сборочная платформа wasm32-experimental-emscripten, позволяющая организовать сборку в псевдокод WebAssembly при помощи бэкенда на базе LLVM. Напомним, что язык Rust сфокусирован на безопасной работе с памятью и обеспечении высокого параллелизма выполнения заданий. При этом Rust обходится без использования сборщика мусора или runtime, что делает возможным создания на Rust библиотек, которые могут выступать в роли прозрачной замены библиотекам для языка Си. Для распространения библиотек на языке Rust, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo, позволяющий получить нужные для программы библиотеки в один клик. Для размещения библиотек введён в строй репозиторий crates.io. По структуре язык Rust напоминает C++, но существенно отличается в некоторых деталях реализации синтаксиса и семантики. Автоматическое управление памятью избавляет разработчика от манипулирования указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Rust поддерживает смесь императивных, процедурных и объектно-ориентированных методов с такими парадигмами, как функциональное программирование, обобщённое программирование и метапрограммирование, в статических и динамических стилях.