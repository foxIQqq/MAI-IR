В NPM планируют использовать Sigstore для подтверждения подлинности пакетов

GitHub выставил на обсуждение предложение по внедрению сервиса Sigstore для верификации пакетов по цифровым подписям и ведения публичного лога для подтверждения подлинности при распространении релизов. Применение Sigstore позволит реализовать дополнительный уровень защиты от атак, нацеленных на подмену программных компонентов и зависимостей (supply chain). Например, внедряемое изменение защитит исходные тексты проектов в случае компрометации учётной записи разработчика одной из зависимостей в NPM и формирования злоумышленником обновления пакета с вредоносным кодом. Благодаря новому уровню защиты разработчики смогут привязать сформированный пакет к использованному исходному коду и сборочному окружению, предоставив пользователю возможность убедиться, что содержимое пакета соответствует содержимому исходных текстов в основном репозитории проекта. Применение Sigstore существенно упрощает процесс управления ключами и позволяет избавиться от сложностей, связанных с регистрацией, отзывом и управлением криптографическими ключами. Sigstore преподносится как аналог Let’s Encrypt для кода, предоставляющий сертификаты для заверения кода цифровыми подписями и инструментарий для автоматизации проверки. Вместо постоянных ключей в Sigstore применяются короткоживущие эфемерные ключи, которые генерируются на основе полномочий. Используемый для подписи материал отражается в защищённом от внесения изменений публичном логе, который позволяет убедиться, что автор подписи именно тот, за кого себя выдаёт, и подпись сформирована тем же участником, что отвечал за прошлые релизы. Для обеспечения целостности и защиты от искажения данных задним числом применяется древовидная структура "дерево Меркла" (Merkle Tree), в которой каждая ветка верифицирует все нижележащие ветки и узлы благодаря совместному (древовидному) хешированию. Имея конечный хеш, пользователь может удостовериться в корректности всей истории операций, а также в корректности прошлых состояний БД (корневой проверочный хеш нового состояния базы вычисляется с учётом прошлого состояния).