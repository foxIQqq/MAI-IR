Выпуск языка программирования Rust 1.64

Опубликован релиз языка программирования общего назначения Rust 1.64, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Методы работы с памятью в Rust избавляют разработчика от ошибок при манипулировании указателями и защищают от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами, учёт времени жизни объектов (области видимости) и оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок. Основные новшества: Повышены требования к окружению Linux в компиляторе, пакетном менеджере Cargo и стандартной библиотеке libstd - минимальные требования к Glibc подняты с версии 2.11 до 2.17, а ядра Linux c версии 2.6.32 до 3.2. Ограничения также распространяются на исполняемые файлы Rust-приложений, собранных с libstd. Новым требованиям соответствуют дистрибутивы RHEL 7, SLES 12-SP5, Debian 8 и Ubuntu 14.04. Будет прекращена поддержка RHEL 6, SLES 11-SP4, Debian 7 и Ubuntu 12.04. Пользователям, которые используют собранные инструментарием Rust исполняемые файлы в окружениях со старым ядром Linux, предложено обновить свои системы, оставаться на старых выпусках компилятора или самостоятельно поддерживать своё ответвление libstd с прослойками для сохранения совместимости. Среди причин прекращения поддержки старых Linux-систем упоминаются ограниченные ресурсы по продолжению сопровождения совместимости со старыми окружениями. Поддержка старых Glibc требует использования старого инструментария при проверке в системе непрерывной интеграции, в условиях повышения требований к версиям в LLVM и утилитах кросс-компиляции. Повышение требований к версии ядра связано с возможностью использования в libstd новых системных вызовов без необходимости поддержания прослоек для обеспечения совместимости со старыми ядрами. Стабилизирован типаж IntoFuture, который напоминает IntoIterator, но отличается от последнего использованием ".await" вместо циклов "for ... in ...". В сочетании с IntoFuture ключевое слово ".await" может ожидать не только типаж Future, но и любые другие типы, которые можно сконвертировать в Future. Утилита rust-analyzer включена в состав коллекции утилит, поставляемой в выпусках Rust. Утилита также доступа для установки при помощи rustup (rustup component add rust-analyzer). В пакетном менеджере Cargo реализована возможность наследования рабочей области для исключения дублирования между пакетами типовых значений полей, таких как версии Rust и URL репозиториев. Также добавлена поддержка сборки сразу для нескольких целевых платформ (в опции "--target" теперь можно указывать более одного параметра). В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: future::IntoFuture num::NonZero*::checked_mul num::NonZero*::checked_pow num::NonZero*::saturating_mul num::NonZero*::saturating_pow num::NonZeroI*::abs num::NonZeroI*::checked_abs num::NonZeroI*::overflowing_abs num::NonZeroI*::saturating_abs num::NonZeroI*::unsigned_abs num::NonZeroI*::wrapping_abs num::NonZeroU*::checked_add num::NonZeroU*::checked_next_power_of_two num::NonZeroU*::saturating_add os::unix::process::CommandExt::process_group os::windows::fs::FileTypeExt::is_symlink_dir os::windows::fs::FileTypeExt::is_symlink_file В основной состав (core) и библиотеку alloc добавлены Си-совместимые типы, ранее стабилизированные в модуле std::ffi: core::ffi::CStr core::ffi::FromBytesWithNulError alloc::ffi::CString alloc::ffi::FromVecWithNulError alloc::ffi::IntoStringError alloc::ffi::NulError В модули core::ffi и std::ffi добавлены Си-типы, ранее стабилизированные в модуле std::os::raw (например, для Си-типов uint и ulong предложены типы c_uint и c_ulong): ffi::c_char ffi::c_double ffi::c_float ffi::c_int ffi::c_long ffi::c_longlong ffi::c_schar ffi::c_short ffi::c_uchar ffi::c_uint ffi::c_ulong ffi::c_ulonglong ffi::c_ushort Стабилизированы низкоуровневые обработчики для использования с механизмом Poll (в будущем планируется предоставить упрощённый API, не требующих использования низкоуровневых структур типа Pull и Pin): future::poll_fn task::ready! Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в функции slice::from_raw_parts. С целью более компактного хранения данных изменена раскладка памяти структур Ipv4Addr, Ipv6Addr, SocketAddrV4 и SocketAddrV6. Возможно нарушение совместимости с единичными crate-пакетами, которые используют std::mem::transmute для низкоуровневых манипуляций со структурами. В сборке компилятора rust для платформы Windows задействованы PGO-оптимизации (profile-guided optimization), позволившие поднять производительность компиляции кода на 10-20%. В компиляторе реализовано новое предупреждение о неиспользуемых полях в определённых структурах. Дополнительно можно отметить отчёт о состоянии разработки альтернативной реализации компилятора языка Rust, подготовленной проектом gccrs (GCC Rust) и одобренной для включения в состав GCC. После интеграции фронтэнда штатный инструментарий GCC сможет использоваться для компиляции программ на языке Rust без необходимости установки компилятора rustc, построенного с использованием наработок LLVM. Пока разработка идёт по плану и если не возникнет непредвиденных проблем, фронтэнд для языка Rust будет интегрирован в состав выпуска GCC 13, намеченного на май следующего года. Реализация Rust в GCC 13 будет иметь статус бета-версии, пока не включаемой по умолчанию.