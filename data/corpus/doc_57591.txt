Выпуск языка программирования Go 1.19

Представлен релиз языка программирования Go 1.19, который развивается компанией Google при участии сообщества как гибридное решение, сочетающее высокую производительность компилируемых языков с такими достоинствами скриптовых языков, как лёгкость написания кода, быстрота разработки и защищённость от ошибок. Код проекта распространяется под лицензией BSD. Синтаксис Go основан на привычных элементах языка Си с отдельными заимствованиями из языка Python. Язык достаточно лаконичен, но при этом код легко читается и воспринимается. Код на языке Go компилируется в обособленные бинарные исполняемые файлы, выполняемые нативно, без использования виртуальной машины (модули профилирования, отладки и другие подсистемы выявления проблем на этапе выполнения интегрируются в виде runtime-компонентов), что позволяет добиться производительности, сопоставимой с программами на языке Си. Проект изначально разрабатывается с оглядкой на многопоточное программирование и эффективную работу на многоядерных системах, в том числе предоставляя реализованные на уровне операторов средства для организации параллельных вычислений и взаимодействия между параллельно выполняемыми методами. Язык также предоставляет встроенные средства защиты от выхода за допустимые области выделенных блоков памяти и обеспечивает возможность использования сборщика мусора. Среди изменений в новом выпуске: Проведена работа по оттачиванию добавленной в прошлом выпуске поддержки обобщённых функций и типов (дженериков), при помощи которых разработчик может определить и использовать функции, предназначенные для работы сразу с несколькими типами. Проведена оптимизация - производительность некоторых программ, использующих дженерики, выросла на 20%. В документирующих комментариях добавлена поддержка ссылок, списков и более простого синтаксиса определения заголовков. В утилите gofmt обеспечено форматирование с учётом расширенных возможностей комментариев с документацией на API. Пересмотрена модель памяти для языка Go, которая приведена в соответствие с моделями языков C, C++, Java, JavaScript, Rust и Swift, не поддерживающих последовательные согласованные атомарные значения. Для упрощения использования атомарных значений в пакете sync/atomic предложены новые типы, такие как atomic.Int64 и atomic.Pointer[T]. Изменение модели памяти не повлияло на совместимость с ранее написанным кодом. С целью усиления защиты модуль os/exec теперь не учитывает относительные пути при раскрытии переменной окружения PATH (например, при определении пути для исполняемого файла теперь не проверяется текущий каталог). В сборщике мусора появилась возможность определения мягких ограничений памяти (soft limit), которые применяются путём ограничения размера кучи и более агрессивного возвращения памяти системе, т.е. не гарантируется, что потребление будет находится в заданных рамках в любых условиях. Мягкие ограничения могут быть полезны для оптимизации программ, запускаемых в контейнерах с фиксированным размером памяти. Добавлено новое сборочное ограничение "unix", которое может применяться в строках "go:build" для отсеивания Unix-подобных систем (aix, android, darwin, dragonfly, freebsd, hurd, illumos, ios, linux, netbsd, openbsd, solaris). Реализованы многочисленные оптимизации производительности. Добавлена поддержка динамической установки размера стека сопрограмм для сокращения размера копируемых данных. На Unix-системах реализовано автоматическое задействование дополнительных файловых дескрипторов (увеличение лимита RLIMIT_NOFILE). Для ускорения больших switch-выражений на системах x86-64 и ARM64 задействованы таблицы переходов (jump table), позволяющие обрабатывать большие switch-выражений до 20% быстрее. На системах riscv64 реализована передача аргументов функций через регистры CPU, что позволило добиться прироста производительности примерно на 10%. Добавлена экспериментальная поддержка Linux-окружений на системах с процессорами Loongson на базе 64-разрядной архитектуры LoongArch (GOARCH=loong64).