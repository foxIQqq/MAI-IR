Выпуск Java SE 18

После шести месяцев разработки компания Oracle выпустила платформу Java SE 18 (Java Platform, Standard Edition 18), в качестве эталонной реализации которой используется открытый проект OpenJDK. За исключением удаления некоторых устаревших возможностей в Java SE 18 сохранена обратная совместимость с прошлыми выпусками платформы Java - большинство ранее написанных Java-проектов без изменений будут работоспособны при запуске под управлением новой версии. Готовые для установки сборки Java SE 18 (JDK, JRE и Server JRE) подготовлены для Linux (x86_64, AArch64), Windows (x86_64) и macOS (x86_64, AArch64). Разработанная в рамках проекта OpenJDK эталонная реализация Java 18 полностью открыта под лицензией GPLv2 с исключениями GNU ClassPath, разрешающими динамическое связывание с коммерческими продуктами. Java SE 18 отнесён к категории выпусков с обычным сроком поддержки, обновления для которого будут выпускаться до следующего релиза. В качестве ветки с длительным сроком поддержки (LTS) следует использовать Java SE 17, обновления для которого будут выпускаться до 2029 года. Напомним, что начиная с выпуска Java 10 проект перешёл на новый процесс разработки, подразумевающий более короткий цикл формирования новых релизов. Новая функциональность теперь развивается в одной постоянно обновляемой master-ветке, в которую включаются уже готовые изменения и от которой раз в шесть месяцев ответвляются ветки для стабилизации новых выпусков. Из новшеств Java 18 можно отметить: По умолчанию задействована кодировка UTF-8. Java API, обрабатывающие текстовые данные с учётом кодировки символов, теперь будут по умолчанию использовать UTF-8 на всех платформах, независимо от системных настроек и выставленной локали. Для возвращения старого поведения, в котором кодировка выбирается с учётом системной локали, можно использовать параметр "-Dfile.encoding=COMPAT". В состав включён пакет com.sun.net.httpserver, в которых входит утилита jwebserver и библиотечный API с реализацией простого http-сервера для отдачи статического контента (CGI и servlet-подобные обработчики не поддерживаются). Встроенный http-сервер не оптимизирован для рабочих нагрузок и не поддерживает управление доступом и аутентификацию, так как нацелен главным образом на использование в процессе разработки для создания прототипов, отладки и тестирования проектов. В JavaDoc реализована поддержка тега "@snippet" для встраивания рабочих примеров и фрагментов кода в документацию на API, к которым можно применять средства для проверки корректности, подсветки синтаксиса и интеграции с IDE. Переделана реализация API java.lang.reflect (Core Reflection), предназначенного для получения информации о методах, полях и контрукторах классов, а также доступа к внутренней структуре классов. Сам API java.lang.reflect остался неизменен, но теперь реализован через использование дескрипторов методов (method handles), предоставляемых модулем java.lang.invoke, вместо применения генераторов байткода. Изменение позволило унифицировать реализации java.lang.reflect и java.lang.invoke, и упростить их сопровождение. Предложена третья предварительная реализация API Vector, предоставляющего функции для векторных вычислений, которые выполняются с использованием векторных инструкций процессоров x86_64 и AArch64 и позволяют одновременно применить операции сразу к нескольким значениям (SIMD). В отличие от предоставляемых в JIT-компиляторе HotSpot возможностей по автовекторизации скалярных операций, новый API даёт возможность явно управлять векторизацией для параллельной обработки данных. Добавлен SPI-интерфейс (service-provider interface) для резолвинга имён хостов и IP-адресов, позволяющий задействовать в java.net.InetAddress альтернативные резолверы, не привязанные к обработчикам, предлагаемым операционной системой. Предложена вторая предварительная реализация API Foreign Function & Memory, при помощи которого приложения могут взаимодействовать с кодом и данными, находящимися за пределами Java runtime. Новый API позволяет эффективно вызывать функции, выполняемые не в JVM, и обращаться к памяти, не управляемой JVM. Например, можно вызывать функции из внешних разделяемых библиотек и обращаться к данным процесса без использования JNI. Добавлена вторая экспериментальная реализация сопоставления по шаблону в выражениях "switch", позволяющая в метках "case" использовать не точные значения, а гибкие шаблоны, охватывающие сразу серию значений, для которых ранее приходилось использовать громоздкие цепочки выражений "if...else". Object o = 123L; String formatted = switch (o) { case Integer i -> String.format("int %d", i); case Long l -> String.format("long %d", l); case Double d -> String.format("double %f", d); case String s -> String.format("String %s", s); default -> o.toString(); }; Объявлен устаревшим и будет отключён в одном из следующих выпусков механизм финализации, а также связанные с ним методы, такие как Object.finalize(), Enum.finalize(), Runtime.runFinalization() и System.runFinalization(). В сборщиках мусора ZGC (Z Garbage Collector), SerialGC и ParallelGC реализована поддержка дедупликации строк.