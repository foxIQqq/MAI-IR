Удалённая уязвимость в реализации протокола TIPC в ядре Linux

В поставляемой в ядре Linux реализации сетевого протокола TIPC (Transparent Inter-process Communication) выявлена критическая уязвимость (CVE-2021-43267), позволяющая удалённо через отправку специально оформленного сетевого пакета добиться выполнения своего кода с привилегиями ядра. Опасность проблемы сглаживает то, что для атаки требуется явное включение поддержки TIPC в системе (загрузка и настройка модуля ядра tipc.ko), которая в неспециализированных дистрибутивах Linux не производится по умолчанию. Протокол TIPC поддерживается начиная с ядра Linux 3.19, но приводящий к уязвимости код был включён в состав ядра 5.10. Уязвимость устранена ядрах 5.15.0, 5.10.77 и 5.14.16. Проблема проявляется и пока не устранена в Debian 11, Ubuntu 21.04/21.10, SUSE (в ещё не выпущенной ветке SLE15-SP4), RHEL (пока не детализируется было ли бэкпортировано уязвимое исправление) и Fedora. Обновление ядра уже выпущено для Arch Linux. Дистрибутивы с ядром старше 5.10, такие как Debian 10 и Ubuntu 20.04, проблеме не подвержены. Протокол TIPC изначально разработан компанией Ericsson, предназначен для организации межпроцессного взаимодействия в кластере и активируется главным образом на узлах кластеров. TIPC может работать как поверх Ethernet, так и поверх UDP (сетевой порт 6118). В случае работы поверх Ethernet атака может быть совершена из локальной сети, а при использовании UDP - из глобальной сети, если порт не прикрыт межсетевым экраном. Атака также может быть совершена непривилегированным локальным пользователем хоста. Для активации TIPC необходима загрузка модуля ядра tipc.ko и настройка привязки к сетевому интерфейсу при помощи netlink или утилиты tipc. Уязвимость проявляется в функции tipc_crypto_key_rc и вызвана отсутствием должной проверки соответствия указанного в заголовке и фактического размера данных при разборе пакетов с типом MSG_CRYPTO, используемых для получения ключей шифрования от других узлов в кластере с целью последующей расшифровки сообщений, отправляемых с этих узлов. Размер копируемых в память данных вычисляется как разность значений полей с размером сообщения и размером заголовка, но без учёта фактического размера передаваемого в сообщении названия алгоритма шифрования и содержимого ключа. Подразумевается, что размер названия алгоритма фиксирован, а для ключа дополнительно передаётся отдельный атрибут с размером, и атакующий может указать в этом атрибуте значение, отличающееся от фактического, что приведёт к записи хвоста сообщения за пределы выделенного буфера. struct tipc_aead_key { char alg_name[TIPC_AEAD_ALG_NAME]; unsigned int keylen; /* in bytes */ char key[]; };