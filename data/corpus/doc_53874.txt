Релиз набора компиляторов LLVM 11.0

После шести месяцев разработки представлен релиз проекта LLVM 11.0 - GCC-совместимого инструментария (компиляторы, оптимизаторы и генераторы кода), компилирующего программы в промежуточный биткод RISC-подобных виртуальных инструкций (низкоуровневая виртуальная машина с многоуровневой системой оптимизаций). Сгенерированный псевдокод может быть преобразован при помощи JIT-компилятора в машинные инструкции непосредственно в момент выполнения программы. Ключевым изменением в новом выпуске стало включение в состав Flang, фронтэнда для языка Fortran. Flang поддерживает Fortran 2018, OpenMP 4.5 и OpenACC 3.0, но разработка проекта пока не завершена и фронтэнд ограничивается разбором кода и его проверкой на корректность. Генерация промежуточного кода LLVM пока не поддерживается и для формирования исполняемых файлов генерируется канонический код, который передаётся во внешний компилятор Fortran. Улучшения в Clang 11.0: Добавлена возможность восстановления абстрактного синтаксического дерева (AST) для некорректного кода на C++, которое может использоваться для упрощения диагностики ошибок и предоставляет дополнительную информацию для внешних утилит, таких как clang-tidy и clangd. Возможность по умолчанию включена для кода на C++ и управляется через опции "-Xclang -f[no-]recovery-ast". Добавлены новые режимы диагностики: "-Wpointer-to-int-cast" - группа предупреждений о приведении указателей к целому типу int, не вмещающему все возможные значения. "-Wuninitialized-const-reference" - предупреждение о передаче неинициализированных переменных в параметрах функции, принимающих ссылочные аргументы с признаком "const". "-Wimplicit-const-int-float-conversion" - включённое по умолчанию предупреждение о неявном преобразовании вещественной константы в целый тип. Для платформы ARM предоставлены встроенные в компилятор Си-функции (Intrinsics), заменяемые на эффективные векторные инструкции Arm v8.1-M MVE и CDE. Доступные функции определены в заголовочных файлах arm_mve.h и arm_cde.h. Добавлен набор расширенных целочисленных типов _ExtInt(N), позволяющих создавать типы не кратные степени двойки, которые могут эффективно обрабатываться на FPGA/HLS. Например, _ExtInt(7) определяет целый тип, состоящий из 7 бит. Добавлены макросы, определяющие поддержку встроенных Си-функций на базе инструкций ARM SVE (Scalable Vector Extension): __ARM_FEATURE_SVE, __ARM_FEATURE_SVE_BF16, __ARM_FEATURE_SVE_MATMUL_FP32, __ARM_FEATURE_SVE_MATMUL_FP64, __ARM_FEATURE_SVE_MATMUL_INT8, __ARM_FEATURE_SVE2, __ARM_FEATURE_SVE2_AES, __ARM_FEATURE_SVE2_BITPERM, __ARM_FEATURE_SVE2_SHA3, __ARM_FEATURE_SVE2_SM4. Например, макрос __ARM_FEATURE_SVE определяется при генерации кода AArch64 с установкой опции командной строки "-march=armv8-a+sve". Флаг "-O" теперь отождествляется с режимом оптимизации "-O1" вместо "-O2". Добавлены новые флаги компилятора: "-fstack-clash-protection" - включает защиту от пересечения стека и кучи. "-ffp-exception-behavior={ignore,maytrap,strict}" - позволяет выбрать режим обработчика исключений для чисел с плавающей запятой. "-ffp-model={precise,strict,fast}" - упрощает доступ к серии специализированных опций для чисел с плавающей запятой. "-fpch-codegen" и "-fpch-debuginfo" для генерации предкомпилированного заголовка (PCH) с отдельными объектными файлами для кода и debuginfo. "-fsanitize-coverage-allowlist" и "-fsanitize-coverage-blocklist" для проверки белого и чёрного списков coverage-тестирования. "-mtls-size={12,24,32,48}" для выбора размера TLS (thread-local storage). "-menable-experimental-extension" для включения экспериментальных расширений RISC-V. По умолчанию для Си применён режим "-fno-common", позволяющий повысить эффективность доступа к глобальным переменным на некоторых платформах. Кэш модулей по умолчанию перенесён из /tmp в каталог ~/.cache. Для переопределения можно использовать флаг "-fmodules-cache-path=". Применяемый по умолчанию стандарт языка Си обновлён с gnu11 до gnu17. Добавлена предварительная поддержка расширения GNU C "asm inline" для добавления ассемблерных вставок. Расширение пока только разбирается, но никак не обрабатывается. Расширены возможности, связанные с поддержкой OpenCL и CUDA. Добавлена поддержка диагностики блоков OpenCL 2.0 и реализованы новые возможности OpenMP 5.0. В утилиту clang-format добавлена опция IndentExternBlock для выравнивания внутри блоков extern "C" и extern "C++". В статическом анализаторе улучшена обработка унаследованных конструкторов в C++. Добавлены новые проверки alpha.core.C11Lock и alpha.fuchsia.Lock для проверки блокировок, alpha.security.cert.pos.34c для выявления небезопасного использования putenv, webkit.NoUncountedMemberChecker и webkit.RefCntblBaseVirtualDtor для выявления проблем с несчётными типами, alpha.cplusplus.SmartPtr для проверки разыменования нулевого умного указателя. В linter clang-tidy добавлена большая порция новых проверок. В кеширующем сервере clangd (Clang Server) повышена производительность и добавлены новые возможности диагностики. Основные новшества LLVM 11.0: Система сборки переведена на использование Python 3. Если Python 3 недоступен, то реализована возможность отката на использование Python 2. Из выпуска исключён фронтэнд с компилятором для языка Go (llgo), который возможно будет реструктуризирован в будущем. В промежуточное представление (IR) добавлен атрибут vector-function-abi-variant для описания маппинга между скалярными и векторными функциями для векторизации вызовов. Из llvm::VectorType выделено два отдельных векторных типа llvm::FixedVectorType и llvm::ScalableVectorType. Признано неопределённым поведением ветвление на основе undef-значений и передача undef-значений в функции стандартной библиотеки. В memset/memcpy/memmove разрешена передача undef-указателей, но, если параметр с размером равен нулю. В LLJIT добавлена поддержка выполнения статических инициализаций через методы LLJIT::initialize и LLJIT::deinitialize. Реализована возможность добавления статических библиотек к JITDylib при помощи класса StaticLibraryDefinitionGenerator. Добавлен Си API для ORCv2 (API для сборки JIT-компиляторов). В бэкенд для архитектуры AArch64 добавлена поддержка процессоров Cortex-A34, Cortex-A77, Cortex-A78 и Cortex-X1. Реализованы расширения ARMv8.2-BF16 (BFloat16) и ARMv8.6-A, включая RMv8.6-ECV (Enhanced Counter Virtualization), ARMv8.6-FGT (Fine Grained Traps), ARMv8.6-AMU ( Activity Monitors virtualization) и ARMv8.0-DGH (Data gathering hint). Обеспечена возможность генерации кода для встроенных функций-обвязок к векторным инструкциям SVE. В бэкенд для архитектуры ARM добавлена поддержка процессоров Cortex-M55, Cortex-A77, Cortex-A78 и Cortex-X1. Реализованы расширения Armv8.6-A Matrix Multiply и RMv8.2-AA32BF16 BFloat16. В бэкенд для архитектуры PowerPC добавлена поддержка генерации кода для процессоров POWER10. Расширены оптимизации циклов и улучшена поддержка операций с плавающей запятой. В бэкенде для архитектуры RISC-V разрешён приём патчей с поддержкой экспериментальных расширенных наборов инструкций, ещё официально не одобренных. Бэкенд для архитектуры AVR переведён из категории экспериментальных в стабильные, включённые в базовую поставку. В бэкенде для архитектуры x86 реализована поддержка инструкций Intel AMX и TSXLDTRK. Добавлена защита от атак LVI (Load Value Injection), а также реализован общий механизм Speculative Execution Side Effect Suppression для блокирования атак, вызванных спекулятивным выполнением операций в CPU. В бэкенде для архитектуры SystemZ добавлена поддержка MemorySanitizer и LeakSanitizer. В Libc++ добавлена поддержка заголовочного файла с математическими константами <numbers>. Расширены возможности компоновщика LLD. Улучшена поддержка формата ELF, в том числе добавлены опции "--lto-emit-asm", "--lto-whole-program-visibility", "--print-archive-stats", "--shuffle-sections", "--thinlto-single-module", "--unique", "--rosegment", "--threads=N". Добавлена опция "--time-trace" для сохранения трассировки в файл, который затем можно проанализировать через интерфейс chrome://tracing в Chrome.