Выпуск Pyston 0.6, реализации языка Python с JIT-компилятором

Увидел свет релиз проекта Pyston 0.6, в рамках которого компанией Dropbox, в которой работает Гвидо ван Россум, развивается высокопроизводительная реализация языка Python, созданная с использованием наработок проекта LLVM. Реализация примечательна применением современных технологий JIT-компиляции и нацелена на достижение высокой производительности, близкой к производительности традиционных системных языков, таких как C++. Код Pyston написан на языке C++ и распространяется под лицензией Apache. В отличие от проекта PyPy, также продвигающего идею применения JIT для ускорения выполнения Python-скриптов, в Pyston используется не трассирующий JIT, базирующийся на компиляции в машинный код часто выполняемых циклов, а применяемый в современных JavaScript-движках JIT на основе трансляции отдельных методов (method-at-a-time), который, по мнению инженеров Dropbox, является более перспективной технологией. Принцип работы Pyston сводится к разбору кода на языке Python и его трансляции в промежуточное представление LLVM (IR, Intermediate Representation). Далее IR-представление проходит обработку в оптимизаторе LLVM и передаётся для исполнения в JIT-движок LLVM, который преобразует IR-представление в машинный код. Для получения информации о типах переменных для программ на динамическом языке Python применяется техника вероятностного предсказания типов объектов с последующим уточнением правильности выбора типа в процессе выполнения. Таким образом Pyston постоянно варьирует выполнение между двумя ветками - быстрой, когда данные о предсказанных типах подтверждаются, и медленной, используемой в случае рассогласования данных о типе. Работа может осуществляться в многопоточном режиме, допускающем параллельное выполнение нескольких нитей кода на языке Python и избавленном от глобальной блокировки интерпретатора (GIL, global interpreter lock). При подготовке новой версии основное внимание было уделено снижению потребления памяти. Одним из главных шагов для уменьшения потребления памяти стал уход от древовидного представления инструкций интерпретатора в пользу хранения в форме реального байткода. Инструкции теперь следуют одна за другой в памяти без дробления с использованием указателей. Кроме уменьшения размера потребляемой памяти подобный подход также позволяет достичь более агрессивного освобождения неиспользуемой памяти. Например, после компиляции при помощи LLVM JIT часто используемых функций, теперь можно освободить память, в которой размешался код, ранее подготовленный с применением встроенного JIT. Потребление памяти также сокращено за счёт повышения эффективности стадий анализа кода и устранению утечек памяти. В итоге, в некоторых тестах потребление памяти снизилось до двух раз, по сравнению с Pyston 0.5.1; В новом выпуске также представлена большая порция исправлений, устраняющих проблемы совместимости с CPython. Для упрощения замены CPython на Pyston проведена унификация структуры директорий и порядка следования записей в типе dict. Изменения позволили добиться выполнения в Pyston немодифицированных программ pip и virtualenv. Что касается производительности, то несмотря на то, что специальных оптимизиаций не добавлялось, при оценке производительности операций при помощи библиотеки NumPy, Pyston уже приблизился к CPython, а в некоторых тестах даже немного обгоняет его.