Выпуск языка программирования Rust 1.49

Опубликован релиз языка системного программирования Rust 1.49, основанного проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Автоматическое управление памятью в Rust избавляет разработчика от ошибок при манипулировании указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Обеспечен первый уровень поддержки 64-разрядных систем ARM (aarch64) в окружениях на базе ядра Linux и Glibc (aarch64-unknown-linux-gnu). Ранее на первом уровне обеспечивалась поддержка архитектур x86_64 (Linux, macOS, Windows) и i686 (Linux, Windows). В окружениях macOS и Windows уровень поддержки ARM 64 доведён до второго уровня (aarch64-apple-darwin, aarch64-pc-windows-msvc). Добавлена поддержка систем Apple, оснащённых новым ARM-чипом M1. Реализован третий уровень поддержки платформы MIPS little-endian (mipsel-unknown-none). Напомним, что на первом уровне поддержки формируются бинарные сборки, проводится доскональное тестирование и предоставляются наивысшие гарантии поддержки платформы - каждое изменение в компиляторе проверяется выполнением полного тестового набора. На втором уровне формируются бинарные пакеты и гарантируется возможность сборки, но не гарантируется корректная работа бинарных сборок и не проводятся полные тесты функциональности. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования, публикации официальных сборок и проверки возможности сборки кода. Во встроенном тестовом фреймворке улучшена обработка сценариев проверки многопоточных обработчиков. Вывод тестов, выполняемых в отдельных потоках, теперь не перемешивается с сообщениями тестового фреймворка. Весь диагностический вывод оформлен единым блоком, который сохраняется в лог, но выводится на экран только в случае сбоя или выполнения операции "panic!". #[test] fn thready_pass() { println!("fee"); std::thread::spawn(|| { println!("fie"); println!("foe"); }) .join() .unwrap(); println!("fum"); } ❯ cargo test Compiling threadtest v0.1.0 Finished test [unoptimized + debuginfo] target(s) in 0.52s Running target/debug/deps/threadtest-40aabfaa345584be running 1 test test thready_pass ... FAILED failures: ---- thready_pass stdout ---- fee fie foe fum thread 'thready_pass' panicked at 'explicit panic', src/lib.rs:11:5 В шаблонах реализована возможность привязки по ссылке или перемещению, которая позволяет выборочно заимствовать (borrow) отдельные компоненты типа. #[derive(Debug)] struct Person { name: String, age: u8, } let person = Person { name: String::from("Alice"), age: 20, }; // `name` is moved out of person, but `age` is referenced. let Person { name, ref age } = person; println!("{} {}", name, age); Разрешено приведение перечислений без вариантов (например, enum Void) в целые типы с использованием оператора "as". pub enum Void {} #[no_mangle] pub fn bar(v: Void) -> usize { v as usize } В разряд стабильных переведена новая порция API, в том числе стабилизированы методы slice::select_nth_unstable, slice::select_nth_unstable_by и slice::select_nth_unstable_by_key. Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в методах Poll::is_ready и Poll::is_pending. В пакетном менеджере Cargo в команду "cargo metadata" добавлена поддержка полей "homepage" и "documentation". Добавлена переменная окружения CARGO_PRIMARY_PACKAGE, которая устанавливается при сборке в rustc корневого пакета, указанного в командной строке. В именах пакетов и целевых платформ разрешено использование масок, например "-p 'serde*'" или "--test '*'". Обеспечена возможность независимой повторяемой пересборки crate-пакетов при помощи команды cargo-package. Требования к минимально поддерживаемой версии LLVM подняты до LLVM 9.