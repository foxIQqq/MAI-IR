Выпуск языка программирования Python 3.12

После года разработки опубликован значительный выпуск языка программирования Python 3.12. Новая ветка будет поддерживаться в течение полутора лет, после чего ещё три с половиной года для неё будут формироваться исправления с устранением уязвимостей. Одновременно началось альфа-тестирование ветки Python 3.13, в которой появился режим сборки CPython без глобальной блокировки интерпретатора (GIL, Global Interpreter Lock). Ветка Python 3.13 будет находиться на стадии альфа-выпусков в течение семи месяцев, во время которых будут добавляться новые возможности и производиться исправление ошибок (в соответствии с новым графиком разработки работа над новой веткой начинается за пять месяцев до релиза предыдущей ветки и к моменту очередного релиза достигает стадии альфа-тестирования). После этого в течение трёх месяцев будет проводиться тестирование бета-версий, во время которого добавление новых возможностей будет запрещено и всё внимание будет уделяться исправлению ошибок. Последние два месяца перед релизом ветка будет находиться на стадии кандидата в релизы, на которой будет выполнена финальная стабилизация. Среди добавленных в Python 3.12 новшеств: Повышена гибкость разбора f-строк (форматируемые литералы с префиксом 'f'), позволившая избавиться от многих ограничений. Например, внутри f-строк теперь можно указывать любые допустимые для Python выражения, включая многострочные выражения, комментарии, обратные слэши и escape-последовательности для Unicode. Кроме того, во внутренней строке теперь допускается повторное использование тех же кавычек, что и в обрамлении f-строки (т.е. внутри теперь повторно можно использовать двойные кавычки, не переходя на одинарные). Повышена информативность сообщений об ошибках в f-строках, в которых теперь указывается точное место в строке, вызвавшее ошибку. Например в Python 3.12 допускаются следующие конструкции: print(f"This is the playlist: {"\n".join(songs)}") print(f"This is the playlist: {"\N{BLACK HEART SUIT}".join(songs)}") print(f"This is the playlist: {", ".join([ ... 'Take me back to Eden', # My, my, those eyes like fire ... 'Alkaline', # Not acid nor alkaline ... 'Ascensionism' # Take to the broken skies at last ... ])}") Для повышения эффективности использования ресурсов многоядерных систем реализована поддержка изолированных субинтерпретаторов и отдельных глобальных блокировок (GIL, Global Interpreter Lock) для разных интерпретаторов внутри процесса (CPython позволяет в одном процессе выполнять сразу несколько интерпретаторов). В текущем виде возможность пока доступна только через C-API (в Python API поддержка появится в следующей значительной ветке). В Python-коде добавлена возможность использования протокола buffer. Классы, предоставляющие метод "__buffer__()", теперь могут использоваться как типы, напрямую работающие с бинарными данными в памяти. Предложен модуль sys.monitoring для отладки и профилирования, позволяющий с минимальными накладными расходами отслеживать такие события в CPython, как вызовы, возвраты из функций, выполнение произвольных строк кода, исключения и переходы. В интерпретаторе реализована поддержка подсистемы ядра Linux perf, позволяющая определять имена Python-функций при профилировании при помощи утилиты perf (ранее в трассировках определялись только имена Си-функций). Повышена информативность сообщений об ошибках и расширен спектр исключений, предлагающих рекомендации по устранению опечаток. Например, теперь выводятся рекомендации по импорту забытых модулей стандартной библиотеки, показываются подсказки по добавлению префикса "self." в методах, определяется написание "import x from y" вместо "from y import x" и т.п. sys.version_info NameError: name 'sys' is not defined. Did you forget to import 'sys'? somethin = blech NameError: name 'blech' is not defined. Did you mean: 'self.blech'? import a.y.z from b.y.z SyntaxError: Did you mean to use 'from ... import ...' instead? from collections import chainmap ImportError: cannot import name 'chainmap' from 'collections'. Did you mean: 'ChainMap'? Продолжена работа по оптимизации производительности. Суммарный прирост производительности в результате добавленных оптимизаций оценивается в 5%. В процесс сборки добавлена экспериментальная поддержка бинарного оптимизатора BOLT, повышающего производительность на 1-5%. Реализовано inline-развёртывание списковых включений (comprehensions), до двух раз ускоряющее работу со списковыми включениями (для кода, в котором активно используются списковые включения, тестирование показало общий прирост производительности на 11%). На 8-16 байт уменьшен размер Unicode-объектов. Ускорены операции с регулярными выражениями re.sub(), re.subn() и re.Pattern. От 2 до 20 раз ускорено выполнение проверок isinstance() для некоторых протоколов. Значительно повышена производительность пакета asyncio (в некоторых тестах наблюдается ускорение на 75%). Ускорено создание класса asyncio.Task. Значительно (в некоторых тестах на 64%) ускорены функции tokenize.tokenize() и tokenize.generate_tokens(). Ускорена загрузка атрибутов и вызов метода super(). Предложен новый более компактный синтаксис аннотирования типов для обобщённых классов и функций. def max[T](args: Iterable[T]) -> T: ... class list[T]: def __getitem__(self, index: int, /) -> T: ... def append(self, element: T) -> None: ... Предоставлен новый способ определения псевдонимов типов при помощи выражения "type" type Point = tuple[float, float] type Point[T] = tuple[T, T] В модуль typing добавлен новый декоратор @override, информирующий системы проверки типов о том, что метод в подклассе предназначен для переопределения метода или атрибута в суперклассе. Декоратор может использоваться для выявления ошибок, связанных с тем, что предназначенный для переопределения метод не выполняет данное действие. class Base: def log_status(self) -> None: ... class Sub(Base): @override def log_status(self) -> None: # Ok, переопределяет Base.log_status ... @override def done(self) -> None: # Система проверки типов выявит ошибку ... С целью усиления безопасности встроенные реализации алгоритмов SHA1, SHA3, SHA2-384, SHA2-512 и MD5 в hashlib заменены на формально верифицированные варианты от проекта HACL* (встроенные реализации применяются только если отсутствует OpenSSL). В СPython реализована защита от переполнения стека. В классе pathlib.Path реализована поддержка подклассов. В модуле os расширена поддержка платформы Windows. Например, при работе в Windows добавлена поддержка методов os.listdrives(), os.listvolumes() и os.listmounts(), а также повышена точность os.stat() и os.lstat(). В модули sqlite3 и uuid добавлены интерфейсы командной строки ("python -m sqlite3" и "python -m uuid"). В C-API добавлена поддержка "бессмертных" объектов, для которых не применяется подсчёт ссылок. Реализована концепция нестабильного уровня C API, предназначенного для использования в отладчиках, JIT-компиляторах и прочих низкоуровневых инструментах. Проведена чистка устаревших возможностей. Удалены модули asynchat, asyncore, smtpd, imp и distutils (модуль distutils можно использовать из пакета setuptools). Из Си-реализации unicode-объектов удалены свойства wstr и wstr_length. Удалены устаревшие методы в модуле unittest. Удалены устаревшие или нормально неработающие функции, классы и методы, включая locale.format(), io.OpenWrapper, ssl.RAND_pseudo_bytes(), ElementTree.Element.copy(), hashlib.pbkdf2_hmac(), gzip.GzipFile и т.д. В модуле webbrowser прекращена поддержка старых браузеров, среди которых Grail, Mosaic, Netscape, Galeon, Skipstone, Iceape, Firebird, и Firefox до версии 36. В рамках подготовки к внесению будущих оптимизаций изменено внутреннее представление целых чисел.