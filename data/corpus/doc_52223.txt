Red Hat развивает JIT-компилятор MIR

В компании Red Hat ведётся разработка нового легковесного JIT-компилятора MIR, обеспечивающего выполнение кода, предварительно преобразованного в промежуточное представление MIR (Medium Internal Representation, не путать с другим промежуточным представлением MIR (mid-level IR), применяемым в компиляторе Rust). Проект нацелен на предоставление основы для реализации быстрых и компактных интерпретаторов и JIT. Код проекта написан на языке Си и распространяется под лицензией MIT. На текущей стадии разработки трансляторы в промежуточное представление MIR подготовлены для языка Си и биткода LLVM (Bitcode), но в будущем планируется реализовать возможность генерации MIR для WebAssembly, байткода Java, CIL (Common Intermediate Language), Rust и C++. Проект развивается одним из разработчиков JIT-движка MJIT, используемого в Ruby. В первую очередь JIT на базе MIR планируется реализовать для CRuby и MRuby. В будущем также не исключается возможность портирования GCC на использование MIR. Промежуточный код MIR может быть представлен в бинарном и текстовом (читаемом) виде. Данный код можно будет исполнить в интерпретаторе, сгенерировать на его основе машинный код (x86_64, в планах ARM64, PPC64 и MIPS64). Возможно и выполнение обратного преобразования - из MIR в CIL, байткод Java, WebAssembly и код на языке Си. Из особенностей MIR выделятся строгая типизация, поддержка модулей и функций, предоставление набора инструкций для преобразования типов, сравнения, арифметических и логических операций, ветвления и т.п. Модули, включающие набор функций, преобразованных в формат MIR, могут загружаться в форме библиотек, а также загружать внешний код на языке Си. Ключевым достоинством выполнения промежуточного кода в JIT вместо компиляции в нативные исполняемые файлы, является возможность формирования компактных файлов, которые могут выполняться без пересборки на разных аппаратных архитектурах (x86, ARM, PPC, MIPS). Для неподдерживаемых архитектур доступен режим интерпретации, который в случае MIR работает в 6-10 раз медленнее JIT. Из недостатков существующих JIT-компиляторов GCC и LLVM называется их излишняя раздутость, низкая скорость компиляции и трудность реализации комбинированных оптимизаций для разных языков программирования. Разработчики MIR попытались решить эти проблемы и поставили перед собой цели: Компиляция в MIR должна осуществляться как минимум в 100 раз быстрее, чем в GCC; JIT для исполнения MIR должен быть очень компактным и включать примерно 15 тысяч строк кода; Исполнение MIR с использованием JIT должно быть не более чем на 30% медленнее, чем производительность исполняемого файла, собранного на основе того же Си-кода в GCC (с оптимизациями "-O2"); Стадии инициализации до начала фактического исполнения должны занимать в 100 раз меньше времени; MIR-представление для JIT должны быть в 100 раз меньше собранного в GCC исполняемого файла. В текущем виде реализация MIR во многим опережает изначально поставленные цели: проведённые тесты показали, что производительность компиляции в MIR быстрее "GCC -O2" в 178 раз, производительность исполнения отстаёт от нативного кода на 6%, размер кода меньше в 144 раза, реализация MIR JIT составляет 16 тысяч строк кода.