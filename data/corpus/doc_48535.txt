Релиз набора компиляторов GCC 8

После года разработки опубликован релиз свободного набора компиляторов GCC 8.1, первый значительный выпуск в новой ветке GCC 8.x. В соответствии с новой схемой нумерации выпусков, версия 8.0 использовалась в процессе разработки, а незадолго до выхода GCC 8.1 уже ответвилась ветка GCC 9.0, на базе которой будет сформирован следующий значительный релиз GCC 9.1. GCC 8.1 примечателен реализацией некоторых возможностей будущего стандарта C++20 (кодовое название C++2a), существенным расширением средств диагностики, значительным улучшением PGO-оптимизаций (Profile-guided optimization), включением новых оптимизаций выполнения циклов, обеспечением поддержки SVE (Scalable Vector Extension) для архитектуры AArch64, поддержкой CPU Intel Cannonlake и Intel Icelake. Основные изменения: Добавлена экспериментальная поддержка части будущего стандарта C++2a. Для включения поддержки C++2a следует использовать опции "-std=c++2a" и "-std=gnu++2a"; В libstdc++ добавлены новые возможности стандартов C++17 и C++2a: std::filesystem, std::char_traits, std::to_chars, std::from_chars, std::to_address и std::endian. Добавлена поддержка расширений математических функций __gnu_cxx::airy_ai и __gnu_cxx::airy_bi; Существенно улучшен механизм оптимизации на основе результатов профилирования кода (PGO - Profile-guided optimization), который генерирует более оптимальный код на основе анализа особенностей выполнения кода. На системах x86/x86_64 тело функции теперь разделяется на горячие и холодные регионы выполнения, данный режим оптимизации (-freorder-blocks-and-partition) по умолчанию применяется начиная с уровня "-O2"; В системе оптимизации на этапе связывания (LTO) представлен новый способ подстановки отладочной информации в формате DWARF, что упрощает отладку оптимизированного кода; Добавлены новые оптимизации циклов: "-floop-unroll-and-jam" (раскрутка внешнего цикла и слияние копий внутреннего цикла) и "-floop-interchange" (обмен циклами во вложенном цикле для улучшения локализации данных). Улучшена работа оптимизации "-ftree-loop-distribution" (расщепление тела вложенного цикла на несколько циклов). Включены по умолчанию при выборе режима "-O3" оптимизации "-ftree-loop-distribution", "-floop-unroll-and-jam" и "-floop-interchange". Полностью переработан режим оптимизации "-floop-nest-optimize". Для тонкого управления оптимизациями раскрутки цикла добавлена новая pragma "unroll"; Улучшены межпроцедурные оптимизации: переработаны собираемые в процессе выполнения оценочные метрики, которые теперь более реалистично отражают ситуации, для которых можно использовать inline-развёртывание или клонирование; Добавлена опция "-fcf-protection=[full|branch|return|none]", позволяющая повысить защищённость собираемого приложения благодаря выполнению проверок целевых адресов в инструкциях передачи потока выполнения (например, при косвенных вызовах функций, возврате из функций и косвенных jump-переходов); Добавлена опция "-fstack-clash-protection", при указании которой компилятор подставляет проверочные вызовы (probe) при каждом статическом или динамическом выделении места для стека, которые позволяют выявлять факты переполнения стека и блокировать методы атак, связанные с пробросом потока выполнения через guard-страницы защиты стека; В детекторе неопределенного поведения (Undefined Behavior Sanitizer), выявляющего ситуации, когда поведение программы становится неопределенным (зависит от реализации компилятора) из-за ошибки программиста, предложены две новые опции: "-fsanitize=builtin" для диагностики некорректных аргументов вызовов __builtin_clz или __builtin_ctz, и "-fsanitize=pointer-overflow" для проверки появления недопустимых значений указателей; В Address Sanitizer добавлены режимы "-fsanitize=pointer-compare" и "-fsanitize=pointer-subtract", выводящие предупреждение о выполнении операций вычитания или сравнения над указателями, которые ссылаются на разные объекты в памяти; Значительно расширены средства диагностики, обеспечено более точное определение местоположения проблем в коде и представлены подсказки по устранению проблем. Например, в случае пропущенных скобок '}' и ')' компилятор теперь указывает на место возможного пропуска. В случае обращения к приватным полям класса или структуры, выдаётся подсказка по использованию функции-обёртки. Показывается когда можно использовать static_cast, const_cast и reinterpret_cast. Не подходящие друг другу типы шаблонов выделяются цветом или могут быть визуализированы (-fdiagnostics-show-template-tree) в иерархическом виде; В компиляторы C и C++ добавлены новые предупреждения: "-Wmultistatement-macros" (небезопасное раскрытие макроса), "-Wstringop-truncation" (при усечении строки, копируемой через strncat, strncpy и stpncpy), "-Wif-not-aligned" (некорректное определение объектов с атрибутом warn_if_not_aligned), "-Wmissing-attributes" (пропущены атрибуты при определении функции), "-Wpacked-not-aligned" (struct или union определены с атрибутом packed и выравниванием больше 1), "-Wcast-function-type" (некорректное приведение типа для указателя на функцию), "-Wsizeof-pointer-div", "-Wcast-align=strict", "-Wclass-memaccess". В режимах "-Warray-bounds", "-Wformat-overflow" и "-Wformat-truncation" расширено число распознаваемых ситуаций выхода за границы массивов и переполнений буфера; Включена по умолчанию опция "-gcolumn-info", при которой в отладочную информацию DWARF добавляются не только имя файла и номер строки, но и данные о столбце; Поддержка развиваемого компанией Google языка программирования Go обновлена до версии 1.10.1. Сборщик мусора переведён на работу в параллельном режиме; Для архитектуры ARM64 (AArch64) добавлена поддержка механизма SVE (Scalable Vector Extension), предоставляющего расширенные инструкции для векторной обработки данных, дополняющие набор NEON средствами для ускорения операций векторизации для научных вычислений; Добавлена поддержка архитектур ARM: Armv8-R (-march=armv8-r), Armv8.3-A (-march=armv8.3-a) и Armv8.4-A (-march=armv8.4-a) и процессоров Arm Cortex-A75 (cortex-a75), Arm Cortex-A55 (cortex-a55), Arm Cortex-A55/Cortex-A75 DynamIQ big.LITTLE (cortex-a75.cortex-a55) и Arm Cortex-R52 для Armv8-R (cortex-r52); Добавлена поддержка процессоров Intel Cannonlake (-march=cannonlake) c расширениями AVX512VBMI, AVX512IFMA и SHA, и Intel Icelake (-march=icelake) c расширениями AVX512VNNI, GFNI, VAES, AVX512VBMI2, VPCLMULQDQ, AVX512BITALG, RDPID и AVX512VPOPCNTDQ; Для систем x86 добавлена поддержка расширения CET (Intel Control-flow Enforcement Technology) активируемого при помощи опций "-mibt", "-mshstk" и "-mcet"; Удалена поддержка устаревшего формата отладочной информации SDB/coff, опция "-gcoff" больше не поддерживается; Удалена поддержка расширений Cilk+ и MPX для языков C и C++, с реализацией предложенной компанией Intel методики параллельного программирования и механизма защиты памяти.