Сравнение производительности компиляторов GCC, Clang и LLVM-GCC

Экспериментаторы с ресурса Phoronix дополнили опубликованное в понедельник сравнение производительности компиляторов GCC (4.3, 4.4, 4.5) и опубликовали более полный отчет, в котором отражены результаты измерения производительности Clang и LLVM-GCC. Напомню, что в рамках проекта LLVM ведется разработка GCC совместимого инструментария (компиляторы, оптимизаторы и генераторы кода), компилирующего программы в промежуточный байткод RISC-подобных виртуальных инструкций (низкоуровневая виртуальная машина с многоуровневой системой оптимизации). Сгенерированный платформонезависимый псевдокод может быть преобразован при помощи JIT-компилятора в машинные инструкции непосредственно в момент выполнения программы. Результаты тестирования: Тесты на время сборки: LLVM-GCC и Clang выполнили операцию сборки Apache на 20% быстрее GCC. Сборка PHP была выполнена LLVM-GCC на 25% быстрее, но при использовании Clang возникли проблемы со сборкой. При сборке ImageMagic проблемы с компиляцией возникли в LLVM-GCC, а Clang завершил процесс сборки на несколько процентов медленнее GCC. При измерении производительности Apache, собранного разными компиляторами, производительность LLVM-GCC оказалась примерно на уровне GCC, но clang-сборка продемонстрировала повышение производительности на 9%. При измерении скорости сжатия утилитой 7-zip, clang показал результаты на уровне GCC, а LLVM-GCC продемонстрировал десятикратный провал производительности. При кодировании MP3 паком LAME, Clang оказался медленнее GCC на 12%, а LLVM-GCC медленнее на 7%. Скорость прохождения тестов Gcrypt и C-Ray оказалась примерно одинаковой для GCC и LLVM-GCC. Clang не смог выполнить тест Gcrypt и оказался на 4% медленее в тесте C-Ray; В тесте BYTE Unix Benchmark (Dhrystone 2) возможности LLVM-GCC и Clang проявились в полной мере: LLVM-GCC обогнал GCC на 43%, а Clang на 28%. В тесте GraphicsMagick Clang отстал от GCC на 18%, а LLVM-GCC наоборот обогнал GCC на 8%; В тесте Himeno LLVM-GCC оказался на уровне GCC, а Clang отстал на 60%. В тесте John The Ripper LLVM-GCC отстал от GCC на 60%, а Clang вообще не смог выполнить тест; В тесте HMMer LLVM-GCC и Clang оказались на 23% медленнее GCC. В целом LLVM / Clang не оправдали возложенные на них ожидания, но эти проекты находятся в активной стадии разработки и не исключено, что уже в ближайшем будущем ситуация может кардинально измениться. Постепенно открытые проекты начинают обращать внимание на Clang и тестировать свой код на совместимость, например большая работа в направлении улучшения поддержки и выявления ошибок ведется в настоящее время разработчиками FreeBSD, которым уже удалось добиться полной пересборки ядра, базовой системы и большого числа популярных портов. Также отмечается, что в исследовании рассмотрен лишь вопрос производительности, без акцентирования внимания на такие преимущества LLVM, как возможность компиляции программы в переносимый между разными платформами универсальный байткод. С другой стороны, GCC имеет фронтэнды для большего числа языков программирования (например, Java и Fortran отсутствуют в LLVM), поддерживает значительно более широкий спектр аппаратных платформ и задействует больше механизмов оптимизаций, привязанных к этим платформам. Кроме того, поддержка C++ в GCC реализована более полно, по сравнению с CLang.