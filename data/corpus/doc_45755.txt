Выпуск языка программирования Python 3.6

После 15 месяцев разработки представлен значительный релиз языка программирования Python 3.6. Среди добавленных новшеств: Добавлена поддержка форматируемых строковых литералов, позволяющих определить строку, содержащую подстановки. Заданные в фигурных скобках выражения вычисляются и подставляются в текст строки во время выполнения программы и форматируются с использованием протокола format(). Например: >>> name = "Fred" >>> f"He said his name is {name}." 'He said his name is Fred.' >>> width = 10 >>> precision = 4 >>> value = decimal.Decimal("12.34567") >>> f"result: {value:{width}.{precision}}" # nested fields 'result: 12.35' Возможность использования символов подчёркивания для улучшения читаемости чисел, например, теперь можно указывать 1_000_000 или 0x_FF_FF_FF; Определён синтаксис аннотаций для переменных, позволяющий передать интерпретатору информацию о типах переменных. Аннотации сохраняются в атрибуте __annotations__ класса или модуля, но в отличие от языков со статической типизацией не накладывают каких-либо ограничений, а служат для структурирования метаданных, которые могут использоваться сторонними инструментами и библиотеками. Например: primes: List[int] = [] captain: str # Note: no initial value! class Starship: stats: Dict[str, int] = {} Возможность определения асинхронных генераторов. В прошлой ветке Python 3.5 был реализован новый синтаксис async / await для определения сопрограмм, но в теле одной функции невозможно было одновременно использовать await и yield. В Python 3.6 данное ограничение снято, что позволяет определять генераторы, работающие в асинхронном режиме: async def ticker(delay, to): """Yield numbers from 0 to *to* every *delay* seconds.""" for i in range(to): yield i await asyncio.sleep(delay) Добавлена возможность асинхронной обработки списковых включений (comprehensions) через использование выражения "async for" для списков, множеств и словарей. Также допускается применение выражений await для всех видов списковых включений. Например: result = [i async for i in aiter() if i % 2] result = [await fun() for fun in funcs if await condition()] Переработана реализация типа dict, которая переведена на более компактное представление, похожее на реализацию от проекта PyPy. В итоге удалось сократить потребление словарями памяти на 20-25% и обеспечить хранение с сохранением порядка следования записей (упорядочивание позиционируется как особенность, которая может измениться в будущем, поэтому до определения упорядочивания в спецификации полагаться на данную возможность не стоит); Представлен новый метод "__init_subclass__", упрощающий настройку подкласса без использования метакласса; Обеспечено сохранение порядка определения атрибутов класса (прядок можно отследить через сохраняемый в классах атрибут "__dict__"); Порядок определения аргументов ключевых слов, передаваемых в функцию, теперь соответствует порядку элементов в **kwargs; Добавлена поддержка контрольных вызовов (probe) DTrace и SystemTap. При сборке с опцией "--with-dtrace" Python может устанавливать маркеры для таких событий, как вызов и выход из функции, начало/завершение сборки мусора и выполнение строки кода; Представлена новая переменная окружения PYTHONMALLOC, через которую можно выбрать механизм распределения памяти для Python или включить отладочные хуки. Например, при указании "PYTHONMALLOC=debug" добавляются средства определения выхода за границы буфера, применяется специально заполнение новых и освобождённых блоков и т.п. Стабилизирован API модуля asyncio, значительно увеличена производительность и расширена функциональность; Добавлен протокол для определения путей в файловой системе в виде отдельных объектов pathlib. Например: >>> import pathlib >>> with open(pathlib.Path("README")) as f: ... contents = f.read() В функции datetime.datetime и datetime.time из модуля datetime добавлен атрибут fold, информирующий о вхождении в неоднозначные промежутки времени, например в промежуток, возникающий при переводе часов на час назад; В разряд стабильных переведён модуль typing; Значительно переработан модуль tracemalloc, расширены средства диагностики ошибок при распределении памяти; В состав стандартной библиотеки включён новый модуль secrets, предоставляющий средства для генерации криптографически надёжных псевдослучайных чисел, пригодных для формирования различных ключей и токенов; На платформе Linux при вызове os.urandom() обеспечено ожидание завершения инициализации энтропии для генератора urandom; В модулях hashlib и ssl добавлена поддержка OpenSSL 1.1.0. Улучшен набор настроек по умолчанию для модуля ssl; В модуль hashlib добавлена поддержка алгоритмов хэширования BLAKE2, SHA-3 и SHAKE, реализована функция формирования ключа scrypt(); Представлена большая порция улучшений, связанных с работой на платформе Windows.