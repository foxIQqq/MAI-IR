Выпуск языка программирования Rust 1.38

Опубликован релиз языка системного программирования Rust 1.38, основанного проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime. Автоматическое управление памятью в Rust избавляет разработчика от манипулирования указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo, позволяющий получить нужные для программы библиотеки в один клик. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Добавлен режим конвейерной компиляции (pipelined), при которой сборка зависимого crate-пакета начинается сразу как только становятся доступны метаданные зависимости, не дожидаясь завершения её компиляции. При компиляции пакета не нужно, чтобы зависимости были собраны полностью, достаточно лишь определения метаданных, включающих списки типов, зависимостей и экспортируемых элементов. Метаданные становятся доступны на начальном этапе компиляции, поэтому связанные пакеты теперь можно начать компилировать гораздо раньше. При сборке одиночных пакетов предложенный режим не сказывается на производительности, но если сборка охватывает пакеты с разветвлёнными зависимостями, общее время сборки может сократиться на 10-20%; Обеспечено выявление некорректного применения функций std::mem::uninitialized и std::mem::zeroed. Например, std::mem::uninitialized удобен для быстрого создания массивов, но вводит компилятор в заблуждение, так как создают видимость выполнения инициализации, а в действительности значение остаётся неинициализированным. Функция mem::uninitialized уже помечена как устаревшая и вместо неё рекомендуется использовать промежуточный тип MaybeUninit. Что касается mem::zeroed, то данная функция может приводить к проблемам с типам, которые не могут принимать нулевые значения. Для выявления вызываемого неопределённого поведения в новом выпуске в компилятор добавлена lint-проверка, выявляющая некоторые проблемы c mem::uninitialized или mem::zeroed. Например, теперь выводится ошибка при попытке использования mem::uninitialized или mem::zeroed с типами &T и Box<T>, представляющими объекты-указатели, которые не могут принимать нулевые значения; Расширены возможности применения атрибута "#[deprecated]", позволяющего пометить crate-пакеты устаревшими и намеченными для удаления в будущем. Начиная с версии Rust 1.38 данный атрибут также можно применять для макросов; Добавлена возможность применения атрибута "#[global_allocator]" в субмодулях; Добавлена функция std::any::type_name, позволяющая узнать имя типа, что может быть полезно в отладочных целях. Например, в процессе выполнения программы можно узнать для какого типа была вызвана функция: fn gen_value<T: Default>() -> T { println!("Initializing an instance of {}", std::any::type_name::<T>()); Default::default() } fn main() { let _: i32 = gen_value(); # будет выведено "i32" let _: String = gen_value(); # будет выведено "alloc::string::String" } Расширены функции стандартной библиотеки: slice::{concat, connect, join} теперь может принимать значение &[T] помимо &T "*const T" и "*mut T" теперь реализуют marker::Unpin; "Arc<[T]>" и "Rc<[T]>" теперь реализуют FromIterator<T>; iter::{StepBy, Peekable, Take} теперь реализуют DoubleEndedIterator. ascii::EscapeDefault реализует Clone и Display. В разряд стабильных переведена новая порция API, в том числе стабилизированы методы <*const T>::cast, <*mut T>::cast, Duration::as_secs_f{32|64}, Duration::div_duration_f{32|64}, Duration::div_f{32|64}, Duration::from_secs_f{32|64}, Duration::mul_f{32|64}, операции деления с остатком div_euclid и rem_euclid для всех целочисленных примитивов; В пакетный менеджер cargo добавлена поддержка указания опции "--features" несколько раз для включения разных возможностей; В компиляторе обеспечен третий уровень поддержки для целевых платформ aarch64-uwp-windows-msvc, i686-uwp-windows-gnu, i686-uwp-windows-msvc, x86_64-uwp-windows-gnu, x86_64-uwp-windows-msvc targets, armv7-unknown-linux-gnueabi, armv7-unknown-linux-musleabi, hexagon-unknown-linux-musl и riscv32i-unknown-none-elf. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования и публикации официальных сборок.