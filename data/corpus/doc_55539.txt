Ошибка в обновлении Chrome OS привела к невозможности входа в систему

Компания Google выпустила обновление Chrome OS 91.0.4472.165, в котором была допущена ошибка, приведшая к невозможности входа в систему после перезагрузки. Некоторые пользователи столкнулись с зацикливанием во время загрузки, в результате которого экран входа в систему не появлялся, а если появлялся, то не позволял подключиться под своей учётной записью. По горячим следам выпущено исправление Chrome OS 91.0.4472.167 с устранением проблемы. Пользователям, которые уже установили первое обновление, но ещё не перезагрузили устройство (обновление активируется после перезагрузки), рекомендуется срочно довести свою систему до версии 91.0.4472.167. В случае если проблемное обновление установлено и вход блокирован, рекомендуется оставить устройство на некоторое время включённым и дождаться пока автоматически загрузится новое обновление. В качестве запасного варианта можно попытаться принудительно инициировать обновление через гостевой вход. Пользователям, система которых зависает не доходя до экрана входа и автоматическая установка нового обновления не срабатывает, рекомендовано нажать комбинацию Ctrl + Alt + Shift + R два раза и воспользоваться режимом сброса к заводским настройкам (Powerwash) или функцией отката системы до прошлой версии через USB (Revert), но в обоих режимах локальные данные пользователя удаляются. Если вызвать режим Powerwash не удаётся потребуется перевод устройства в режим разработчика с выполнением сброса в исходное состояние. Один из пользователей проанализировал исправление и пришёл к выводу, что причина блокировки входа в опечатке, из-за которой в условном операторе, применяемом для проверки типа ключей, был пропущен один символ "&". Вместо if (key_data.has_value() && !key_data->label().empty()) { было указано if (key_data.has_value() & !key_data->label().empty()) { Оператор "&" отличается от "&&" тем, что "&&" позволяет пропускать вычисление второго аргумента, если в первом получен ложный результат. В случае оператора "&", компилятор должен вычислить обязательно и первый аргумент, и второй аргумент, но если первый "key_data.has_value()" вернёт "false", то вызов оператора "->" во втором аргументе приведёт к неопределённому поведению, потому что "label" не инициализирован (key_data имеет тип Optional<T>, схожий с optional<T> из стандарта на C++, и с Maybe/Option в Haskell/Rust). Такого бы не случилось, если бы использовался оператор "&&", потому что он вычисляет аргументы слева направо и прерывает вычисления, если первый оказался "false".