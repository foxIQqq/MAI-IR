W3C представил черновой вариант стандарта WebGPU

Консорциум W3C представил первые черновые варианты спецификаций WebGPU и WebGPU Shading Language (WGSL), определяющих API для выполнения операций на GPU, таких как рендеринг и вычисления, а также язык шейдров для написания программ, работающих на стороне GPU. концептуально схожий с API Vulkan, Metal и Direct3D 12. Спецификации подготовлены рабочей группой, в которую вошли инженеры из Mozilla, Google, Apple и Microsoft. Концептуально WebGPU отличается от WebGL примерно так же, как графический API Vulkan отличается от OpenGL, но при этом не основывается на конкретном графическом API, а представляет собой универсальную прослойку, использующую те же низкоуровневые примитивы, что имеются в Vulkan, Metal и Direct3D. WebGPU предоставляет приложениям на JavaScript средства для низкоуровневого контроля за организацией, обработкой и передачей команд к GPU, управления связанными ресурсами, памятью, буферами, объектами текстур и скомпилированными графическими шейдерами. Подобный подход позволяет добиться более высокой производительности графических приложений за счёт снижения накладных расходов и повышения эффективности работы с GPU. WebGPU даёт возможность создавать для Web сложные 3D-проекты, работающие не хуже, чем обособленные программы, напрямую обращающиеся с Vulkan, Metal или Direct3D, но не привязанные к конкретным платформам. WebGPU также предоставляет дополнительные возможности при портировании нативных графических программ в форму, способную работать на базе web-технологий, благодаря компиляции в WebAssembly. Кроме 3D-графики WebGPU охватывает и возможности, связанные с выносом вычислений на сторону GPU и выполнением шейдеров. Ключевые особенности WebGPU: Раздельное управление ресурсами, подготовительными работами и передачей команд в GPU (в WebGL один объект отвечал за всё разом). Предоставляется три отдельных контекста: GPUDevice для создания ресурсов, таких как текстуры и буферы; GPUCommandEncoder для кодирования отдельных команд, включая стадии рендеринга и вычисления; GPUCommandBuffer для передачи в очередь на выполнение в GPU. Результат может быть отрисован в области, связанной с одним или несколькими элементами canvas, или обработан без вывода (например, при запуске вычислительных задач). Разделение стадий упрощает разнесение создания ресурсов и подготовительные операции в разные обработчики, которые могут выполняться в разных потоках. Иной подход при обработке состояний. В WebGPU предлагается два объекта - GPURenderPipeline и GPUComputePipeline, позволяющих комбинировать различные состояния, заранее определённые разработчиком, что даёт возможность браузеру не тратить ресурсы на проведение дополнительной работы, такой как перекомпиляция шейдеров. Среди поддерживаемых состояний: шейдеры, раскладки вершинных буферов и атрибутов, раскладки прикреплённых групп, смешивание, глубина и шаблоны, форматы вывода после рендеринга. Модель связывания, во многом напоминающая присутствующие в Vulkan средства группировки ресурсов. Для объединения ресурсов в группы в WebGPU предоставляется объект GPUBindGroup, который во время записи команд можно связать с другими такими же объектами для использования в шейдерах. Создание подобных групп даёт возможность драйверу заранее выполнить необходимые подготовительные действия, а браузеру позволяет значительно быстрее менять привязки ресурсов между вызовами отрисовки. Раскладка привязок ресурсов может быть определена заранее при помощи объекта GPUBindGroupLayout.