Выпуск языка программирования Rust 1.40

Опубликован релиз языка системного программирования Rust 1.40, основанного проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime. Автоматическое управление памятью в Rust избавляет разработчика от манипулирования указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo, позволяющий получить нужные для программы библиотеки в один клик. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Добавлена возможность пометки структур (struct) и перечислений (enum c блоком Variant) при помощи атрибута "#[non_exhaustive]", который позволяет в дальнейшем добавлять новые поля и варианты в объявленные структуры и перечисления. Например, разработчики модулей, имеющих структуры с публично объявленными полями, могут использовать "#[non_exhaustive]" для пометки структур, в которых в будущем возможно добавление новых полей. До сих пор в подобной ситуации разработчик вынужден был выбирать между приватным объявлением полей и привязкой к неизменному списку полей. Новый атрибут снимает данное ограничение и позволяет в будущем добавлять новые поля без риска нарушения работы ранее собранного внешнего кода. В crate-пакетах при сопоставлениях вариантов в секции "match" требуется явное определение маски "_ => {...}", охватывающей возможные будущие поля, иначе при добавлении новых полей будет выводиться ошибка. Добавлена возможность вызова процедурного макроса mac!() в контексте типа. Например, теперь можно писать "type Foo = expand_to_type!(bar);", если "expand_to_type" процедурный макрос. В блоках "extern { ... }" добавлена возможность использования процедурных и атрибутных макросов, в том числе макросов "bang!()", например: macro_rules! make_item { ($name:ident) => { fn $name(); } } extern { make_item!(alpha); make_item!(beta); } extern "C" { #[my_identity_macro] fn foo(); } В макросах реализована возможность генерации элементов "macro_rules!". Генерация "macro_rules!" возможна как в напоминающих функции макросах ("mac!()"), так и в макросах в форме атрибутов ("#[mac]"). В элементе сопоставления $m:meta добавлена поддержка произвольных значений перечислений токенов ("[TOKEN_STREAM]", "{TOKEN_STREAM}" и "(TOKEN_STREAM)), например: macro_rules! accept_meta { ($m:meta) => {} } accept_meta!( my::path ); accept_meta!( my::path = "lit" ); accept_meta!( my::path ( a b c ) ); accept_meta!( my::path [ a b c ] ); accept_meta!( my::path { a b c } ); В режиме Rust 2015 активирован вывод ошибки для проблем, выявленных при проверке заимствования переменных (borrow checker) c использованием техники NLL (Non-Lexical Lifetimes). Ранее предупреждения были заменены на ошибки при работе в режиме Rust 2018. После распространения изменения и на режим Rust 2015 разработчики получили возможность окончательно избавиться от старого borrow checker. Напомним, что система проверки на основе нового механизма учёта времени жизни заимствованных переменных дала возможность выявлять некоторые проблемы, которые оставались незамеченными старым кодом проверки. Так как вывод ошибки для подобных проверок мог повлиять на совместимость с ранее работающим кодом, вместо ошибок первое время выдавались предупреждения. Признак "const", определяющий возможность использования в любом контексте вместо констант, применён для функции is_power_of_two (для беззнаковых целых чисел). В разряд стабильных переведена новая порция API, в том числе стабилизированы макрос todo!() и методы slice::repeat, mem::take, BTreeMap::get_key_value, HashMap::get_key_value, Option::as_deref, Option::as_deref_mut, Option::flatten, UdpSocket::peer_addr, {f32,f64}::to_be_bytes, {f32,f64}::to_le_bytes,{f32,f64}::to_ne_bytes, {f32,f64}::from_be_bytes, {f32,f64}::from_le_bytes, and {f32,f64}::from_ne_bytes. В пакетном менеджере cargo реализовано кэширование на диске предупреждений компилятора. В команду "cargo metadata" добавлена опция "--filter-platform" для показа в графе разрешения зависимостей только пакетов, привязанных к указанной целевой платформе. Добавлен параметр конфигурации http.ssl-version для определения допустимых версий TLS. Добавлена возможность публикации секции "dev-dependencies" без указания ключа "version". В компиляторе rustc обеспечен третий уровень поддержки целевых платформ thumbv7neon-unknown-linux-musleabihf, aarch64-unknown-none-softfloat, mips64-unknown-linux-muslabi64 и mips64el-unknown-linux-muslabi64. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования и публикации официальных сборок.