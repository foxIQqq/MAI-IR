Выпуск пакетного фильтра nftables 1.0.0

Опубликован выпуск пакетного фильтра nftables 1.0.0, унифицирующего интерфейсы фильтрации пакетов для IPv4, IPv6, ARP и сетевых мостов (нацелен на замену iptables, ip6table, arptables и ebtables). Необходимые для работы выпуска nftables 1.0.0 изменения включены в состав ядра Linux 5.13. Значительное изменение номера версии не связано с какими-то кардинальными изменениями, а лишь является следствием последовательного продолжения нумерации в десятичном исчислении (прошлый выпуск был 0.9.9). В пакет nftables входят компоненты пакетного фильтра, работающие в пространстве пользователя, в то время как на уровне ядра работу обеспечивает подсистема nf_tables, входящая в состав ядра Linux начиная с выпуска 3.13. На уровне ядра предоставляется лишь общий интерфейс, не зависящий от конкретного протокола и предоставляющий базовые функции извлечения данных из пакетов, выполнения операций с данными и управления потоком. Непосредственно правила фильтрации и специфичные для протоколов обработчики компилируются в байткод в пространстве пользователя, после чего данный байткод загружается в ядро при помощи интерфейса Netlink и выполняется в ядре в специальной виртуальной машине, напоминающей BPF (Berkeley Packet Filters). Подобный подход позволяет значительно сократить размер кода фильтрации, работающего на уровне ядра и вынести все функции разбора правил и логики работы с протоколами в пространство пользователя. Основные новшества: В set-списки добавлена поддержка элемента-маски "*", срабатывающего для любых пакетов, не подпадающих под другие элементы, определённые в наборе. table x { map blocklist { type ipv4_addr : verdict flags interval elements = { 192.168.0.0/16 : accept, 10.0.0.0/8 : accept, * : drop } } chain y { type filter hook prerouting priority 0; policy accept; ip saddr vmap @blocklist } } Предоставлена возможность определения переменных из командной строки при помощи опции "--define". # cat test.nft table netdev x { chain y { type filter hook ingress devices = $dev priority 0; policy drop; } } # nft --define dev="{ eth0, eth1 }" -f test.nft В map-списках разрешено применение постоянных (stateful) выражений: table inet filter { map portmap { type inet_service : verdict counter elements = { 22 counter packets 0 bytes 0 : jump ssh_input, * counter packets 0 bytes 0 : drop } } chain ssh_input { } chain wan_input { tcp dport vmap @portmap } chain prerouting { type filter hook prerouting priority raw; policy accept; iif vmap { "lo" : jump wan_input } } } Добавлена команда "list hooks" для вывода списка обработчиков заданного семейства пакетов: # nft list hooks ip device eth0 family ip { hook ingress { +0000000010 chain netdev x y [nf_tables] +0000000300 chain inet m w [nf_tables] } hook input { -0000000100 chain ip a b [nf_tables] +0000000300 chain inet m z [nf_tables] } hook forward { -0000000225 selinux_ipv4_forward 0000000000 chain ip a c [nf_tables] } hook output { -0000000225 selinux_ipv4_output } hook postrouting { +0000000225 selinux_ipv4_postroute } } В блоках "queue" разрешено комбинировать выражения jhash, symhash и numgen для распределения пакетов по очередям в пространстве пользователя. ... queue to symhash mod 65536 ... queue flags bypass to numgen inc mod 65536 ... queue to jhash oif . meta mark mod 32 "queue" также можно сочетать с map-списками для выбора очереди в пространстве пользователя на основе произвольных ключей. ... queue flags bypass to oifname map { "eth0" : 0, "ppp0" : 2, "eth1" : 2 } Предоставлена возможность раскрытия переменных, включающих set-список, в несколько map-ов. define interfaces = { eth0, eth1 } table ip x { chain y { type filter hook input priority 0; policy accept; iifname vmap { lo : accept, $interfaces : drop } } } # nft -f x.nft # nft list ruleset table ip x { chain y { type filter hook input priority 0; policy accept; iifname vmap { "lo" : accept, "eth0" : drop, "eth1" : drop } } } Разрешено комбинирование vmap-ов (verdict map) c интервалами: # nft add rule x y tcp dport . ip saddr vmap { 1025-65535 . 192.168.10.2 : accept } Упрощён синтаксис сопоставлений для NAT. Разрешено указание диапазонов адресов: ... snat to ip saddr map { 10.141.11.4 : 192.168.2.2-192.168.2.4 } или явных IP-адресов и портов: ... dnat to ip saddr map { 10.141.11.4 : 192.168.2.3 . 80 } или комбинации диапазонов IP и портов: ... dnat to ip saddr . tcp dport map { 192.168.1.2 . 80 : 10.141.10.2-10.141.10.5 . 8888-8999 }