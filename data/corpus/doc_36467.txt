Выпущен набор компиляторов GCC 4.8

После года разработки увидел свет релиз свободного набора компиляторов GCC 4.8. Новый выпуск примечателен переходом проекта на использование языка C++, улучшением поддержки стандартов C++11 и C11, интеграцией компонентов Address Sanitizer и Thread Sanitizer, поддержкой архитектуры AArch64 (ARM64). Основные изменения: Кодовая база компилятора переведена на использование языка C++. Основной код по прежнему остаётся на языке Си, но для сборки обязательно требуется компилятор С++, так как некоторые части были переписаны на C++ и теперь допускается включение в GCC новых компонентов на языке C++; Поддержка 64-разрядной архитектуры AArch64(ARM64), присутствующей в процессорах с набором команд ARMv8. Архитектура AArch64 включает в себя новый набор команд A64, примечательный расширением числа регистров, новыми командами для вычислений с плавающей запятой (FP) и новыми векторными SIMD-инструкциями NEON, такими как инструкции для ускорения работы алгоритмов шифрования AES и SHA-1/SHA-256. В настоящее время устройства на базе ARMv8 пока находятся на стадии тестирования прототипов и ещё не поступили в продажу. Из поддерживаемых процессоров отмечены Cortex-A53 (-mcpu=cortex-a53 ) и Cortex-A57 (-mcpu=cortex-a57); Улучшение поддержки 32-разрядной архитектуры ARM, в том числе улучшение поддержки процессоров Marvell PJ4, Cortex-A7 и Cortex-A15; автоматическая генерация инструкций VFMA, VFMS, REVSH и REV16; улучшенная модель векторизации; поддержка расширений AArch32, представленных в наборе команд ARMv8; Поддержка процессоров семейства Intel Broadwell (-madx, -mprfchw, -mrdseed), AMD Jaguar (-march=btver2 и -mtune=btver2) и AMD Steamroller (-march=bdver3 и -mtune=bdver3). Поддержка инструкций RDSEED, ADCX, ADOX, PREFETCHW, FXSR, XSAVE и XSAVEOPT Интеграция компонента Address Sanitizer, созданного компанией Google и прекрасно зарекомендовавшего себя при выявлении уязвимостей в браузере Chrome. Address Sanitizer позволяет выявлять ошибки в работе с памятью и факты некорректного обращения к памяти, такие как обращение к областям памяти, после их освобождения ("use-after-free"), разрушение кучи, повреждение стека, переполнение буферов. Проверки Address Sanitizer включаются через опцию "-fsanitize=address" и могут замедлить работу программы примерно в два раза за счёт добавления дополнительных проверок. Address Sanitizer может быть использован на платформах GNU/Linux (IA-32, x86-64, x32, PowerPC, PowerPC64) и Darwin (x86-64); Добавлен режим Thread Sanitizer (-fsanitize=thread), предназначенный для обнаружения эффекта "гонки" при совместном доступе к одним и тем же данным из различных нитей многопоточного приложения. Thread Sanitizer базируется на коде из программы Valgrind. Использование Thread Sanitizer может до 10 раз замедлить работу программы. Режим доступен только для платформы x86-64 GNU/Linux; Новый уровень оптимизации "-Og", позволяющий повысить удобство отладки за счёт существенного сокращения времени компиляции. В режиме "-Og" компилятор производит только минимальные оптимизации, не влияющие на результаты при отладке; По умолчанию задействован более агрессивный метод оптимизации циклов. На случай возникновения проблем в приложениях, предусмотрена опция "-fno-aggressive-loop-optimizations"; Добавлена новая опция оптимизации "-ftree-partial-pre", позволяющая управлять оптимизацией по частичному устранению избыточных выражений (http://en.wikipedia.org/wiki/Partial_redundancy_elimination PRE, Partial Redundancy Elimination). Опция по умолчанию включается при выборе флага "-O3" и приводит к задействованию более агрессивного метда оптимизации PRE; Улучшена работа оптимизаций во время динамического связывания (LTO, Link Time Optimization) и межпроцедурных оптимизаций; Улучшения в поддержке стандарта C++11, а также реализация ряда возможностей будущего стандарта C++1y. Из элементов C++11 добавлена поддержка ключевого слова thread_local, наследуемых конструкторов, выражений подобных "[[noreturn]] void f()" и "alignas(double) int i"; Для программ на языке Си добавлено новое предупреждение "-Wsizeof-pointer-memaccess" (включается при -Wall), уведомляющее о подозрительной длине параметров, передаваемых в некоторые встроенные строковые функции и функции работы с памятью (работает только если аргумент использует sizeof). Например, предупреждение будет выведено при вызове memset (ptr, 0, sizeof (ptr)) и memcpy (&foo, ptr, sizeof (&foo)), если ptr не является массивом, но используется как указатель; При генерации отладочной информации по умолчанию теперь используется формат DWARF4 (в прошлых выпусках использовался DWARF2). DWARF4 уже поддерживается в GDB 7.5, Valgrind 3.8.0 и elfutils 0.154; Дополнительно можно отметить интересное исследование производительности работы кода, собранного компиляторами Си и Cи++ из состава GCC 4.7.2. В итоге опровергнуто мнение, что код на языке Си собранный компилятором сс медленнее, чем если данный код будет собран компилятором g++. Подмножество языка Си, доступное при сборке компилятором С++, по эффективности не уступает чистому компилятору Си, разница составляет всего 0.1%. Таким образом переход GCC на сборку компилятором С++ не скажется на производительности.