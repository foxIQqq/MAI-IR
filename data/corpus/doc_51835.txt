Выпуск языка программирования Rust 1.39

Опубликован релиз языка системного программирования Rust 1.39, основанного проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime. Автоматическое управление памятью в Rust избавляет разработчика от манипулирования указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo, позволяющий получить нужные для программы библиотеки в один клик. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Стабилизирован новый синтаксис асинхронного программирования, основанный на функции "async", блоке async move { ... } и операторе ".await", которые упрощают написание обработчиков, не блокирующих основной поток команд. По сравнению с ранее предлагавшимся API для асинхронного ввода/вывода конструкции async/.await просты для восприятия, хорошо читаемы и позволяют реализовывать сложные асинхронные взаимодействия с использованием привычных приёмов управления потоком выполнения на основе циклов, условных операторов и исключений. Синтаксис Async-await позволяет создавать функции, которые могут приостанавливать своё выполнение, возвращать управление в основной поток, а затем возобновлять выполнение с того места, где они были остановлены. Например, подобная приостановка востребована при обработке ввода/вывода, в котором во время ожидания поступления очередной порции данных можно выполнять другую работу. Функции и блоки, определённые через "async fn" и "async move", возвращают типаж Future, определяющий представление отложенного на будущее асинхронного вычисления. Непосредственно инициировать отложенное вычисление и получить результат можно при помощи оператора ".await". До вызова ".await" никаких действий не производится и не планируется заранее, что позволяет создавать сложные вложенные конструкции без дополнительных накладных расходов. async fn first_function() -> u32 { .. } ... let future = first_function(); ... let result: u32 = future.await; Стабилизирован "#![feature(bind_by_move_pattern_guards)]", позволяющий использовать переменные с типом привязки "by-move" в шаблонах и использовать ссылки на эти переменные в секции "if" выражения "match". Например, теперь допустимы следующие конструкции: fn main() { let array: Box<[u8; 4]> = Box::new([1, 2, 3, 4]); match array { nums if nums.iter().sum::() == 10 => { drop(nums); } _ => unreachable!(), } } Разрешено указание атрибутов при определении параметров функций, замыканий и указателей на функции. Поддерживаются атрибуты условной компиляции (cfg, cfg_attr), управляющие диагностикой через lint (allow, warn, deny и forbid) и вспомогательные атрибуты вызова макросов. fn len( #[cfg(windows)] slice: &[u16], // использовать параметр в Windows #[cfg(not(windows))] slice: &[u8], // использовать в остальных ОС ) -> usize { slice.len() } Предупреждения о проблемах, выявленных при проверке заимствования переменных (borrow checker) c использованием техники NLL (Non-Lexical Lifetimes), переведены в разряд фатальных ошибок. Напомним, что система проверки на основе нового механизма учёта времени жизни заимствованных переменных дала возможность выявлять некоторые проблемы, которые оставались незамеченными старым кодом проверки. Так как вывод ошибки для подобных проверок мог повлиять на совместимость с ранее работающим кодом, вместо ошибок первое время выдавались предупреждения. Теперь при работе в режиме Rust 2018 предупреждения заменены на ошибки. В следующем выпуске вывод ошибки также будет реализован в режиме Rust 2015, что позволит окончательно избавиться от старого borrow checker; Признак "const", определяющий возможность использования в любом контексте вместо констант, применён для функций Vec::new, String::new, LinkedList::new, str::len, [T]::len, str::as_bytes, abs, wrapping_abs и overflowing_abs; В разряд стабильных переведена новая порция API, в том числе стабилизированы методы Pin::into_inner, Instant::checked_duration_since и Instant::saturating_duration_since; В пакетный менеджер cargo добавлена возможность использования для файлов конфигурации расширения ".toml". Добавлена предварительная поддержка сборки стандартной библиотеки непосредственно из Cargo. Добавлен флаг "--workspace", заменивший неоднозначно воспринимаемый флаг "--all". В метаданные добавлено новое поле "publish", позволяющее публиковать зависимости, указывая тег в git и номер версии. Добавлена тестовая опция "-Ztimings" для генерации HTML-отчета о времени выполнения различных стадий компиляции. В компиляторе rustc в диагностических сообщениях включено обрезание хвостов кода, не умещающегося в терминал. Обеспечен третий уровень поддержки целевых платформ i686-unknown-uefi и sparc64-unknown-openbsd. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования и публикации официальных сборок.