Шестая версия патчей для ядра Linux с поддержкой языка Rust

Мигель Охеда (Miguel Ojeda), автор проекта Rust-for-Linux, предложил для рассмотрения разработчиками ядра Linux выпуск v6 компонентов для разработки драйверов устройств на языке Rust. Это седьмая редакция патчей с учётом первого варианта, опубликованного без номера версии. Поддержка Rust рассматривается как экспериментальная, но уже включена в ветку linux-next и достаточно развита для начала работы по созданию слоёв абстракции над подсистемами ядра, а также для написания драйверов и модулей. Разработка финансируется компанией Google и организацией ISRG (Internet Security Research Group), которая является учредителем проекта Let's Encrypt и способствует продвижению HTTPS и развитию технологий для повышения защищённости интернета. В новой версии: Инструментарий и вариант библиотеки alloc, избавленный от возможных генераций состояния "panic" при возникновении ошибок, обновлены до выпуска Rust 1.60, в которой стабилизирована поддержка режима "maybe_uninit_extra", применяемого в патчах к ядру. Добавлена возможность выполнения тестов из документации (тесты, одновременно используемые в качестве примеров в документации), через преобразование во время компиляции тестов, завязанных на API ядра, в тесты KUnit, выполняемые во время загрузки ядра. Приняты требования, в соответствии с которыми тесты не должны приводить к выводу предупреждения линтера Clippy, как и код для ядра на языке Rust. Предложена начальная реализация модуля "net" с сетевыми функциями. Для кода на языке Rust предоставлен доступ к таким сетевым структурам ядра, как "Namespace" (на основе структуры ядра "struct net"), SkBuff (struct sk_buff), TcpListener, TcpStream (struct socket), Ipv4Addr (struct in_addr), SocketAddrV4 (struct sockaddr_in) и их эквивалентам для IPv6. Реализована начальная поддержка методов асинхронного программирования (async), реализованная в форме модуля kasync. Например, можно создавать работающий в асинхронном режиме код для манипуляции с TCP-сокетами: async fn echo_server(stream: TcpStream) -> Result { let mut buf = [0u8; 1024]; loop { let n = stream.read(&mut buf).await?; if n == 0 { return Ok(()); } stream.write_all(&buf[..n]).await?; } } Добавлен модуль net::filter для манипуляции с фильтрами сетевых пакетов. Добавлен пример rust_netfilter.rs с реализацией фильтра на языке Rust. Добавлена реализация простого мьютекса smutex::Mutex, не требующего привязки (pinning). Добавлена блокировка NoWaitLock, которая никогда не приводит к ожиданию освобождения, а в случае занятия другим потоком приводит к выводу ошибки при попытке получения блокировки вместо остановки вызывающего. Добавлена блокировка RawSpinLock отождествлённая с raw_spinlock_t в ядре, применяемая к секциям, которые не могут находиться в состоянии ожидания. Добавлен тип ARef для ссылок на объект, к которому применяется механизм подсчёта ссылок (always-refcounted). В бэкенде rustc_codegen_gcc, позволяющем использовать библиотеку libgccjit от проекта GCC в качестве генератора кода в rustc для обеспечения в rustc поддержки доступных в GCC архитектур и оптимизаций, реализована возможность раскрутки компилятора (bootstrapping) rustc. Под раскруткой компилятора понимается возможность использования в rustc генератора кода на основе GCC для сборки самого компилятора rustc. Кроме того, в недавний выпуск GCC 12.1 включены исправления в libgccjit, необходимые для корректной работы rustc_codegen_gcc. Ведётся подготовка к предоставлению возможности установки rustc_codegen_gcc при помощи утилиты rustup. Отмечается прогресс разработки GCC-фронтэнда gccrs с реализацией компилятора языка Rust на базе GCC. В настоящее время над gccrs в режиме полного рабочего дня работают два разработчика. Напомним, что предложенные изменения дают возможность использовать Rust в качестве второго языка для разработки драйверов и модулей ядра. Поддержка Rust преподносится как опция, не активная по умолчанию и не приводящая к включению Rust в число обязательных сборочных зависимостей к ядру. Использование Rust для разработки драйверов позволит с минимальными усилиями создавать безопасные и более качественные драйверы, избавленные от таких проблем как обращение к области памяти после её освобождения, разыменование нулевых указателей и выход за границы буфера. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами и учёт времени жизни объектов (области видимости), а также через оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок.