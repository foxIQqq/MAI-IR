Вышел язык спецификации бинарных форматов Kaitai Struct 0.5

Проект Kaitai представил новый релиз Kaitai Struct версии 0.5, декларативного языка описания бинарных форматов и структур данных. Как и прежде, основная идея проекта заключается в том, что практически любой формат файла или структуру сетевого протокола можно описать на Kaitai Struct, составив исходный файл .ksy, который затем компилируется (с помощью прилагаемого компилятора ksc) в готовый парсер на любом из поддерживаемых языков программирования. Основная сфера применения подобного решения - разбор всевозможных существующих (зачастую закрытых и проприетарных) форматов (офисных, мультимедийных и т.д.) и протоколов. Благодаря наличию продвинутых инструментов отладки и визуализации, Kaitai Struct нашел свое применение и в быстром реверс-инжиниринге неизвестных форматов, а также в digital forensics. Ряд организаций, занимающийся хранением исторических цифровых архивов, взяли Kaitai Struct на вооружение как стандарт описания форматов данных. Компилятор Kaitai Struct распространяется под лицензией GPLv3, большая часть runtime - под MIT. Для желающих попробовать компилятор без установки подготовлен JavaScript-вариант компилятора KS с примерами. Наиболее заметные изменения: Поддержка новых целевых языков Полная поддержка целевого языка C++ (на базе STL), а также новые целевые языки PHP и Perl: Вывод описаний форматов в виде наглядных человеко-читаемых схем (через GraphViz). Подборка примеров визуализаций доступна в галерее; Многочисленные доработки и проверки для полноценной поддержки как Python 2, так и Python 3. Как и раньше, кроме новых языков, все еще поддерживаются C#, Java, JavaScript, Python, Ruby. Новые инструменты для разработки, отладки и визуализации Консольный визуализатор ksv обновлен и теперь работает не только на UNIX-консолях (Linux, *BSD, OS X), но и под Windows: Появился экспериментальный GUI-визуализатор на Java/Swing: Начата разработка интегрированной среды на основе web-технологий, работающей в браузере и совмещающей в себе редактор для создания .ksy-файлов, компилятор, визуализатор дерева объектов, hex viewer и менеджер библиотеки ksy-форматов. Среда реализована на HTML/JavaScript, но благодаря технологии ScalaJS, внутри у нее использоваться абсолютно такой же компилятор, как и в большой, "десктопной" версии Kaitai Struct. Доступна онлайн демо-версия. Новые возможности языка .ksy Switch-подобный механизм определения типов данных на основе условия позволяет отказаться от кучи однотипных if'ов: Цикл repeat-until позволяет объявить массив элементов, повторяющихся до достижения определенного условия. Для ссылки на текущий элемент следует использовать специальную переменную `_`. Например, следующее объявление задает массив целых знаковых 4-байтовых чисел, заканчивающийся -1: - id: elements type: s4 repeat: until repeat-until: _ == -1 Более сложный пример — массив сегментов (тип segment - пользовательский, объявлен отдельно), заканчивающийся чтением сегмента с кодом "segment_code::end": - id: segments type: segment repeat: until repeat-until: _.code == segment_code::end Каждое поле теперь может аннотироваться строчкой человеко-читаемой документации. Кроме видимости в .ksy-файле, эта документация будет выгружаться в doc-систему целевого языка (JavaDoc, JSDoc, YARD/RDoc и т.п.): В язык выражений добавлены операции над потоком (`_io`). С их помощью можно, например, адресовать структуры относительно конца потока (а не только относительно начала): instances: from_start: # 0x10 байт, начиная с 0x40 байта от начала pos: 0x40 size: 0x10 from_end: # 0x10 байт, начиная с 0x40 байта с конца pos: _io.size - 0x40 size: 0x10 Или, например, удобно делать условные структуры, которые будут парситься, только если что-то еще осталось в потоке: seq: # основной элемент, присутствует всегда - id: main_element type: ... # дополнительный элемент, будет зачитан, только в потоке еще что-то есть - id: aux_element type: ... if: not _io.eof Важные мелочи Существенно улучшена диагностика ошибок, усилена строгость проверки исходных .ksy. При обнаружении ошибки компилятор теперь генерирует понятные ссылки на конкретные элементы, в которых проблема и предлагает варианты решения. При обнаружении ошибки с данными в runtime в debug-режиме теперь производится попытка оставить как можно больше данных в структуре (включая не полностью заполненные классы), чтобы легче было понять, где именно произошел сбой парсинга. Стандартизация сборки: в дополнение к ранее собираемым runtime-модулям для Ruby в виде gem, появились доступные для инсталляции из соответствующих репозиториев пакеты для Python в PyPI и для Java-платформы. Авторы призывают помочь с упаковкой runtime-библиотек и для других языков.