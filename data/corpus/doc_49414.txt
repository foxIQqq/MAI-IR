Для Linux представлена система динамической отладки BPFtrace (DTrace 2.0)

Брендан Грег (Brendan Gregg), один из разработчиков DTrace, объявил об открытии доступа к репозиторию проекта BPFtrace, в рамках которого развивается высокоуровневый язык для написания скриптов динамической отладки и анализа производительности приложений и ядра, продолжающий развитие системы DTrace (позиционируется как DTrace 2.0). Наработки проекта распространяются под лицензией Apache 2.0. BPFtrace реализован в виде фронтэнда, транслирующего отладочные сценарии в форму приложений eBPF, имеющих доступ к низкоуровневым примитивам ядра для анализа производительности. Для компиляции скриптов BPFtrace в байткод BPF применяется бэкенд на базе LLVM. Язык BPFtrace напоминает AWK и Си, и предоставляет возможности для упрощения трассировки, похожие на DTrace и SystemTap. eBPF представляет собой встроенный в ядро Linux интерпретатор байткода, позволяющий создавать обработчики сетевых операций, отслеживать работу систем, перехватывать системные вызовы, контролировать доступ, обрабатывать события с сохранением хронометража (perf_event_open), подсчитывать частоту и время выполнения операций, выполнять трассировку с использованием kprobes/uprobes/tracepoints. Благодаря применению JIT-компиляции, байткод на лету транслируется в машинные инструкции и выполняется с производительностью нативного кода. BPFtrace пока ограничен поддержкой платформы Linux, но ведётся разработка реализации eBPF для FreeBSD, после завершения которой BPFtrace сможет быть портирован на FreeBSD. BPFtrace позволяет отслеживать поведение системы и выполнять диагностику проблем в режиме реального времени, не влияя в процессе отладки на работу и производительность исследуемых приложений. В сценариях BPFtrace может учитываться разнообразная статистика о подсистемах ядра, процессах, системных вызовах, обрабатываемых файлах, блочном вводе/выводе, сетевой активности, состоянии кэшей, работе планировщика задач, утилизации CPU (например, можно определить какое ядро CPU в данным момент выполняет код) и многих других параметрах. Возможна привязка скриптов-обработчиков к функциям ядра (kprobe:vfs_read), функциям в пространстве пользователя (uprobe:/bin/bash:readline), точкам трассировки в ядре (tracepoint:sched:sched_switch), программным и аппаратным событиям (software:faults: и hardware:cache-references:). Возможен периодический запуск скриптов для сбора статистики (profile:ms: и interval:ms:). Поддерживается привязка скрипта сразу к нескольким событиям, привязка по маске (kprobe:vfs_*) и определение условий для вызова (kprobe:sys_open / uid == 0 /). Для использования в скриптах предлагается типовой набор функций и библиотека готовых обработчиков на основе BCC (BPF Compiler Collection). Из возможностей, которые имеются в DTrace и пока отсутствуют в BPFtrace упоминаются средства агрегирования вывода, обработка аргументов для shell, поддержка трансляторов, sizeof() и спекулятивный режим трассировки. Среди функциональности, которая есть в BPFtrace, но недоступна в DTrace отмечается поддержка сохранения и извлечения трассировок стека с использованием переменных, а также возможность привлечения инструментария bcc для создания сложных сценариев и обработки аргументов. Эквивалентные вызовы в DTrace и BPFtrace: ТипDTracebpftrace function@ = quantize(value)@ = hist(value) function@ = lquantize(value, min, max, step)@ = lhist(value, min, max, step) variablethis->name$name variableself->name@name[tid] variablename[key]@name[key] variableglobal_name@global_name variableself->name = 0delete(@name[tid]) variablecurthreadcurtask variableprobeprov probemod probenamename providerfbt::func:entrykprobe:func providerfbt::func:returnkretprobe:func providerpid$target::func:entryuprobe:func providerpid$target::func:returnuretprobe:func providerprofile:::99profile:hz:99 providerprofile:::tick-1secinterval:s:1 Примеры однострочников: # Отслеживание задержек при чтении данных процессом с PID 181: bpftrace -e 'kprobe:vfs_read /pid == 30153/ { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns = hist(nsecs - @start[tid]); delete(@start[tid]); }' # Отображение новых процессов с аргументами их вызова bpftrace -e 'tracepoint:syscalls:sys_enter_execve { join(args->argv); }' # Отслеживание файлов, открытых процессами bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args->filename)); }' # Подсчёт системных вызовов с группировкой по приложениям bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }' # Подсчёт системных вызовов с группировкой по системным вызовам bpftrace -e 'tracepoint:syscalls:sys_enter_* { @[name] = count(); }' # Подсчёт системных вызовов с группировкой по процессам bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[pid, comm] = count(); }' # Размер данных в байтах, прочитанных процессом bpftrace -e 'tracepoint:syscalls:sys_exit_read /args->ret/ { @[comm] = sum(args->ret); }' # Активность обращения процессов к диску; bpftrace -e 'tracepoint:block:block_rq_issue { printf("%d %s %d\n", pid, comm, args->bytes); }' # Сведения об обращениях к не выделенным страницам памяти (page fault) с сортировкой по числу обращений; bpftrace -e 'software:major-faults:1 { @[comm] = count(); }' # Сведения об обращениях к не выделенным страницам памяти (page fault) с сортировкой по процессам; bpftrace -e 'software:faults:1 { @[comm] = count(); }' # Профилирование стека процесса с PID 189 с частотой 99 Гц. bpftrace -e 'profile:hz:99 /pid == 189/ { @[ustack] = count(); }'