Релиз набора компиляторов LLVM 4.0

После шести месяцев разработки подготовлен релиз проекта LLVM 4.0 (Low Level Virtual Machine) - GCC-совместимого инструментария (компиляторы, оптимизаторы и генераторы кода), компилирующего программы в промежуточный биткод RISC-подобных виртуальных инструкций (низкоуровневая виртуальная машина с многоуровневой системой оптимизации). Сгенерированный псевдокод может быть преобразован при помощи JIT-компилятора в машинные инструкции непосредственно в момент выполнения программы. LLVM 4.0 стал первым выпуском в рамках новой нумерации версий, в которой решено уйти от разделения значительных и функциональных выпусков. Отныне в каждом функциональном обновлении будет меняться первая цифра (в сентябре состоится релиз LLVM 5.0.0, весной следующего года 6.0.0 и т.д.). Для обеспечения совместимости с существующими системами разбора номеров версий LLVM корректирующие обновления, как и раньше будут приводить к увеличению третьей цифры (4.0.1, 4.0.2, 4.0.3). Из новых возможностей LLVM 4.0 отмечается использование статистики выполнения в оптимизаторе ThinLTO, более агрессивное устранение бесполезного кода, экспериментальная поддержка сопрограмм, экспериментальная поддержка целевой платформы AVR, улучшение совместимости с GNU ld и значительное увеличение производительности компоновщика LLD. Улучшения в Clang 4.0: В оптимизатор ThinLTO ("-flto=thin"), работающий на этапе связывания, добавлена поддержка учёта данных профилирования (PGO, Profile-guided optimization), накопленных в процессе выполнения программы, для более точного принятия решений об импортировании функций и продвижения косвенных вызовов между различными модулями. При включении отладочного режима (-g) существенно сокращено время сборки и уменьшен размер исполняемого файла; Добавлен атрибут diagnose-if, позволяющем выводить предупреждения или ошибки, если вызов функции соответствует одному или нескольким условиям, определённым пользователем. Например: void abs(int a) __attribute__((diagnose_if(a >= 0, "Redundant abs call", "warning"))); Расширены средства девиртуализации (замена непрямых вызовов на условное выполнение развёрнутых inline-блоков) при помощи новой опции "-fstrict-vtable-pointers"; Представлен новый флаг компиляции "-Og", позволяющий выполнить оптимизацию с учётом применения сборки для отладки (в текущей версии опция аналогична применению режима "-O1"); Добавлена опция "-MJ" для вывода БД компиляции в формате JSON для интеграции с существующими системами сборки; Устранена порция ошибок в реализации OpenCL и добавлено новое OpenCL-расширение cl_khr_mipmap_image. Добавлен флаг "-cl-ext" для переопределения списка расширений, компилируемых для выбранной целевой платформы. Добавлены "#pragma OPENCL EXTENSION the_new_extension_name : begin/end" для добавления собственных расширений OpenCL без правки кода Clang. В документацию Clang включено руководство по OpenCL; В статическом анализаторе улучшена поддержка кода, использующего gtest. Добавлена опция "--show-description" для вывода описаний дефектов в списке scan-build. Добавлены новые проверки: предупреждение при виртуальных вызовах из конструкторов и деструкторов, проверка синхронизированных копий свойств mutable-типов в Objective C, таких как NSMutableArray, проверка нежелательных сравнений NSNumber, CFNumberRef и других числовых объектов Cocoa со скалярными значениями; В linter clang-tidy добавлена большая порция новых проверок. В include-fixer обеспечена интеграция с Emacs; Основные новшества LLVM 4.0: Добавлена экспериментальная поддержка сопрограмм, активируемая при указании опции "-enable-coroutines" или через API addCoroutinePassesToExtensionPoints; В компоновщике LLD значительно улучшена совместимость с GNU linker в плане поддержки формата ELF. LLD доведён до возможности применения для связывания всех файлов при сборке базовой системы и ядра FreeBSD. Значительно увеличена производительности многопоточного режима, который теперь включен по умолчанию. LLD 4.0 примерно в полтора раза быстрее чем LLD 3.9 при выполнении связывания больших программ. Значительные оптимизации также реализованы и при работе с форматом COFF, например, скорость связывания Chromium DLL в окружении Windows возросла в два с половиной раза, по сравнению с прошлым выпуском; Повышены требования к минимальным версиям компиляторов GCC и Visual Studio 2015. Для сборки LLVM теперь необходимы как минимум GCC 4.8 и Visual Studio 2015; Обеспечена обработка invariant.group для различных базовых блоков, что сделало возможным выполнение девиртуализации виртуальных вызовов внутри циклов; В фазе агрессивного удаления мёртвого кода (adce) реализовано удаление веток, не влияющих на поведение программы. Циклы оставляются по умолчанию, но они могут быть удалены при явном указании опции "-adce-remove-loops", если тело цикла не включает значимых операций; В утилиту llvm-cov добавлена возможность экспорта coverage-статистики в формате JSON. Кроме того, также улучшен вывод в формате HTML; Добавлена поддержка соглашения о вызове __regcall, предложенного в компиляторе Intel и нацеленного на максимальное использование регистров для передачи и возвращения значений. Соглашение о вызове __vectorcall, представленное в компиляторах Microsoft, расширено возможностью корректной обработки HVA (Homogeneous Vector Aggregate); Реализована возможность тестирования фаз компиляции, манипулирующих машинными инструкциями, используя формат сериализации MIR (Machine IR). В LLC (LLVM static compiler) добавлена поддержка опций "-run-pass", "-stop-after", "-stop-before", "-start-after" и "-start-before" для запуска только одной выбранной фазы в цепочке генерации кода или для остановки/запуска цепочки генерации кода с заданной позиции; В состав включён бэкенд с поддержкой архитектуры AVR; Для архитектуры x86 добавлена поддержка CPU AMD Ryzen (znver1), обеспечено применения кодирования VEX для CPU с поддержкой AVX-512 для сокращения размера кода, улучшена генерация кода с инструкциями AVX-512; Внесены многочисленные улучшения в бэкенды для архитектур AArch64, ARM, MIPS и PowerPC.