Спецификация C++0X принята в качестве международного стандарта C++11

Завершилась длительная эпопея по принятию нового стандарта для языка программирования Си++. Комитет ISO по стандартизации языка C++ единогласно утвердил спецификацию C++0X в качестве международного стандарта "C++11". Стандарт C++0X планировалось выпустить еще в 2008 году, но его принятие постоянно откладывалось. Большинство представленных в стандарте возможностей уже поддерживаются в таких компиляторах, как GCC, IBM C++, Intel C++, Visual C++, C++ Builder. Поддерживающие C++11 стандартные библиотеки реализованы в рамках проекта Boost. Новый стандарт развивался более 10 лет и пришел на смену стандартам C++98 и C++03. Отмечается, что если различия между стандартами C++98 и C++03 были столь незначительными, что их можно было не заметить, то стандарт C++11 содержит ряд кардинальных улучшений, как самого языка, так и стандартной библиотеки. По словам Бьерна Страуструпа, создателя C++, C++11 ощущается как новый язык, части которого лучше сочетаются друг с другом. В C++11 высокоуровневый стиль программирования стал более естественным, а эффективность возросла как никогда раньше. Кроме того, язык стал проще для изучения и освоения новичками. Основные улучшения, отраженные в стандарте C++11: Расширение стандартной библиотеки в таких областях, как регулярные выражения, хэши, генераторы случайных чисел, интеллектуальные указатели и т.п. Поддержка лямбда-выражений и лямбда-функций, т.е. анонимных функций, объявляемых в месте использования. Например, "[](int x, int y) { return x + y; }"; Поддержка списков инициализации, т.е. передачи структуры или массива в виде списка значений. Например: для конструктора или функции Test можно указать шаблонный класс std::initializer_list и затем для инициализации использовать "Test testVar = {1, 2, 3, 4};" или "Test(1,2,3,4,5)"; Универсальная форма инициализации для всех видов объектов с помощью расширения синтаксиса списков инициализации; Поддержка ключевого слова "decltype" для определения типа выражения во время компиляции, например, можно указать "decltype(someVar) otherIntegerVariable = 5;"; Возможность автоматического назначения типа при указании ключевого слова "auto". Тип выбирается на основании анализа типа аргумента. Например, "auto otherVariable = 5;"; Возможность создания шаблона функции, возвращаемый тип которого определяется автоматически на основании другой функции или выражения; Аналог циклов "foreach" для перебора элементов коллекции. Например, для перебора элементов массива my_array достаточно указать "for(int &x : my_array)"; Реализация нового типа ссылок на временные объекты (Rvalue References), объявляемые через выражение "type &&"; Реализация ключевого слова "constexpr", позволяющего указать, что выражение (функция или конструктор) возвращает константу и данные выражения можно использовать как константы, например: "constexpr int GetFive() {return 5;}". В дальнейшем GetFive можно указать, например, при определении массива "int some_value[GetFive() + 7];"; Ослаблены требования при определении типов простых данных. Например, как тип простых данных могут рассматриваться классы, при соблюдении ряда правил; Поддержка определения внешних шаблонов, позволяющих увеличить скорость компиляции; Возможность создавать шаблоны с переменным количеством аргументов; Расширенная поддержка символов в Unicode; Возможность вызывать одни конструкторы класса из других конструкторов этого же класса, что позволяет создавать конструкторы, использующие другие конструкторы без дублирования кода; Возможность использования локальных и безымянных типов в качестве аргументов шаблонов; Вместо макроса NULL для обозначения нулевого указателя введено ключевое слово nullptr.