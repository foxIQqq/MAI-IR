Выпуск библиотеки хэш-функций Fast Positive Hash 2.0.1

Состоялся новый выпуск библиотеки libt1ha, которая предоставляет быстрые некриптографические хеш-функции с несколькими уровнями качества хеширования, точнее говоря с различным балансом скорость/качество. По планам разработки, примерно раз в год библиотека пополняется функциями со следующим «уровнем качества» и/или для нацеленных на различные применения. Код проекта поставляется под свободной лицензией Zlib. В конце марта этого года в libt1ha было добавлено несколько функций с очередным (вторым) уровнем качества хеширования. Новые функции обеспечивают соблюдение критерия строго лавинного эффекта во всех случаях, затрачивая на обработку лишь на пару тактов процессора больше. Также теперь доступны 128-битные некриптографические дайджесты (цифровые отпечатки). Все функции libt1ha проходят все проверки в хорошо зарекомендовавшем себя наборе тестов SMHasher. А обнаруженные Yves Orton отклонения от строгого лавинного эффекта в хеш-функциях первого уровня качества крайне малозначительны при использовании этих функций по их назначению. Кроме добавления новых функций, в сборке libt1ha теперь доступен тест производительности, реализующий замеры с точностью до тактов процессора на большинстве современных платформ. В том числе сравнение с одной из самых быстрых переносимых хеш-функций xxhash. Следует отметить, что результаты могут существенно отличаться в зависимости от компилятора и аппаратной платформы. Однако, усредняя доступные результаты можно сделать вывод, что t1ha является семейством самых быстрых переносимых хеш-функций при выполнении на всех современных 64-битных процессорах (Elbrus, x86_64, ARM64, MIPS64). Пользуясь случаем, хотелось бы пригласить заинтересованных разработчиков в тестировании и доработке кода реализующего прецизионный замер выполнения коротких функций на широком спектре аппаратных платформ. После ожидаемых доработок и стабилизации этот механизм планируется выделить в отдельную открытую библиотеку. Более подробно о семействе t1ha можно узнать из осенней статьи на «Хабре», а в мае ожидается доклад автора на конференции «Positive Hack Days». В качестве примера ниже протокол выполнения на x86_64 Intel i7-6700K при использовании компилятора clang 5.0: Preparing to benchmarking... - running on CPU#0 - use RDPMC_40000001 as clock source for benchmarking - assume it cheap and stable - measure granularity and overhead: 54 cycle, 0.0185185 iteration/cycle Bench for tiny keys (5 bytes): t1ha2_atonce : 13.070 cycle/hash, 2.614 cycle/byte, 0.383 byte/cycle, 1.148 Gb/s @3GHz t1ha2_atonce128* : 29.984 cycle/hash, 5.997 cycle/byte, 0.167 byte/cycle, 0.500 Gb/s @3GHz t1ha2_stream* : 79.062 cycle/hash, 15.812 cycle/byte, 0.063 byte/cycle, 0.190 Gb/s @3GHz t1ha2_stream128* : 99.750 cycle/hash, 19.950 cycle/byte, 0.050 byte/cycle, 0.150 Gb/s @3GHz t1ha1_64le : 14.055 cycle/hash, 2.811 cycle/byte, 0.356 byte/cycle, 1.067 Gb/s @3GHz t1ha0 : 14.070 cycle/hash, 2.814 cycle/byte, 0.355 byte/cycle, 1.066 Gb/s @3GHz xxhash32 : 16.000 cycle/hash, 3.200 cycle/byte, 0.312 byte/cycle, 0.938 Gb/s @3GHz xxhash64 : 17.203 cycle/hash, 3.441 cycle/byte, 0.291 byte/cycle, 0.872 Gb/s @3GHz Bench for medium keys (1024 bytes): t1ha2_atonce : 266.000 cycle/hash, 0.260 cycle/byte, 3.850 byte/cycle, 11.549 Gb/s @3GHz t1ha2_atonce128* : 266.144 cycle/hash, 0.260 cycle/byte, 3.848 byte/cycle, 11.543 Gb/s @3GHz t1ha2_stream* : 300.750 cycle/hash, 0.294 cycle/byte, 3.405 byte/cycle, 10.214 Gb/s @3GHz t1ha2_stream128* : 307.000 cycle/hash, 0.300 cycle/byte, 3.336 byte/cycle, 10.007 Gb/s @3GHz t1ha1_64le : 245.875 cycle/hash, 0.240 cycle/byte, 4.165 byte/cycle, 12.494 Gb/s @3GHz t1ha0 : 86.375 cycle/hash, 0.084 cycle/byte, 11.855 byte/cycle, 35.566 Gb/s @3GHz xxhash32 : 524.250 cycle/hash, 0.512 cycle/byte, 1.953 byte/cycle, 5.860 Gb/s @3GHz xxhash64 : 282.750 cycle/hash, 0.276 cycle/byte, 3.622 byte/cycle, 10.865 Gb/s @3GHz