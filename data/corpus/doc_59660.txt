В Python устранена уязвимость в реализации TLS

Опубликованы корректирующие обновления языка программирования Python 3.11.5, 3.10.13, 3.9.18 и 3.8.18, в которых устранена уязвимость (CVE-2023-40217) в классе ssl.SSLSocket, позволяющая обойти стадию согласования TLS-соединения и связанные с ним процессы, такие как проверка сертификата. Успешная атака может привести к обработке незашифрованных данных так, как если бы они были переданы с использованием корректного TLS-соединения. Проблема вызвана тем, что после создания сокета имеется небольшое окно, во время которого принятые и помещённые в буфер сокета данные будут обработаны как прочитанные от клиента, если соединение будет закрыто до того, как начнётся процесс согласования TLS-соединения. Для совершения атаки достаточно установить соединение, сразу отправить данные и закрыть сокет, не дожидаясь ответа для согласования TLS-соединения. Размер данных, который может быть отправлен в ходе атаки ограничен размером сетевого буфера. Уязвимость затрагивает серверные приложения (например, HTTPS-серверы), использующие штатную Python-библиотеку ssl для организации защищённого канала связи, в котором применяется аутентификация по клиентским сертификатам (например, mTLS). Уязвимость может использоваться только для отправки данных в обход аутентификации по сертификатам - так как соединение сразу закрывается, ответ на запрос не будет отправлен клиенту. При этом уязвимость вполне может применяться для атак на API, через которые можно внести изменения или удалить данные. Уязвимость также может быть использована для атаки на клиентов, подключаемых к контролируемому атакующими серверу, если эти клиенты сразу переходят к чтению данных из сокета, без предварительной отправки запроса (обычные клиентские приложения, такие как pip, которые используют HTTPS для отправки запросов, уязвимость не затрагивает). Кроме того, в ветке Python 3.11 устранена ещё одна уязвимость (CVE-2023-41105), позволяющая обойти проверки допустимых файловых путей, выполняемые с использованием функции os.path.normpath(). Уязвимость вызвана тем, что если в пути присутствуют символы с нулевым кодом ('\0'), то функция os.path.normpath() обрезает путь после первого нулевого символа. При этом в последующих функциях работы с файлами может использоваться полный, а не обрезанный путь. Проблема проявляется только в ветке 3.11.x, т.е. код на базе os.path.normpath(), корректно блокирующий недопустимые пути при выполнении в Python 3.10.x, можно обойти при выполнении этого кода в Python 3.11.x.