Второй отчет о развитии системного менеджера systemd

Леннарт Поттеринг, возглавляющий разработку перспективной системы инициализации systemd, представил очередной отчет о развитии проекта, приуроченный к его 13-му релизу. Ключевые моменты: Уже сейчас, в составе Fedora 15/Rawhide, systemd 13 способен обеспечить полноценную загрузку системы без использования shell-скриптов. Однако, все еще существуют отдельные ситуации, когда без скриптов обойтись невозможно, в частности: Включен autoswapping (Леннарт отмечает, что это в любом случае не лучшая идея); Требуется полная переустановка меток SELinux; Выполняется первая загрузка после установки системы; Производится загрузка модулей ядра, сконфигурированная без использования соответствующего штатного механизма systemd; Производится загрузка с доступной только на чтение NFS; Задействованы LVM/RAID/Multipath. Во всех остальных случаях, используя Fedora 15/Rawhide, вы уже сейчас можете полностью избавиться от скрипт-костылей и насладиться невероятно быстрой загрузкой. Что касается перечисленных ситуаций, то Леннарт и его коллеги интенсивно работают над расширением возможностей systemd, так что, вероятно, к выходу Fedora 15 список таких неудобных ситуаций будет сильно сокращен. Подготовлен написанный на C инструмент, обеспечивающий корректную остановку системы, включая остановку всех процессов, отмонтирование всех файловых систем, отключение всех loopback-устройств и томов Device Mapper (LVM, Multipath, etc.). Все эти операции производятся по тщательно продуманному алгоритму, обеспечивающему их корректное выполнение практически в любой ситуации. Например, большинство современных скрипт-костылей оставляют смонтированной файловую систему, если на ней находится файл, подключенный к loopback-устройству, что приводит к необходимости запуска fsck для данной ФС при следующей загрузке. systemd в такой ситуации, выполнив отключение loopback-устройств, повторно попытается отмонтировать еще смонтированные ФС. Отметим, что данный модуль может быть использован как после полной остановки всех служб (обычное выключение/перезагрузка), так и без нее — в последнем случае он предоставляет корректную и безопасную замену действиям halt -f/reboot -f. В systemd добавлена базовая реализация упреждающего чтения (read ahead) с HDD и SSD-накопителей, использующая новейшие возможности ядра Linux, такие, как fanotify(), fadvise() и mincore(). Леннарт отмечает, что полученное в результате ускорение процесса загрузки должно проявляться на любых компьютерах, однако оно будет особенно заметно на старых и медленных машинах. Подготовлен, написанный на C модуль, выполняющий запуск fsck и активацию квот файловых систем с обеспечением максимально возможной степени параллелизации операций. Каждая служба, каждый пользователь и каждый пользовательский сеанс выделяются в собственную контрольную группу по CPU-ресурсу, что позволит «из коробки» получить ту самую «killer feature» (высокую отзывчивость сильно нагруженной системы) без наложения дополнительных патчей на ядро или использования небезопасных и не вполне универсальных решений. systemd предоставляет интерфейс протоколирования /dev/log, действующий с ранней стадии загрузки до момента полной остановки системы. В том случае, если демон системного лога не запущен, запись ведется в буфер ядра (kmsg). После запуска этого демона, накопленные лог-записи обрабатываются им согласно соответствующим настройкам. Таким образом, systemd позволяет обеспечить регистрацию событий в системе практически на все время ее функционирования. Подробнее о концепции этого механизма и его достоинствах можно почитать в прошлом отчете. Добавлена команда «systemctl kill», обеспечивающая отправку заданного сигнала всем процессам определенной службы, таким образом, обеспечив ее корректную остановку. Этим systemd отличается от классических механизмов вроде «kill `cat /var/run/daemon.pid`», которые в некоторых случаях допускают возможность продолжения работы порожденных службой процессов (например, некорректно форкнувшегося и потерявшего связь с родителем CGI-процесса при остановке web-сервера). Подробнее об этих вопросах можно почитать в четвертой статье из цикла «systemd for Administrators». В systemd реализована возможность загрузки правил SELinux. Таким образом, один и тот же бинарник systemd может использоваться при загрузке как с initrd, так и без него. К удивлению самих авторов, systemd оказался первой (и пока последней) системой инициализации Linux, поддерживающей такую возможность. systemd обеспечивает настройку системной локали (соответствующих переменных окружения), которая автоматически наследуется всеми процессами в системе (и, разумеется, может быть перекрыта при необходимости). Добавлена штатная поддержка работы с шифрованными LUKS/dm-crypt томами, включая чтение настроек из /etc/crypttab. Особенно интересна модульная структура реализации запроса пароля, работающая с самыми различными агентами. Например, при загрузке пароль может быть запрошен через Plymouth или непосредственно в консоли, а при горячем подключении — через графическую утилиту в составе GNOME или механизм wall. Также, при ручной активации юнита через команду «systemctl start», пароль может быть запрошен из той же консоли. Интерфейс взаимодействия агента запроса пароля с systemd очень прост, отмечает Леннарт, и предлагает разработчикам KDE лично убедиться в этом, создав собственную реализацию агента. С другой стороны, данная инфраструктура может использоваться для работы не только с шифрованными томами, но и вообще с любыми программными и аппаратными компонентами, запрашивающими некие пароли (например, шифровальными токенами). Наконец, стоит отметить что, благодаря модульной организации этой инфраструктуры, она не является обязательной частью systemd, что значительно упрощает его сборку, например, для embedded-систем, в которых поддержка шифрованных томов обычно не требуется, но требования по потреблению памяти и места на диске являются довольно жесткими. Механизм плагинов также используется в системе генераторов — специальных программ, динамически формирующих файлы конфигурации юнитов (units) systemd. Таким образом можно, например, упростить развертывание большого количества виртуальных окружений на базе LXC или KVM, с сохранением полного централизованного контроля над ними. systemd берет на себя автоматическую очистку и формирование внутренней структуры «динамических» каталогов, таких, как /tmp, /var/run и /var/lock, что позволяет выносить их в tmpfs без дополнительных усилий. Реализовано измерение и регистрация длительности всех операций, происходящих при загрузке, что упрощает процесс выявления «узких мест». Обеспечивается корректное завершение сеансов пользователя. Раньше при остановке Linux отнюдь не редко встречалась ситуация, когда некоторые пользовательские процессы завершались позже всех демонов, просто потому, что они отделились от основного сеанса и не были завершены вместе с ним. С systemd такое исключено. Добавлена поддержка маскирования — специального механизма, позволяющего полностью заблокировать запуск какой-либо службы. Обычный метод «systemctl disable», запрещая автоматический запуск службы, оставляет возможность для ручного запуска через «systemctl start». Маскирование, состоящее в создании в /etc/systemd/system символьной ссылки с именем соответствующей службы, указывающей на /dev/null, полностью блокирует как автоматический, так и ручной запуск службы. В файлах описания юнитов теперь можно использовать проверку некоторых условий, в частности, существования заданных файлов или наличия каких-либо файлов в заданном каталоге (проверка на непустой каталог), присутствие определенных параметров в командной строке ядра. В дополнение к классическим механизмам halt, reboot и poweroff, добавлена реализация перезагрузки через использование kexec, позволяющей избежать затрат времени на инициализацию BIOS, что особенно актуально для серверного оборудования, в котором этот период бывает достаточно длительным. Реализовано «умное» (в стиле zsh) дополнение опций systemctl для bash (требуется версия bash >=4.0). Andrew Edmunds добавил в systemd поддержку дистрибутива Ubuntu. Однако, пока что фирма Canonical не стремится интегрировать systemd в свой дистрибутив, предпочитая собственную разработку — upstart, которая, к сожалению, использует не столь эффективные методы параллелизации и значительно уступает systemd по возможностям. Тем временем, разработчики Debian — Michael Biebl и Tollef Fog Heen — работают над полной интеграцией systemd в Debian, с возможностью загрузки системы без установленного пакета initscripts. Подробнее см. эту страницу в Debian Wiki. [Прим. перев.: заметим, что интеграцией systemd в Fedora и openSUSE занимаются его непосредственные разработчики — Леннарт Поттеринг, сотрудник Red Hat, и Кай Сиверс (Kay Sievers), сотрудник Novell.]