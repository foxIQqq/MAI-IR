Выпуск языка программирования Rust 1.66

Опубликован релиз языка программирования общего назначения Rust 1.66, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Методы работы с памятью в Rust избавляют разработчика от ошибок при манипулировании указателями и защищают от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами, учёт времени жизни объектов (области видимости) и оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок. Основные новшества: В перечислениях c целочисленными представлениями (атрибутом "#[repr(Int)]") разрешено явное указание дискриминанта (номера варианта в перечислении), даже если перечисление содержит поля. #[repr(u8)] enum Foo { A(u8), # дискриминант 0 B(i8), # дискриминант 1 C(bool) = 42, # дискриминант 42 } Добавлена функция core::hint::black_box, которая просто возвращает назад принятое значение. Так как компилятор считает, что данная функция выполняет определённое действие, функцию black_box можно использовать для отключения оптимизации компилятором циклов при проведении тестирования производительности кода или при изучении генерируемого машинного кода (чтобы компилятор не посчитал код неиспользуемым и не убрал его). Например, в примере ниже указание black_box(v.as_ptr()) не позволяет компилятору считать, что вектор v не используется. use std::hint::black_box; fn push_cap(v: &mut Vec) { for i in 0..4 { v.push(i); black_box(v.as_ptr()); } } В пакетном менеджере "cargo" предложена команда "remove", позволяющая из командной строки удалять зависимости из манифеста Cargo.toml. В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: proc_macro::Span::source_text u*::{checked_add_signed, overflowing_add_signed, saturating_add_signed, wrapping_add_signed} i*::{checked_add_unsigned, overflowing_add_unsigned, saturating_add_unsigned, wrapping_add_unsigned} i*::{checked_sub_unsigned, overflowing_sub_unsigned, saturating_sub_unsigned, wrapping_sub_unsigned} BTreeSet::{first, last, pop_first, pop_last} BTreeMap::{first_key_value, last_key_value, first_entry, last_entry, pop_first, pop_last} Реализации Add AsFd для типов блокировок stdio при применении WASI. impl TryFrom<Vec<T>> для Box<[T; N]> core::hint::black_box Duration::try_from_secs_{f32,f64} Option::unzip std::os::fd В шаблонах разрешено применение диапазонов "..X" и "..=X". При сборке фронтэнда компилятора rustc и бэкенда LLVM задействованы режимы оптимизации LTO (Link Time Optimization) и BOLT (Binary Optimization and Layout Tool), позволяющие увеличить производительность результирующего кода и снизить потребление памяти. Реализован третий уровень поддержки для платформ armv5te-none-eabi и thumbv5te-none-eabi. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования, публикации официальных сборок и проверки возможности сборки кода. Добавлена поддержка связывания с универсальными библиотеками macOS. Дополнительно можно отметить включение в кодовую базу GCC фронтэнда компилятора языка Rust (gccrs). Фронтэнд включён в ветку GCC 13, релиз которой состоится в мае 2023 года. Начиная с GCC 13 штатный инструментарий GCC сможет использоваться для компиляции программ на языке Rust без необходимости установки компилятора rustc, построенного с использованием наработок LLVM. Реализация Rust в GCC 13 будет иметь статус бета-версии, не включаемой по умолчанию.