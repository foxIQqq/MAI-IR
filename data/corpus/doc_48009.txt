Выпуск системной библиотеки Glibc 2.27

После шести месяцев разработки состоялся релиз системной библиотеки GNU C Library (glibc) 2.27, которая полностью следует требованиям стандартов ISO C11 и POSIX.1-2008. В состав нового выпуска включены исправления от 73 разработчиков. Примечательно, что мэйнтейнером выпуска 2.27 стал Дмитрий Левин, генеральный конструктор ALT Linux. Из добавленных в Glibc 2.27 улучшений можно отметить: Реализованы новые функции memfd_create и mlock2, специфичные для платформы Linux. Функция memfd_create позволяет создавать области маппинга памяти при помощи механизма memfd, при котором область памяти идентифицируется через файловый дескриптор, который может передаваться между процессами (можно выделить память как по malloc, но обращаться к ней как с файлом, по файловому дескриптору). Функция mlock2 расширяет возможности вызова mlock() поддержкой дополнительного аргумента, позволяющего задействовать новый режим блокировки VM_LOCKONFAULT, при котором страницы памяти в указанном диапазоне будут закреплены в ОЗУ не сразу, а только после возникновения page fault (обращение к невыделенным страницам памяти); Добавлена поддержка механизма PKU (Memory Protection Keys), реализованного в серверных моделях процессоров Intel на базе микроархитектуры Skylake для защиты доступа к страницам памяти из пространства пользователя без изменения таблиц страниц памяти при изменении домена защиты. Для использования данного режима в sys/mman.h добавлены функции pkey_alloc, pkey_free, pkey_mprotect, pkey_set и pkey_get, которые можно использовать для дополнительной защиты размещения в памяти ключей шифрования, предоставив возможность чтения только для одного потока в многопоточной программе шифрования; Добавлена функция copy_file_range, позволяющая ускорить выполнение операций копирования данных из одного файла в другой файл с выполнением операции только на стороне ядра без предварительного чтения данных в память процесса, что избавляет от частого переключения контекста между ядром и пространством пользователя. Тем не менее в обычных условиях использование copy_file_range лишь немного быстрее обычной команды "cp", так как основное время уходит на ввод/вывод с накопителя; Добавлена возможность компиляции Glibc (опция "--enable-static-pie") с поддержкой сборки статически связанных исполняемых файлов в формате PIE. По сравнению с обычными статическими исполняемыми файлами подобные файлы в формате PIE могут быть загружены по любому адресу и предоставляют дополнительные средства защиты ценой определённого повышения потребления памяти и снижения производительности. При сборке Glibc с опцией "--enable-static-pie" формируется файл libc.a, который можно использовать с компилятором GCC 8 для создания статических файлов PIE при указании опции '-static-pie'. Возможность реализована для архитектур i386, x86_64 и x32 (требуется binutils 2.29), а также aarch64 (требуется binutils 2.30); Добавлена поддержка архитектуры RISC-V, которая предоставляет открытую и гибкую систему машинных инструкций, позволяющую создавать микропроцессоры для произвольных областей применения, не требуя при этом отчислений и не налагая условий на использование. RISC-V позволяет создавать полностью открытые SoC и процессоры. Для использования RISC-V также требуется binutils 2.30, gcc 7.3.0 и ядро Linux 4.15; Проведена оптимизация кода функций asin, atan2, exp, expf, log, pow, atan, sin, cosf, sinf, sincosf и tan с задействованием набора инструкций FMA (Fused Multiply–Add) на платформе x86_64; Проведена оптимизация кода функций trunc и truncf с задействованием инструкций SSE4.1 на платформе x86_64; Проведены общие платформонезависимые оптимизации кода функций expf, exp2f, logf, log2f, powf, sinf, cosf и sincosf; Проведена оптимизация функций memcpy, mempcpy, memmove и memset для процессоров Sparc M7; С целью обеспечения более быстрого и безопасного завершения процессов в наборе функций malloc прекращён вывод информации об адресе сбоя и обратной трассировке стека. Целью изменения является минимизация действий, выполняемых после обнаружения выхода за границы диапазонов памяти, чтобы избежать потенциальных уязвимостей в коде обработки данных ситуаций и сократить время завершения работы процесса; В функции abort обеспечено мгновенное завершение процессов без сброса буферов ввода/вывода в stdio, что снижает вероятность повреждения данных после краха и возникновения ситуаций взаимной блокировки; В библиотеку математических функций добавлены интерфейсы _Float32, _Float64 и _Float32x в соответствии с требованиями стандарта ISO/IEC TS 18661-3:2015. Для платформ с поддержкой формата IEEE binary128 для типа "long double" (aarch64, alpha, mips64, riscv, s390 и sparc) в библиотеке математических функций также реализованы интерфейсы _Float128 для данного типа; В утилите ldconfig при обработке директивы include обеспечена сортировка в соответствии с локалью C/POSIX (ранее использовались правила из текущей локали, что приводило к проблемам); Добавлена поддержка двух грамматических форм имён месяцев (например, января и январь). В strftime спецификаторы "%B" и "%b" теперь выводят имена месяца с учётом их грамматической формы в контексте общей даты, а новые спецификаторы %OB" и "%Ob" могут применяться для вывода грамматической формы названия месяца как такового. В функции strptime считаются корректными любые формы имени месяца, обрабатываемые через специфкаторы %B", "%b", "%h", "%OB", "%Ob" и "%Oh". Вызов nl_langinfo выводит форму со склонением при указании флагов MON_1..12 и ABMON_1..12 либо нормальную форму при указании флагов ALTMON_1..12 и _NL_ABALTMON_1..12; Устаревшая функциональность и изменения, приводящие к нарушению обратной совместимости: Изменения в бинарном формате локали не позволяют использовать файлы локали, собранные для Glibc 2.27, в статически скомпилированных приложениях. В этом случае вместо запрошенной локали будет включена локаль C/POSIX, а для корректной загрузки локали требуется перекомпиляция приложения; Объявлена устаревшей возможность использования в статически скомпилированных приложениях вызова dlopen. Поддержка таких приложений будет прекращена в следующем выпуске. Для подобных программ следует применять динамическое связывание; Объявлена устаревшей и будет прекращена в следующем выпуске поддержка старых программ, в которых используются внутренние структуры данных и функции stdio (_IO_*), в том числе программы C++, использующих класс streams из libstdc++ (GCC 2.95); Из заголовочного файла sys/ptrace.h убрано определение константы PTRACE_SEIZE_DEVEL на системах GNU/Linux; В libm прекращена поддержка обработчиков ошибок SVID (вызов пользовательской функции matherr при ошибке) и применение переменной _LIB_VERSION для управления обработкой ошибок. Прекращена поставка библиотеки libieee.a. Из заголовочного файла math.h убраны определения макросов X_TLOSS, DOMAIN, SING, OVERFLOW, UNDERFLOW, TLOSS, PLOSS и HUGE; В новых программах прекращена поддержка функций pow10, pow10f и pow10l, вместо которых следует использовать exp10, exp10f и exp10l; Прекращена поддержка механизма сборки дополнительных пакетов во время сборки Glibc. Опция "--enable-add-ons" теперь игнорируется; Во время сборки теперь не учитывается опция "--without-fp", а задействование аппаратных средств вычислений с плавающей запятой производится на уровне опций компилятора; В функции res_hnok, res_dnok, res_mailok и res_ownok добавлена проверка соответствия переданной строки требованиям к доменному имени; Объявлены устаревшими заголовочные файлы libio.h и _G_config.h, вместо определённых в них GNU-расширений следует использовать стандартные интерфейсы stdio.h; Для сборки содержимого каталога intl теперь требуется пакет bison 2.7 или более новая версия; Устранены уязвимости: CVE-2017-15670, CVE-2017-15671, CVE-2017-15804 - переполнения буфера в функции glob. Потенциально могут привести к выполнению кода злоумышленника при выполнения поиска имен файлов по шаблону при помощи функции glob(). Проблема проявляется при использование флага GLOB_TILDE (расширение GNU) в процессе обработки домашних директорий при помощи оператора "~", идущего после длинной строки (при обработке пути вида "~длинная_строка/a/b"). CVE-2017-1000409 - может привести к повышению своих привилегий в системе. Уязвимость вызвана переполнением буфера в компоновщике ld.so и может быть эксплуатирована через указание специально подобранных данных в переменной LD_LIBRARY_PATH перед запуском suid-программ. Для эксплуатации переполнения буфера локальный атакующий должен иметь возможность создания жесткой ссылки на исполняемый SUID-файл в каталог, содержащий двоеточие в имени. Также требуется, чтобы применяемая в дистрибутиве версия ld.so передавала переменную окружения LD_LIBRARY_PATH в функцию _dl_init_paths(). CVE-2017-1000408 - некорректное вычисление размера массива в функции _dl_init_paths может привести к утечке содержимого памяти процессов через манипуляцию с переменной окружения LD_HWCAP_MASK. CVE-2018-1000001 - переполнение через нижнюю границу буфера в функции realpath(), проявляющееся при возврате относительного пути системным вызовом getcwd(). Существует рабочий прототип эксплоита, позволяющий поднять свои привилегии до прав root через манипуляцию с исполняемыми файлами с флагом suid root, в которых вызывается функция realpath(); CVE-2009-5064 - запуск программы в режиме проверки скриптом ldd может привести к запуску исполняемого кода; CVE-2017-17426 - вызов функции malloc для объекта размером близким к SIZE_MAX может привести к возврату указателя на буфер недостаточного размера, вместо возврата NULL при нехватке памяти; CVE-2017-16997 - некорректная обработка переменных окружения RPATH и RUNPATH, содержащих $ORIGIN, может привести к загрузке в привилегированные исполняемые файлы (SUID или AT_SECURE) произвольных библиотек из текущей директории; CVE-2018-6485 - вызов функций posix_memalign и memalign со значением размера объекта близким к SIZE_MAX может привести к возврату указателя на буфер недостаточного размера, вместо возврата NULL.