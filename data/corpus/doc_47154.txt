Релиз набора компиляторов LLVM 5.0

После шести месяцев разработки представлен релиз проекта LLVM 5.0 (Low Level Virtual Machine) - GCC-совместимого инструментария (компиляторы, оптимизаторы и генераторы кода), компилирующего программы в промежуточный биткод RISC-подобных виртуальных инструкций (низкоуровневая виртуальная машина с многоуровневой системой оптимизации). Сгенерированный псевдокод может быть преобразован при помощи JIT-компилятора в машинные инструкции непосредственно в момент выполнения программы. Напомним, что в соответствии с новой нумерацией версий осуществлён уход от разделения значительных и функциональных выпусков. В каждом функциональном обновлении теперь меняется первая цифра (например, весной следующего года состоится релиз LLVM 6.0.0). Для обеспечения совместимости с существующими системами разбора номеров версий LLVM корректирующие обновления, как и раньше приводят к увеличению третьей цифры (5.0.1, 5.0.2, 5.0.3). Из новых возможностей LLVM 5.0 отмечается полная реализация стандарта C++17, поддержка сопрограмм в C++, реализация GNU-расширения для неявного скалярного преобразования в вектор, новые оптимизации и средства диагностики ошибок. Улучшения в Clang 5.0: Поддержка расширения для использования сопрограмм в коде на C++ (пример кода). Для включения следует использовать опции "-fcoroutines-ts -stdlib=libc++"; Обеспечена полная поддержка стандарта C++17. Для активации режима C++17 следует использовать флаг "-std=c++17" ("-std=c++1z" оставлен для обеспечения совместимости); Новые возможности для диагностики: "-Wcast-qual" для проверки корректности приведения типов в Си-стиле для C++; "-Wunused-lambda-capture" для выявления переменных, захваченных лямбда-выражением, но не используемых в теле лямбда-выражения; "-Wstrict-prototypes" для выявления не-прототипных функций, определений блоков и типов в Си и Objective-C; "-Wunguarded-availability" для информирования об использовании новых API, которые были представлены в системе, версия которой новее версии системы, заданной в качестве целевой. Также добавлен сокращённый вариант "-Wunguarded-availability-new", который охватывает проверку версий API, выпущенных после macOS 10.13, iOS 11, tvOS 11 и watchOS 4; "-Wdocumentation" - позволяет использовать в комментариях директивы \param и \returns для задания типа указателя для блока или функции; Добавлен новый флаг компилятора "--autocomplete" для вывода списка флагов и их аргументов для применения в системах автодополнения ввода; Объявлены устаревшими и игнорируются флаги "-fslp-vectorize-aggressive" (заменён нормальным векторизатором SLP) и "-fno-slp-vectorize-aggressive" (данное поведение теперь всегда используется по умолчанию); Добавлена новая pragma attribute для применения атрибута к нескольким декларациям; Для языков Си++ и Си реализовано GNU-расширение для неявного скалярного преобразования в вектор. Пример преобразования скалярного значения в вектор (ко всем элементам вектора "a" будет прибавлено 5): typedef unsigned v4i32 __attribute__((vector_size(16))); v4i32 foo(v4i32 a) { return a + 5; } Clang 5 станет последним выпуском, в котором по умолчанию используется режим "-std=gnu++98" при использовании совместимого с GCC драйвера clang++. Начиная со следующего выпуска будет применяться режим "-std=gnu++14" для совместимости с поведением новых выпусков GCC. Пользователям рекомендуется добавить в файлы сборки опции для явного определения используемой версии стандарта; Устранена порция ошибок в реализации OpenCL, расширен тестовый набор для OpenCL, расширена диагностика, в руководство добавлена документация по OpenCL. Обеспечена поддержка расширения cl_khr_subgroups и атрибута intel_reqd_sub_group_size. В CIndex добавлены типы OpenCL; В clang-format добавлена опция BreakBeforeInheritanceComma для подстановки разрывов после ":" и "," при определении класса. Опция включена по умолчанию при выборе стиля оформления кода Mozilla. Обеспечено выравнивание комментариев. Обеспечена автоматическая подстановка комменария с именем пространства имён в конце его определения; class MyClass : public X , public Y { }; /* line 1 * line 2 */ namespace A { int i; int j; } // namespace A В Libclang обеспечена поддержка автодополнения кода для следующих конструкций C++: static_assert, alignas, constexpr, final, noexcept, override и thread_local. Добавлено автодополнения для членов зависимых классов; В linter clang-tidy добавлена большая порция новых проверок, реализованы новые модули bugprone и hicpp; В статическом анализаторе добавлена поддержка автоматического доказателя теорем Z3, созданного в Microsoft Research для верификации кода своих продуктов. По сравнению с предлагаемым по умолчанию доказателем теорем Z3 работает примерно в 15 раз медленнее, но позволяет обрабатывать более сложные запросы. Для включения Z3 требуется сборка с опцией "CLANG_ANALYZER_BUILD_Z3=ON" и указание флагов "-Xanalyzer -analyzer-constraints=z3"; Расширены возможности компонента UBSan (Undefined Behavior Sanitizer) с реализацией детектора неопределенного поведения, выявляющего во время выполнения программы ситуации, когда поведение программы становится неопределенным: Добавлены и включены по умолчанию новые средства для проверки переполнения указателей (-fsanitize=pointer-overflow). Реализованы проверки для определения нарушения аннотаций о значениях NULL (-fsanitize=nullability) в аргументах функций, операциях присвоения и значениях return. Обеспечено определение некорректной загрузки из битовых полей (bitfields) и булевых наборов ObjC. В биндингах для языка Python обеспечена поддержка обеих веток - Python 2 и Python 3. Основные новшества LLVM 5.0: В компоновщике LLD решены многие проблемы с совместимостью, реализован более читаемый формат сообщений об ошибках, добавлена опция "-Map" для вывода схемы с сопоставлением входных файлов с результирующим файлом, значительно ускорена работа опции "--gdb-index ", добавлена поддержка нестандартных перестановок R_X86_64_8 и R_X86_64_16, по умолчанию обеспечено заполнение добавочных блоков в текстовых сегментах инструкцией INT3 вместо нулевых байтов. Добавлены новые опции: -compress-debug-sections, -emit-relocs, -error-unresolved-symbols, -exclude-libs, -filter, -no-dynamic-linker, -no-export-dynamic, -no-fatal-warnings, -print-map, -warn-unresolved-symbols, -z nocopyreloc, -z notext, -z rodynamic; В оптимизаторе циклов Polly, поддерживающем несколько техник оптимизации циклов и позволяющем организовать автоматическое распараллеливание кода с задействованием OpenMP, обеспечена поддержка компиляции всех компонентов платформы Android и пакета FFMPEG; Представлена новая библиотека BinaryFormat, в которую перемещены определения структуры file_magic и функций identify_magic, а также структур и определений для форматов DWARF, ELF, COFF, WASM и MachO; Утилита llvm-pdbdump переименована llvm-pdbutil, так как она уже давно переросла из программы для дампа содержимого PDB в полноценный инструмент диагностики и манипуляции содержимым PDB; Удалена стадия векторизации BBVectorize, на смену которой пришёл векторизатор SLP; Добавлена утилита opt-viewer.py для визуализации сведений о выполненных оптимизациях в формате HTML на основании YAML-отчёта, генерируемого опцией "-fsave-optimization-record"; Добавлен новый CMake-макрос LLVM_REVERSE_ITERATION; Добавлена утилита llvm-dlltool для создания коротких библиотек импорта из файлов с определениями в стиле GNU. Поддерживаются форматы импорта PE COFF SPEC Import Library и PE COFF Auxiliary Weak Externals; Для архитектуры x86 добавлена поддержка CPU Intel Goldmont, реализован планировщик для CPU AMD Ryzen (znver1), обеспечено более агрессивное развёртывание (inlining) вызовов memcmp. Добавлена поддержка инструкций AMD Lightweight Profiling (LWP), avx512vpopcntdq и инструкций AVX512 для ротации векторов. Добавлена возможность трассировки процессов и core-файлов NetBSD в одном потоке LLDB; В бэкенд AMDGPU добавлена поддержка архитектуры Radeon GFX9, используемой в GPU Vega; Внесены многочисленные улучшения в бэкенды для архитектур AArch64, ARM, AVR, MIPS и PowerPC, в том числе добавлена поддержка инструкций ARMv 8.1, 8.2 и 8.3, большой порции расширений POWER ISA 3.0, MIPS MT ASE и оптимизаций размера для microMIPS.