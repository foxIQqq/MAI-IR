Релиз набора компиляторов GCC 12

После года разработки опубликован релиз свободного набора компиляторов GCC 12.1, первый значительный выпуск в новой ветке GCC 12.x. В соответствии с новой схемой нумерации выпусков, версия 12.0 использовалась в процессе разработки, а незадолго до выхода GCC 12.1 уже ответвилась ветка GCC 13.0, на базе которой будет сформирован следующий значительный релиз GCC 13.1. 23 мая проект будет отмечать 35 лет с момента формирования первого выпуска GCC. Основные изменения: Добавлена поддержка отладочного формата CTF (Compact Type Format), обеспечивающего компактное хранение сведений о Си-типах, связях между функциями и отладочных символах. При встраивании в ELF-объекты формат позволяет использовать таблицы символов EFL для избежания дублирования данных. Объявлена устаревшей поддержка формата хранения отладочной информации "STABS", созданного в 1980-е годы. Продолжена работа по расширению поддержки будущих стандартов C2X и C++23 для языков C и C++. Например, добавлена поддержка выражения "if consteval"; разрешено использование auto в аргументах функций ("f(auto(g()))"); разрешено использование нелитеральных переменных, goto и меток в функциях, объявленных как constexpr; добавлена поддержка многомерный индексных операторов operator[]; в if, for и switch расширены возможности блоков инициализации ("for (using T = int; T e : v)"). В стандартной библиотеке C++ улучшена поддержка экспериментальных разделов стандартов C++20 и C++23. Добавлена поддержка std::move_only_function, <spanstream>, std::basic_string::resize_and_overwrite, <stacktrace>, <stdatomic.h> и std::invoke_r. Разрешено использование в constexpr-функциях std::unique_ptr, std::vector, std::basic_string, std::optional и std::variant. Во фронтэнде для языка фортран предоставлена полная поддержка спецификации TS 29113, описывающей возможности по обеспечению переносимости между кодом на языках Fortran и C. Добавлена поддержка расширения __builtin_shufflevector(vec1, vec2, index1, index2, ...), ранее добавленного в Clang и предлагающего единый вызов для выполнения общих векторных операций перестановки и перетасовки. При использовании уровня оптимизации "-O2" по умолчанию включено применение векторизации (включены режимы -ftree-vectorize и -fvect-cost-model=very-cheap). Модель "very-cheap" допускает векторизацию только если векторный код может полностью заменить векторизируемый скалярный код. Добавлен режим "-ftrivial-auto-var-init" включающий явную инициализацию переменных в стеке для отслеживания проблем и блокирования уязвимостей, связанных с использованием неинициализированных переменных. Для языков C и C++ добавлена встроенная функция __builtin_dynamic_object_size для определения размера объекта, совместимая с аналогичной функцией из Clang. Для языков C и C++ добавлена поддержка атрибута "unavailable" (например, можно помечать функции, при попытке использовании которых будет выводиться ошибка). Для языков C и C++ добавлена поддержка директив препроцессинга "#elifdef" и "#elifndef". Добавлен флаг "-Wbidi-chars" для вывода предупреждения в случае некорректного использования символов UTF-8, меняющих порядок отображения двунаправленного текста. Добавлен флаг "-Warray-compare" для вывода предупреждения при попытке сравнения двух операндов, ссылающихся на массивы. Продолжена реализация стандартов OpenMP 5.0 и 5.1 (Open Multi-Processing), определяющих API и способы применения методов параллельного программирования на многоядерных и гибридных (CPU+GPU/DSP) системах с общей памятью и блоками векторизации (SIMD). Улучшена реализация спецификации параллельного программирования OpenACC 2.6, определяющая средства для выноса операций (offloading) на GPU и специализированные процессоры, такие как NVIDIA PTX. В бэкенд генерации кода для архитектуры x86 добавлена поддержка расширенных инструкций Intel AVX512-FP16 и типа _Float16. Для архитектуры x86 добавлена защита от уязвимостей в процессорах, вызванных спекулятивным выполнением инструкций после операций безусловного прямого перехода. Проблема возникает из-за упреждающей обработки инструкций, следующих в памяти сразу за командой перехода (SLS, Straight Line Speculation). Для включения защиты предложена опция "-mharden-sls". В экспериментальный статический анализатор добавлено определение использования неинициализированных переменных. Добавлена начальная поддержка анализа ассемблерного кода в inline-вставках. Улучшено отслеживание состояния памяти. Переписан код для обработки выражений switch. Добавлено 30 новых вызовов в libgccjit, разделяемую библиотеку для встраивания генератора кода в другие процессы и использования для организации JIT-компиляции байткода в машинный код. В бэкенд для генерации байткода BPF добавлена поддержка механизма CO-RE (Compile Once - Run Everywhere), позволяющего собирать код eBPF-программ для ядра Linux только один раз и использовать специальный универсальный загрузчик, адаптирующий загружаемую программу к текущему ядру и типам BTF (BPF Type Format). CO-RE решает проблему с переносимостью скомпилированных eBPF-программ, которые ранее могли использоваться только в той версии ядра, для которой были собраны, так как позиция элементов в структурах данных меняется от версии к версии. В бэкенде для архитектуры RISC-V добавлена поддержка новых расширений архитектуры набора команд zba, zbb, zbc и zbs, а также ISA-расширений для векторных и скалярных криптографических операций. По умолчанию обеспечена поддержка спецификации RISC-V ISA 20191213. Добавлен флаг -mtune=thead-c906, включающий оптимизации для ядер T-HEAD c906. В бэкенд генерации кода для GPU AMD на базе микроархитектуры GCN добавлена поддержка типа __int128_t/integer(kind=16). Обеспечена возможность использования до 40 рабочих групп на вычислительный блок (CU) и до 16 фронтов инструкций (wavefront, набор нитей, параллельно выполняемых SIMD Engine) на группу. Ранее было разрешено использование только одного фронта инструкций на CU. В бэкенд NVPTX, предназначенный для генерации кода с использованием архитектуры набора команд NVIDIA PTX (Parallel Thread Execution), добавлена возможность использования флагов "-march", "-mptx" и "-march-map". Реализована поддержка PTX ISA sm_53, sm_70, sm_75 и sm_80. По умолчанию используется архитектура sm_30. В бэкенде для процессоров PowerPC / PowerPC64 / RS6000 переписаны реализации встроенных функций. Документированы встроенные функции__builtin_get_texasr, __builtin_get_texasru, __builtin_get_tfhar, __builtin_get_tfiar, __builtin_set_texasr, __builtin_set_texasru, __builtin_set_tfhar и __builtin_set_tfiar. В бэкенд для архитектуры ARM/AArch64 добавлена поддержка CPU Arm Ampere-1 (-mcpu/-mtune ampere1), Arm Cortex-A510 (cortex-a510), Arm Cortex-A710 (cortex-a710) и Arm Cortex-X2 (cortex-x2). Добавлена поддержка новых вариантов архитектуры ARMv8 для использования в опции "-march": armv8.7-a, armv8.8-a, armv9-a. Добавлена реализация встроенных в компилятор Си-функций (Intrinsics) для атомарной загрузки и сохранения данных в память, основанная на использовании расширенных инструкций ARM (ls64). Добавлена поддержка ускорения функций memcpy, memmove и memset при помощи ARM-расширения mopsoption. Добавлен новый режим проверки "-fsanitize=shadow-call-stack" (ShadowCallStack), который пока доступен только для архитектуры AArch64 и работает при сборке кода с опцией "-ffixed-r18". Режим обеспечивает защиту от перезаписи адреса возврата из функции в случае переполнения буфера в стеке. Суть защиты в сохранении после передачи управления функции адреса возврата в отдельном "теневом" стеке и извлечении данного адреса перед выходом из функции.