Релиз языка программирования PHP 8.0

После года разработки представлен релиз языка программирования PHP 8.0. Новая ветка включает серию новых возможностей, а также несколько изменений, нарушающих совместимость. Ключевые улучшения в PHP 8.0: Включение JIT-компилятора. PHP транслирует исходные тексты PHP-скриптов в промежуточное представление (байткод), которое затем выполняется в виртуальной машине Zend VM. JIT поможет дополнительно поднять производительность за счёт преобразования байткода в специфичный для текущей аппаратной платформы машинный код, который может напрямую исполняться процессором, минуя интерпретатор байткода в Zend VM. Выигрыш от использования JIT заметен при выполнении конструкций, для которых основное значение имеет производительность CPU, например, интенсивные математические вычисления или обработка в циклах данных, находящихся в оперативной памяти. В некоторых синтетических тестах применение JIT привело к повышению производительности в 2-3 раза. В отдельных вычислительных приложениях наблюдается рост производительности в 1.5–2 раза, но в типовых web-приложениях производительность не сильно отличается от PHP 7.4, так как узким местом является ввод/вывод. Поддержка именованных аргументов функций, позволяющих передававать в функцию значения в привязке к именам, т.е. можно передавать аргументы в произвольном порядке и определять необязательные аргументы. Например, "array_fill(start_index: 0, num: 100, value: 50)". При вызове методов разрешено применение оператора "?", который позволяет обойтись без отдельных условных проверок объектов на значение null. Если один из элементов в цепочке "?->" не может быть вычислен, выполнение цепочки прерывается и для всей цепочки возвращается значение null. Например, "$dateAsString = $booking->getStartDate()?->asDateTimeString()"; Поддержка union-типов, определяющих коллекции из двух и более типов (например "public function foo(Foo|Bar $input): int|float;"). Поддержка атрибутов (аннотаций), позволяющих привязать метаданные (например, сведения о типах) к классам без использования синтаксиса Docblock. Поддержка выражений match, которые в отличие от switch могут возвращать значения, поддерживают комбинирование условий, используют строгое сравнение типов и не требуют указания "break". $result = match($input) { 0 => "hello", '1', '2', '3' => "world", }; Сокращённый синтаксис определения классов, позволяющий объединить определение конструктора и свойств. Новый тип возвращаемых значений - static. Новый тип - mixed, который может применяться для определения приёма функцией параметров с разными типами. Выражение throw для обработки исключений. WeakMap для создания объектов, которыми можно пожертвовать при сборке мусора (например, для хранения необязательных кэшей). Возможность использования выражения "::class" для объектов (аналог вызова get_class()). Возможность определения в блоке catch исключений, не привязанных к переменным. Возможность оставления символа запятой после последнего элемента в списке параметров функции. Новый интерфейс Stringable для идентификации любых строковых типов или данных, которых можно преобразовать в строку (для которых доступен метод__toString()). Новая функция str_contains(), упрощённый аналог strpos для определения вхождения подстроки, а также функции str_starts_with() и str_ends_with() для проверки совпадений в начале и конце строки. Добавлена функция fdiv(), выполняющая операцию деления без вывода ошибки в случае деления на ноль. Изменена логика соединения строк. Например, выражение 'echo "sum: " . $a + $b' ранее интерпретировалось как 'echo ("sum: " . $a) + $b', а в PHP 8 будет обработано как 'echo "sum: " . ($a + $b)'. Ужесточена проверка арифметических и битовых операций, например, выражения "[] % [42]" и "$object + 4" будут приводить к ошибке. Реализован стабильный алгоритм сортировки, в котором при разных запусках сохраняется порядок следования одинаковых значений. Изменено поведение при сравнении строковых и числовых типов. Операция PHP 7.4 PHP 8.0 0 == "0" TRUE TRUE 0 == "0.0" TRUE TRUE 0 == "foo" TRUE FALSE 0 == "" TRUE FALSE 42 == " 42" TRUE TRUE 42 == "42foo" TRUE FALSE