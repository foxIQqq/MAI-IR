Выпуск компилятора языка D 2.100

Разработчики языка программирования D представили релиз основного эталонного компилятора DMD 2.100.0, который поддерживает системы GNU/Linux, Windows, macOS и FreeBSD. Код компилятора распространяется под свободной лицензией BSL (Boost Software License). Язык D использует статическую типизацию, обладает синтаксисом, схожим с C/C++, и обеспечивает производительность компилируемых языков, при этом заимствуя некоторые полезные возможности динамических языков в области эффективности разработки и обеспечения безопасности. Например, предоставляется поддержка ассоциативных массивов, косвенное определение типов, автоматическое управление памятью, средства параллельного программирования, опциональный сборщик мусора, система шаблонов, компоненты для метапрограммирования, возможность использовать библиотеки на языке C, а также некоторые библиотеки на C++ и Objective-C. Среди изменений в новом выпуске: Прекращена поддержка старого стиля перегрузки операторов, используемого в ветке D1. На смену opNeg, opAdd_r, opAddAssign и т.п. пришли opUnary, opBinary, opBinaryRight и opOpAssign. Старый стиль перегрузки операторов был объявлен устаревшим в 2019 году и начиная с выпуска 2.100 будет приводить к выводу ошибки. Прекращена поддержка ключевого слова delete, объявленного устаревшим, начиная с 2018 года. Вместо delete следует использовать функцию destroy или core.memory.__delete. Реализован новый атрибут @mustuse, который может быть применён к типам struct и union в качестве альтернативного метода обработки ошибок, когда в коде невозможно использовать исключения (например, в блоках @nogc). Если помеченное атрибутом @mustuse выражение не используется в коде, компилятор выведет ошибку. Для статических массивов разрешено применение свойства ".tupleof" для получения последовательности значений (lvalue) каждого элемента массива. void foo(int, int, int) { /* ... */ } int[3] ia = [1, 2, 3]; foo(ia.tupleof); // аналог foo(1, 2, 3); float[3] fa; fa.tupleof = ia.tupleof; // простое присвоение fa = ia приведёт к ошибке assert(fa == [1F, 2F, 3F]);