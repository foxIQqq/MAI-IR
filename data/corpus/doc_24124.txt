Подробности об использовании Linux ядра в Google

На проходившем в октябре саммите разработчиков Linux ядра сотрудником Google был сделан доклад о том, как Linux используется в этой компании. В Google поддерживается собственное ответвление от Linux ядра, на базе которого каждые 6 месяцев выпускается релизы для внутреннего использования, а раз в 17 месяцев производится синхронизация со стандартной "ванильной" веткой Linux ядра. Для управления кодом ядра применяется программное обеспечение Perforce. Над ядром работают около 30 инженеров, нередко имеющие слабое представление о том, что происходит с основным деревом, так как синхронизация производится только раз в полтора года. В будущем для совершенствования процесса управления кодом ядра и взаимодействия с независимым сообществом разработчиков в компании планируют перейти на использование Git. Ранее в Google использовалось ядро 2.4.18, в него было добавлено около 500 тыс. строк кода и бэкпортирована поддержка IPv6. Из-за необходимости качественной поддержки SATA было решено мигрировать на версию 2.6.11. В настоящее время базовым Linux ядром в Google является 2.6.18 и ведется подготовка к внедрению ядра, основанного на версии 2.6.26, в которое добавлено 1208 патчей насчитывающих 300 тыс. строк кода. Около 25% от объема патчей составляют бэкпортированные новые возможности, 3/4 всех изменений связаны с работой основных подсистем ядра и только незначительная доля изменений касается драйверов и поддержки оборудования. Для Google важнее планирование процессорного времени, т.к. компания запускает около 5000 потоков на системах с 16-32 ядрами. Инженеры компании портировали старый планировщик задач O(1) для запуска с использованием ядра 2.6.26. А для управления виртуальной памятью в указанных процессах применяется технология "Numa-Aware VFS LRU", которая ориентирована на конкретные узлы NUMA и призвана сделать работу с последними максимальной эффективной. Среди планов развития ядра Google на 2010 год: Организация приоритетного доступа к задачам, чувствительным к задержкам, с сохранением тех задач, которые требуются системе; RPC-aware CPU scheduling (проверка входящего RPC-трафика для определения того, какой процесс будет "просыпаться" в ответ и нужно ли ему это делать); Idle cycle injection (усовершенствование управления питанием с целью добавления возможности запуска машин на пороговых значениях, но не за их пределами); Усовершенствование подсистемы управления памятью, включая учет использования памяти ядром; Снижение накладных расходов системных вызовов для обеспечения кэширования в ядре и решение ряда других проблем.