Уязвимость в специфичном для CPU AMD коде KVM, позволяющая выполнить код вне гостевой системы

Исследователи из команды Google Project Zero выявили уязвимость (CVE-2021-29657) в поставляемом в составе ядра Linux гипервизоре KVM, позволяющую обойти изоляцию гостевой системы и выполнить свой код на стороне хост-окружения. Проблема присутствует в коде, используемом на системах с процессорами AMD (модуль kvm-amd.ko) и не проявляется для процессоров Intel. Исследователями подготовлен рабочий прототип эксплоита, позволяющий из гостевого окружения запустить root shell в хост-окружении на системе с процессором AMD Epyc 7351P и ядром Linux 5.10. Отмечается, что это первая брешь класса "guest-to-host" в самом гипервизоре KVM, не связанная с ошибками в компонентах, выполняемых в пространстве пользователя, таких как QEMU. Исправление было принято в ядро в конце марта. Проблема проявляется начиная с ядра Linux 5.10-rc1 и заканчивая v5.12-rc6, т.е. охватывает только ядра 5.10 и 5.11 (большинства стабильных веток дистрибутивов проблема не коснулась). Проблема присутствует в механизме nested_svm_vmrun, реализованном с использованием расширения AMD SVM (Secure Virtual Machine) и позволяющем организовать вложенный запуск гостевых систем. Для корректной реализации данной функциональности гипервизор должен перехватывать все инструкции SVM, выполняемые в гостевых системах, эмулировать их поведение и синхронизировать состояние с оборудованием, что является достаточно сложной задачей. Проанализировав предложенную в KVM реализацию, исследователи нашли логическую ошибку, позволяющую влиять на содержимое MSR-регистров (Model-Specific Register) хоста из гостевой системы, что можно использовать для запуска кода на уровне хоста. В частности, выполнение операции VMRUN из гостевой системы второго уровня вложенности (L2, запущенной из другой гостевой системы) приводит ко второму вызову nested_svm_vmrun и повреждению структуры svm->nested.hsave, на которую накладываются данные из vmcb гостевой системы L2. В итоге возникает ситуация, когда на уровне гостевой системы L2 можно освободить память в структуре svm->nested.msrpm, в которой хранится бит MSR, несмотря на то, что он продолжает использоваться, и получить доступ к MSR хост-окружения.