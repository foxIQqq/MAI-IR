Анализ влияния на производительность выбранного в системе источника времени

Брендан Грег (Brendan Gregg), один из разработчиков DTrace, ныне развивающий средства для анализа производительности на базе BPF в ядре Linux, обобщил опыт, полученный в ходе разбора проблем с производительностью, с которыми компания Netflix столкнулась в 2014 году при переводе СУБД Cassandra c CentOS на Ubuntu в окружениях, выполняемых в облаке Amazon EC2 на базе Xen. После миграции нагрузка на CPU увеличилась на 30% и примерно на столько же возросли задержки при выполнении операций записи. Как оказалось, производительность приложений, интенсивно запрашивающих информацию о времени, очень сильно зависит от выбранного в системе источника точного времени. Вначале причина снижения производительности была не очевидна и диагностика началась с отслеживания возможного влияния постоянно работающих или периодически запускаемых ресурсоёмких системных процессов при помощи утилит top и execsnoop. Но всё указывало на то, что потребление ресурсов увеличилось именно в СУБД Cassandra, написанной на языке Java. Сравнение показателей профилирования двух процессов Cassandra, параллельно запущенных в CentOS и Ubuntu и обрабатывающих одни и те же запросы, показало, что около 32% всего времени тратится на вызов os::javaTimeMillis(), используемый для получения информации о текущем времени. После этого был проведён эксперимент, в ходе которого было написано простое приложение на языке Java, в цикле вызывающее сто миллионов раз метод System.currentTimeMillis(). Запуск приложения показал, что в CentOS для его выполнения потребовалось 13 секунд, а в Ubuntu - около 68 секунд, т.е. в 5 раз медленнее. На языке Си была написана похожая программа, сто миллионов раз вызывающая функцию gettimeofday(), но при её выполнения были получены аналогичные результаты. Так как стало ясно, что источником проблемы является функция возврата текущего времени, внимание переключилось на изменение показателей при выборе в системе разных источников точного времени. Судя по содержимому "/sys/devices/system/clocksource/clocksource0/current_clocksource" по умолчанию при запуске Linux в гостевой системе использовался таймер "xen". После изменения источника времени на "tsc" время выполнения тестового приложения в Ubuntu уменьшилось с 68 до 3.3 секунд, т.е. стало быстрее в 20 раз. $ cat /sys/devices/system/clocksource/clocksource0/available_clocksource xen tsc hpet acpi_pm $ cat /sys/devices/system/clocksource/clocksource0/current_clocksource xen $ time java TimeBench real 1m8.300s user 0m38.337s sys 0m29.875s $ echo tsc > /sys/devices/system/clocksource/clocksource0/current_clocksource $ time java TimeBench real 0m3.370s user 0m3.353s sys 0m0.026s Для получения времени при выборе источника TSC используется процессорная инструкция RDTSC, выполнение которой не требует совершение системного вызова (инструкция не требует повышенных привилегий и выдаёт значение из встроенного в CPU счётчика времени). По умолчанию TSC не активируется так как в былые времена данный источник не исключал постепенный дрейф времени, который в других обработчиках корректируется программно для достижения более точных показаний. По мнению инженера, специализирующегося на разработке процессоров, опасения о сдвигах времени при использовании TSC уже давно не соответствуют действительности и в современных процессорах данный источник может годы выдавать стабильные показания. Перевод рабочих серверов в Netflix на источник TSC привёл к снижению задержек при записи на 43% и достижению при использовании Ubuntu результатов, превосходящих конфигурации с CentOS с источником времени "xen". Результаты проведённого исследования были переданы компании Amazon, которая официально рекомендовала в окружениях AWS EC2 на базе гипервизора Xen использовать по умолчанию источник времени TSC. В окружениях AWS EC2 на базе гипервизора Nitro остаётся рекомендован kvm-clock, но ранее проведённые тесты источника времени kvm-clock показывали снижение производительности на 20%, по сравнению с TSC.