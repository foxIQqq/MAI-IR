Компания Cisco предложила файловую систему PuzzleFS для ядра Linux

Компания Cisco предложила новую файловую систему PuzzleFS, реализованную в виде модуля для ядра Linux, написанного на языке Rust. ФС рассчитана на использование для размещения изолированных контейнеров и продолжает развитие идей, предложенных в ФС Atomfs. Реализация пока находится на стадии прототипа, поддерживает сборку с веткой ядра Linux rust-next и открыта под лицензиями Apache 2.0 и MIT. Проект нацелен на обход ограничений, возникающих при использовании образов контейнеров в формате OCI (Open Container Initiative). PuzzleFS решает такие задачи как эффективное хранение дублирующихся данных, возможность прямого монтирования, повторяемая сборка образов и безопасная работа с памятью. Для дедупликации повторяющихся в разных контейнерах данных задействован алгоритм FastCDC (Fast Content-Defined Chunking), работающий через разделение данных на фрагменты произвольного размера и ведение индекса с хэшами обработанных фрагментов. Повторяющиеся фрагменты хранятся один раз и совместно индексируются для всех слоёв ФС, т.е. дедупликация может охватывать разные точки монтирования (новый слой ФС может быть запущен на основе существующего и использовать, имеющиеся в нём фрагменты данных при дедупликации). Повторяющаяся сборка образов контейнеров достигается через определение канонического представления формата образов контейнеров. Прямое монтирование (direct-mount) позволяет монтировать образ контейнера в формате OCI из глобального совместно используемого хранилища без его предварительной распаковки и используя в качестве идентификатора хэш содержимого из манифеста контейнера. Для верификации целостности данных в условиях применения общего хранилища может применяться механизм fs-verity, который при обращении к файлам проверяет соответствие указанных в бинарном индексе хэшей с фактическим содержимым. Язык Rust выбран как сочетающий высокую производительность результирующего кода с возможностями для безопасной работы с памятью, что позволяет снизить риск появления уязвимостей, вызванных такими проблемами как обращение к области памяти после её освобождения и выход за границы буфера. Применение Rust для модуля ядра также позволило совместно использовать код в ядре и компонентах, работающих в пространстве пользователя, для создания единой защищённой реализации. Среди других целей проекта: очень быстрая сборка и монтирование образов, возможность использования необязательной промежуточной стадии для преобразования (canonicalization) образов, необязательность полных проходов по дереву ФС в стиле mtree при использовании многослойной структуры, наложение изменений в стиле casync и простая в реализации архитектура.