Утверждён стандарт ECMAScript 6

На очередном собрании Генеральной Ассамблеи ECMA официально утверждён стандарт ECMAScript 2015 (PDF), более известный как ECMAScript 6 или "ECMA-262 6th edition". ECMAScript 6 продолжает линейку стандартов, определяющих базовые функциональные возможности JavaScript, реализованные для всех web-браузеров. Прошлый стандарт ECMAScript 5 был принят в 2009 году, а позапрошлый в 1999 году. Долгое время развитие стандарта было заморожено из-за трудноразрешимых разногласий среди производителей браузеров, одни из которых выступали за внесение значительных изменений в JavaScript, а другие настаивали на сохранении полной семантической совместимости. Основные нововведения ECMAScript 6: Поддержка классов. Например: class Polygon { constructor(height, width) { this.name = 'Polygon'; this.height = height; this.width = width; } sayName() { log('Hi, I am a ', this.name + '.'); } } let p = new Polygon(300, 400); Шаблоны строк, предоставляющие удобные средства для форматирования строк. Шаблоны строк являются строковыми литералами, допускающими встраивание выражений. Выражения определяются в размещённом внутри строки блоке ${...}, который может включать как отдельные переменные (${name}), так и выражения (${5 + a + b})). Например, в результате выполнения "var message = '1 + 1 = ${1 + 1}'" в переменную будет записана строка "1 + 1 = 2"; Поддержка лексических объявлений переменных (Lexical Declarations), позволяющих ограничить текущим блоком область видимости ключевых слов, через их повторное определение при помощи оператора let вместо var. Оператор const для определения переменных, доступных только для чтения; Модули. Для экспорта и импорта модулей введены операторы export и import, например, "import * as mymodule from "lib/mymodule". Предоставляются средства динамической загрузки модулей, пространства имён и изоляция состояния. Arrow-функции позволяющие использовать синтаксис "=>" для быстрого определения анонимных функций (например, "x.map(x => console.log(x * x));") и ключевое слово "this" для доступа к текущему лексическому контексту функции; Сокращённый формат задания объектов (например, "var a = {obj1, obj2}" вместо "var a = {'obj1': obj1, 'obj2': obj2}"); Тип Symbol, применимый для идентификаторов свойств объектов; Генераторы, позволяющие организовать эффективное выполнение функций в асинхронном режиме. Генераторы представляют собой специальные функции, генерирующие итераторы. Использование выражения yield для генератора, позволяет приостановить его выполнение и вернуть управление вызвавшей генератор функции. Особенность генераторов состоит в том, что последующие вызовы будут использовать предыдущее состояние и продолжат выполнение кода генератора с того места, где он был приостановлен. Объект WeakSet, позволяющий определить множество из объектов, и объект WeakMap, определяет коллекцию пар ключ/значение в которых ключ является объектом, к которому может быть прикреплено произвольное значение. WeakSet и WeakMap отличаются использованием эффективных с точки зрения потребления памяти структур, использующих сборщик мусора для удаления неиспользуемых объектов (объект удаляется, если на него больше не осталось ссылок, кроме ссылки из текущей коллекции) и предотвращающих возникновение утечек памяти; Механизм Promise, предназначенный для получения значений в асинхронном режиме. Позволяет определить значение, которое пока неизвестно, но будут определено через какое-то время; Возможность определения значений по умолчанию для аргументов функций (например, "function myfunc(a='test', b=1)"); Возможность передачи в функцию произвольной группы параметров в форме массива (например, "function myfunc(a, b, ...c)"); Новая форма слияния массивов (например, "var a= [3,4]; var b = [1,2,...a])"; Cтруктуры данных Map и Set, упрощающих работу со специфичными типами коллекций. Map позволяет определять коллекции наборов в формате ключ/значение, при том, что в качестве ключа и значения могут выступать любые выражения JavaScript. По аналогии Set позволяет задать множество любых выражений JavaScript; Поддержка абстракции массивов (Array comprehensions), дающих возможность создания нового массива на основе другого массива; Большая порция новых методов для строк, массивов и математических операций, в том числе Array.from(), Array.prototype.keys, Array.prototype.entries, Array.prototype.copyWithin(), Number.isSafeInteger(), Math.fround(), Math.ToFloat32(), startsWith(), endsWith(), contains(), clear() и Math.imul;