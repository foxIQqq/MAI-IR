Выпуск языка программирования Rust 1.42

Опубликован релиз языка системного программирования Rust 1.42, основанного проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime. Автоматическое управление памятью в Rust избавляет разработчика от манипулирования указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo, позволяющий получить нужные для программы библиотеки в один клик. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Добавлена поддержка шаблонов для сопоставления частей срезов (динамических массивов, slice). Если раньше допускались точные сопоставления, то теперь добавлена возможность использования конструкций с меткой ".." для охвата остающихся элементов массива. Например: fn foo(words: &[&str]) { match words { // проверяет начальные элементы массива с игнорированием следующих за ними элементов ["Hello", "World", "!", ..] => println!("Hello World!"), // проверяет первые два элемента "Foo" и "Bar", а остальное не важно ["Foo", "Bar", ..] => println!("Baz"), // игнорируем всё, но последний элемент должен быть "!". [.., "!"] => println!("!!!"), // в срез start включаем всё, кроме последнего элемента, который должен быть "z" [start @ .., "z"] => println!("starts with: {:?}", start), // в срез end помещаем всё, кроме первого элемента, который должен быть "a". ["a", end @ ..] => println!("ends with: {:?}", end), rest => println!("{:?}", rest), } } Добавлен новый макрос "matches!", который принимает на входе выражение и шаблон, а возвращает "true", если шаблон соответствует выражению. В шаблоне возможно использование операций "|" и "if". match self.partial_cmp(other) { Some(Less) => true, _ => false, } matches!(self.partial_cmp(other), Some(Less)) let foo = 'f'; assert!(matches!(foo, 'A'..='Z' | 'a'..='z')); let bar = Some(4); assert!(matches!(bar, Some(x) if x > 2)); В panic-сообщениях, выводимых при некорректном использовании типов Option и Result, теперь отражаются номера строк со ссылкой на код, осуществивший проблемный вызов, а не ссылки на код реализации вызова в libcore. Например, изменение затрагивает вызов unwrap и expect над Option::None или сбои при использовании unwrap_err, expect, expect_err и подобных методов для типа Result. В пакетном менеджере Cargo обеспечена автоматическая подстановка "proc_macro crate" в блок "extern" для пакетов с процедурными макросами. Данное изменение позволяет применять директиву "use" к процедурным макросам без необходимости указания в коде "extern crate proc_macro;". Например, если в программе используется строка "use proc_macro::TokenStream;", то код теперь останется рабочим, если из него удалить "extern crate proc_macro;". Расширены возможности стандартной библиотеки. В iter::Empty<T> добавлена поддержка Send и Sync для любых значений T. Вызовы Pin::{map_unchecked, map_unchecked_mut} избавлены от необходимости возвращать значение типа для реализации "Sized". В io::Cursor реализованы PartialEq и Eq. Признак "const", определяющий возможность использования в любом контексте вместо констант, применён для метода Layout::new. В разряд стабильных переведена новая порция API, в том числе стабилизированы CondVar::wait_while, CondVar::wait_timeout_while, DebugMap::key, DebugMap::value, ManuallyDrop::take, ptr::slice_from_raw_parts_mut и ptr::slice_from_raw_parts. Объявлен устаревшим метод Error::description. Обеспечен в второй уровень поддержи для платформ armv7a-none-eabi и riscv64gc-unknown-linux-gnu. Обеспечена поддержка стандартной библиотеки для платформы riscv64gc-unknown-linux-gnu. 32-разрядные платформы Apple понижены до третьего уровня поддержки, который подразумевает базовую поддержку, но без автоматизированного тестирования и публикации официальных сборок. Понижение уровня поддержки обусловлено прекращением сопровождения компанией Apple 32-разрядных платформ.