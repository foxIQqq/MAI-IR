Выпуск сборочной системы Meson 0.50

Представлен релиз сборочной системы Meson 0.50, которая используется для сборки таких проектов, как X.Org Server, Mesa, Lighttpd, systemd, GStreamer, Wayland, GNOME и GTK+. Код Meson написан на языке Python и поставляется под лицензией Apache 2.0. Ключевой целью развития Meson является обеспечение высокой скорости сборочного процесса в сочетании с удобством и простотой использования. Вместо утилиты make при сборке по умолчанию применяется инструментарий Ninja, но возможно применение и других бэкендов, таких как xcode и VisualStudio. В систему встроен многоплатформенный обработчик зависимостей, позволяющий использовать Meson для сборки пакетов для дистрибутивов. Правила сборки задаются на упрощённом предметно-ориентированном языке, отличаются хорошей читаемостью и понятны пользователю (по задумке авторов разработчик должен тратить минимум времени на написание правил). Например, простейший файл сборки (meson.build) будет выглядеть как: project('tutorial', 'c') executable('demo', 'main.c') или более сложный вариант с зависимостью от GTK3: project('tutorial', 'c') gtkdep = dependency('gtk+-3.0') executable('demo', 'main.c', dependencies : gtkdep) Поддерживается кросс-компиляция и сборка в Linux, macOS и Windows с использованием GCC, Clang, Visual Studio и других компиляторов. Возможна сборка проектов на различных языках программирования, включая C, C++, Fortran, Java и Rust. Поддерживается инкрементальный режим сборки, при котором пересобираются только компоненты, напрямую связанные с изменениями, внесёнными с момента прошлой сборки. Meson можно использовать для формирования повторяемых сборок, при которых запуск сборки в разных окружениях приводит к генерации полностью идентичных исполняемых файлов. Основные новшества Meson 0.50: Добавлена поддержка развиваемых компанией NVIDIA компиляторов PGI для языков C, C++ и Fortran, а также компилятора Flang; Добавлена поддержка расширения coarray для параллельного программирования на языке Fortran, стандартизированного в спецификациях Fortran 2008 и Fortran 2018. В коде для разбора зависимостей также представлена начальная поддержка субмодулей для Fortran, определяемых при помощи выражения "submodule"; Обеспечена возможность указания пути к каталогу с модулями для системы CMake в составе зависимостей. Бэкенд для определения зависимостей через CMake теперь может использовать существующие файлы Find{name}.cmake через указание свойства make_module_path в dependency(). Также добавлена поддержка передачи CMake дополнительных параметров при помощи опции cmake_args; Значение libdir при кросс-компиляции теперь указывает на каталог "/lib", а не на специфичные для выбранной архитектуры пути (например "lib/x86_64-linux-gnu"); В сборочные файлы добавлена новая секция "[paths]" для определения постоянных путей, таких как prefix и libdir; Добавлен режим "warning_level 0" для отключения в компиляторе любых проверок, связанных со статическим анализом кода; Добавлена встроенная сборочная цель (ninja clang-format) для форматирования кода при помощи clang-format; Реализована возможность указания в ключевом слове include_directories строковых значений, а не только объектов, ссылающихся на каталоги; Для языков C, C++ и Fortran добавлена поддержка обработчиков формата для обмена научными данными NetCDF через вызов pkg-config; Добавлена поддержка формата HDF5 через вызов pkg-config; Добавлена поддержка компиляции кода NVIDIA CUDA (пока только при помощи бэкенда на базе Ninja). Так как компилятор CUDA не сохраняет файлы с зависимостями (*.d), отслеживание зависимостей не поддерживается; Расширены возможности интроспекции. Обеспечена генерация файла meson-info.json при каждом запуске meson. Добавлена поддержка инроспектирования разом нескольких параметров. Реализована возможность выполнения "introspect --targets" и "introspect --buildoptions" без настроенного сборочного каталога. Добавлена команда "introspect --scan-dependencies" для поиска зависимостей в проекте; Добавлена функциональность для изменения файлов meson.build при выполнении операций в командной строке. Например, можно добавлять и исключать исходные файлы и сборочные цели (target), изменять наборы kwargs и модифицировать применяемые по умолчанию сборочные опции.