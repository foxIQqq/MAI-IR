Основан Xfce Classic, форк Xfce без декорирования окон на стороне клиента

Шон Анастаси (Shawn Anastasio), энтузиаст свободного ПО, в своё время разрабатывавший собственную операционную систему ShawnOS и занимавшийся портировнием Chromium и Qubes OS на архитектуру ppc64le, основал проект Xfce Classic, в рамках которого намерен развивать форки компонентов пользовательского окружения Xfce, работающие без применения декорирования окон на стороне клиента (CSD, client-side decorations), при котором заголовок и рамки окна отрисовываются не оконным менеджером, а самим приложением. Напомним, что при подготовке следующего выпуска Xfce 4.16, релиз которого ожидается в октябре или ноябре, осуществлён перевод интерфейса на виджет GtkHeaderBar и применение CSD, что дало возможность по аналогии с GNOME добиться размещения меню, кнопок и других элементов интерфейса в заголовке окна, а также обеспечить скрытие рамок в диалогах. Новый механизм отрисовки интерфейса интегрирован в библиотеку libxfce4ui, что привело к автоматическому применению CSD для почти всех диалогов, без необходимости внесения изменений в код существующих проектов. У перехода на CSD нашлись противники, которые считают, что поддержка CSD должна быть опциональной и пользователь должен иметь возможность продолжить использование классических заголовков окон. Из недостатков применения CSD упоминается слишком массивная область заголовка окна, отсутствие потребности переносить элементы приложения в заголовок окна, неработоспособность тем оформления Xfwm4 и разнобой в оформлении окон приложений Xfce/GNOME и программ, не использующих CSD. Отмечается, что одной из причин неприятия интерфейса GNOME некоторыми пользователями является применение CSD. Так как за 5 месяцев не было предпринято попыток предоставить поддержку отключения CSD, Шон Анастаси решил взять данный вопрос в свои руки и создал форк библиотеки libxfce4ui, в котором провёл чистку привязки к CSD и вернул старый режим декорирования на стороне сервера (оконного менеджера). Для обеспечения совместимости с приложениями, использующими новый API libxfce4ui, и сохранения ABI, подготовлены специальные обвязки, транслирующие специфичные CSD-методы класса XfceTitledDialog в вызовы класса GtkDialog. В итоге предоставлена возможность избавления приложений Xfce от CSD путём замены библиотеки libxfce4ui, без изменения кода самих приложений. Дополнительно сформирован форк панели xfce4-panel, включающей изменения для возвращения классического поведения. Для пользователей Gentoo подготовлен overlay для установки libxfce4ui-nocsd. Для пользователей Xubuntu/Ubuntu подготовлен PPA-репозиторий с готовыми пакетами. Мотивы создания форка Шон Анастаси пояснил тем, что он уже много лет использует Xfce и ему нравится интерфейс данного окружения. После принятия решения по изменению интерфейса, с которыми он был несогласен, и отсутствию попыток предоставить опцию для возвращения старого поведения, было решено самостоятельно решить свою проблему и поделиться решением с другими людьми, разделяющими его точку зрения. Из проблем при использовании Xfce Classic отмечается возникновение впечатления дублирования заголовков из-за отображения повторяющейся информации в заголовке и в окне приложения. Данная особенность соответствует поведению Xfce 4.12 и 4.14, и не связана с CSD. В одних приложениях подобное дублирование выглядит нормально (например, в xfce4-screenshooter), но в других явно неуместно. Для решения данной проблемы не исключается добавление переменной окружения, регулирующей отрисовку XfceHeading. Позиция сторонников CSD сводится к возможности задействовать пропадающее впустую пространство заголовка окна для размещения меню, кнопок панели и других значимых элементов интерфейса. Противники CSD считают, что при данном подходе возникают проблемы с унификацией оформления окон, особенно написанных для разных пользовательских окружений, определяющих разные рекомендации по компоновке заголовочной области. Оформление окон всех приложений гораздо проще привести к единому стилю при классической отрисовке служебных областей окна на стороне сервера. В случае применения CSD требуется отдельно адаптировать интерфейс приложения к каждому графическому окружению и достаточно трудно добиться того, чтобы приложение не выглядело чужеродно в разных пользовательских окружениях.