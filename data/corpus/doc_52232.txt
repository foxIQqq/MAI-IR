Доступен GameMode 1.5, оптимизатор производительности игр в Linux

Компания Feral Interactive опубликовала выпуск оптимизатора GameMode 1.5, реализованного в виде фонового процесса, на лету изменяющего различные системные настройки Linux для достижения максимальной производительности игровых приложений. Код проекта написан на языке Си и поставляется под лицензией BSD. Для игр предлагается использовать специальную библиотеку libgamemode, которая позволяет на время выполнения игры запрашивать включение определённых оптимизаций, не применяемых по умолчанию в системе. Доступен также вариант библиотеки для запуска игры в режиме автоматической оптимизации (загрузка libgamemodeauto.so через LD_PRELOAD при запуске игры), без необходимости внесения изменений в код игры. Включение тех или иных оптимизаций можно контролировать через файл конфигурации. Например, при помощи GameMode могут отключаться режимы энергосбережения, меняться параметры распределения ресурсов и планировки задач (CPU governor и SCHED_ISO), перестраиваться приоритеты ввода/вывода, блокироваться запуск хранителя экрана, включаться различные режимы повышенной производительности в GPU NVIDIA и AMD, выполняться разгон GPU NVIDIA (overclocking), запускаться скрипты с определёнными пользователем оптимизациями. В выпуске 1.5 добавлена возможность динамической смены регулятора режимов CPU (CPU governor) для процессоров Intel со встроенным GPU, если использование режима "performance" приводит к проседанию производительности графической подсистемы при высокой нагрузке на GPU. В этом случае переход на режим "powersave" позволяет снизить энергозатраты CPU и высвободить больше ресурсов GPU (CPU и GPU предоставлен совместный бюджет питания и приоритетное выделение ресурсов CPU приводит к урезанию частоты GPU). На CPU i7-1065G7 предложенная оптимизация позволяет поднять производительность игры Shadow of the Tomb Raider на 25-30%. В GameMode 1.5 также представлен новый набор D-Bus API, применяющий механизм 'pidfd' для обработки ситуации с повторным использованием PID (pidfd связывается с конкретным процессом и не меняется, в том время как PID может быть привязан к другому процессу после завершения текущего процесса, ассоциированного с этим PID).