Выпуск Java SE 20

После шести месяцев разработки компания Oracle выпустила платформу Java SE 20 (Java Platform, Standard Edition 20), в качестве эталонной реализации которой используется открытый проект OpenJDK. За исключением удаления некоторых устаревших возможностей в Java SE 20 сохранена обратная совместимость с прошлыми выпусками платформы Java - большинство ранее написанных Java-проектов без изменений будут работоспособны при запуске под управлением новой версии. Готовые для установки сборки Java SE 20 (JDK, JRE и Server JRE) подготовлены для Linux (x86_64, AArch64), Windows (x86_64) и macOS (x86_64, AArch64). Разработанная в рамках проекта OpenJDK эталонная реализация Java 20 полностью открыта под лицензией GPLv2 с исключениями GNU ClassPath, разрешающими динамическое связывание с коммерческими продуктами. Java SE 20 отнесён к категории выпусков с обычным сроком поддержки, обновления для которого будут выпускаться до следующего релиза. В качестве ветки с длительным сроком поддержки (LTS) следует использовать Java SE 17, обновления для которого будут выпускаться до 2029 года. Напомним, что начиная с выпуска Java 10 проект перешёл на новый процесс разработки, подразумевающий более короткий цикл формирования новых релизов. Новая функциональность теперь развивается в одной постоянно обновляемой master-ветке, в которую включаются уже готовые изменения и от которой раз в шесть месяцев ответвляются ветки для стабилизации новых выпусков. Из новшеств Java 20 можно отметить: Предложена предварительная поддержка ограниченных значений (Scoped Values), позволяющих совместно использовать неизменяемые данные в потоках и эффективно обмениваться данными между дочерними потоками (значения наследуются). Scoped Values развиваются для замены механизма переменных локальных к потоку (thread-local variables) и более эффективны при использовании очень большого числа виртуальных потоков (тысячи и миллионы потоков). Главное отличие Scoped Values от переменных локальных к потоку в том, что первые записываются один раз, в дальнейшем не могут быть изменены и остаются доступны только на время выполнения потока. class Server { final static ScopedValue CURRENT_USER = new ScopedValue<>(); void serve(Request request, Response response) { var level = (request. isAuthorized()? ADMIN : GUEST); var user = new User(level); ScopedValue.where(CURRENT_USER, user) .run(() -> Application.handle(request, response)); } } class DatabaseManager { DBConnection open() { var user = Server.CURRENT_USER.get(); if (!user.canOpen()) throw new InvalidUserException(); return new DBConnection(...); } } Добавлена вторая предварительная реализация шаблонов записей (record pattern), расширяющая появившуюся в Java 16 возможность сопоставления с образцом средствами для разбора значений классов типа record. Например: record Point(int x, int y) {} static void printSum(Object obj) { if (obj instanceof Point p) { int x = p.x(); int y = p.y(); System.out.println(x+y); } } Добавлена четвёртая предварительная реализация сопоставления по шаблону в выражениях "switch", позволяющая в метках "case" использовать не точные значения, а гибкие шаблоны, охватывающие сразу серию значений, для которых ранее приходилось использовать громоздкие цепочки выражений "if...else". static String formatterPatternSwitch(Object obj) { return switch (obj) { case Integer i -> String.format("int %d", i); case Long l -> String.format("long %d", l); case Double d -> String.format("double %f", d); case String s -> String.format("String %s", s); default -> o.toString(); }; } Добавлена вторая предварительная реализация API FFM (Foreign Function & Memory), позволяющего организовать взаимодействие Java-программ с внешними кодом и данными через вызов функций из внешних библиотек и доступ к памяти вне JVM. Добавлена вторая предварительная реализация виртуальных потоков, представляющих собой легковесные потоки, значительно упрощающие написание и сопровождение высокопроизводительных многопоточных приложений. Добавлен второй вариант экспериментального API для cтруктурированного параллелизма, упрощающего разработку многопоточных приложений за счёт обработки нескольких задач, выполняемых в разных потоках, как единого блока. Добавлена пятая предварительная реализация API Vector, предоставляющего функции для векторных вычислений, которые выполняются с использованием векторных инструкций процессоров x86_64 и AArch64 и позволяют одновременно применить операции сразу к нескольким значениям (SIMD). В отличие от предоставляемых в JIT-компиляторе HotSpot возможностей по автовекторизации скалярных операций, новый API даёт возможность явно управлять векторизацией для параллельной обработки данных. Дополнение: Опубликовано обновление платформы для создания приложений с графическим интерфейсом JavaFX 20.