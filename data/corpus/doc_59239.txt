Опубликован стандарт SQL:2023

Международная организация по стандартизации (ISO) утвердила и опубликовала международный стандарт SQL:2023 (ISO/IEC 9075), который определяет девятую редакцию спецификации языка SQL, применяемого для манипуляции данными в реляционных СУБД. Прошлое обновление спецификации было выпущено в 2016 году (SQL:2016). Основные изменения в новой спецификации: Добавлено расширение SQL/PGQ (Property Graph Queries) для манипуляции наборами связанных между собой данных, образующих граф. CREATE TABLE person (...); CREATE TABLE company (...); CREATE TABLE ownerof (...); CREATE TABLE transaction (...); CREATE TABLE account (...); CREATE PROPERTY GRAPH financial_transactions VERTEX TABLES (person, company, account) EDGE TABLES (ownerof, transaction); SELECT owner_name, SUM(amount) AS total_transacted FROM financial_transactions GRAPH_TABLE ( MATCH (p:person WHERE p.name = 'Alice') -[:ownerof]-> (:account) -[t:transaction]- (:account) <-[:ownerof]- (owner:person|company) COLUMNS (owner.name AS owner_name, t.amount AS amount) ) AS ft GROUP BY owner_name; Определена возможность настройки поведения обработки значений NULL при наличии ограничителя "UNIQUE". При указании "UNIQUE NULLS DISTINCT", добавляемые в базу значения NULL будут трактоваться как уникальные. Например, в таблице с условием "UNIQUE NULLS DISTINCT (a, b, c)" можно выполнить несколько операций "INSERT INTO t2 VALUES (1, NULL, NULL);", а в таблице с условием "UNIQUE NULLS NOT DISTINCT (a, b, c)" - нет. Расширены возможности выполнение операции "ORDER BY" над сгруппированными таблицами. В спецификации теперь разрешены операции упорядочивания сгруппированных таблиц по столбцу, не упомянутому в списке вывода SELECT сгруппированной таблицы. Ранее большинство СУБД позволяло делать такие манипуляции, но спецификация не определяла подобную возможность. Например: SELECT product.product_id, sum(product_part.num) FROM product JOIN product_part ON product.product_id = product_part.product_id GROUP BY product.product_id ORDER BY product.product_code; Добавлены новые функции GREATEST и LEAST, выбирающие наибольшее и наименьшее значение из переданного списка. Например: SELECT greatest(1, 2, 3); --> 3 SELECT least(1, 2, 3); --> 1 SELECT least(standard, discount) FROM data ... Добавлены новые функции LPAD и RPAD для дополнения строки до определённого размера. Например: SELECT lpad(cast(amount as varchar), 12, '-') FROM ... ----12345.67 Добавлены многосимвольные варианты функции TRIM - LTRIM, RTRIM и BTRIM, которые позволяют вырезать из начала или конца строки символы, указанные в списке. По сравнению с TRIM новые функции имеют более простой синтаксис. Например: SELECT ltrim('cccbtest', 'abc'); --> test SELECT trim(leading 'abc' from 'cccbtest'); Для типов "VARCHAR" и "CHARACTER VARYING" разрешено не указывать максимальный размер, в этом случае максимальный размер будет зависеть от реализации СУБД. CREATE TABLE t1 ( a VARCHAR(256), b VARCHAR, ... ); Расширены возможности по выявлению циклов в рекурсивных запросах, используя выражение "CYCLE". Поле с маркером цикла теперь может иметь тип "boolean", а не строковый, и передавать признак цикла в форме значений true и false. Например: WITH RECURSIVE ... ( SELECT ... UNION ALL SELECT ... ) CYCLE id SET is_cycle USING path; -- вместо CYCLE id SET is_cycle TO 'Y' DEFAULT 'N' USING path; Добавлена новая агрегатная функция any_value(), которая из входного набора данных возвращает произвольное значение, не являющееся NULL. CREATE TABLE t1 ( a int, b int ); INSERT INTO t1 VALUES (1, 11), (1, 22), (1, 33); SELECT a, any_value(b) FROM t1 GROUP BY a; в зависимости от вызова вернёт "1 | 11", "1 | 22" или "1 | 33". Добавлена возможность указания шестнадцатеричных, двоичных и восьмеричных литералов. Например: SELECT 0xFFFF, 0o755, 0b11001111 ... Разрешено использование в числе символа подчёркивания для повышения наглядности цифровых литералов. SELECT ... WHERE a > 1_000_000; UPDATE ... SET x = 0x_FFFF_FFFF ... Значительно расширены возможности, связанные с обработкой данных в формате JSON. Добавлен отдельный тип JSON (в стандарте SQL:2016 данные JSON предписывалось хранить в полях со строковыми типами). В данных с типом JSON можно проверять уникальность, используя "JSON('...text...' WITH UNIQUE KEYS)". Тип JSON также может сравниваться, сортироваться и использоваться в операциях группировки. Предложенные в прошлом стандарте функции JSON_OBJECT, JSON_OBJECTAGG, JSON_TABLE и т.п. могут работать как со старым строковым представлением, так и с отдельными типом JSON. Реализована поддержка операций JSON_SERIALIZE, JSON_SCALAR и IS JSON. Предоставлен упрощённый синтаксис доступа к наборами вида '{"foo": {"bar": [100, 200, 300]}, ...}' из SQL ("SELECT t.j.foo.bar[2], ... FROM tbl t ..."). Добавлено 14 новых методов для применения к значениям SQL/JSON внутри языка SQL/JSON. В СУБД PostgreSQL большая часть предложенных в SQL:2023 новшеств уже доступна или запланирована для включения в следующий значительный выпуск. Поддержка ANY_VALUE, подчёркиваний в числах, шестнадцатеричных/двоичных/восьмеричных литералов и шестнадцатеричных литералов в SQL/JSON появится в осеннем выпуске PostgreSQL. Поддержка расширенных возможностей для типа JSON, упрощённого синтаксиса SQL/JSON, новых JSON-методов и расширения PGQ ожидается в выпусках после PostreSQL 16, но работа в этих областях пока не началась. Остальные новшества SQL:2023 уже доступны в существующих выпусках PostreSQL.