Для Linux представлен TIER, блочное устройство для агрегирования накопителей

Марк Райтер (Mark Ruijter), автор работающей в пространстве пользователя файловой системы LessFS с автоматической дедупликацией, master/slave-репликацией, сжатием и шифрованием данных, представил для ядра Linux модуль TIER, позволяющий сформировать многоуровневое блочное устройство из нескольких устройств небольшого размера, обеспечивающее высокую производительность за счёт оптимального разнесения блоков по дискам и использования техники активного кэширования данных в ОЗУ. От других систем виртуального слияния хранилищ TIER отличается поддержкой автоматической миграции данных между накопителями и обеспечением "умной" балансировки размещения блоков данных на накопителях в зависимости от характера нагрузки. Первая реализация TIER поддерживает агрегацию в виде одного виртуального диска до 16 SSD, SAS или SATA-накопителей. Код проекта распространяется под лицензией GPL. Использование TIER позволяет достигнуть более высокой производительности, чем при применении только SSD за счёт использования техники кэширования в оперативной памяти, ранее реализованной в RAM-диске EPRD. При распределении данных по дискам TIER учитывает статистику доступа к уже размещённым данным, например, принимает во внимание то, когда данные использовались последний раз и как часто они запрашиваются. При наличии разных типов накопителей в пуле, отличающихся скоростными характеристиками, наиболее востребованные данные будут вытеснены на более быстрые накопители, такие как SSD или SAS, а редко используемые данные будут размещены на медленных дисках. В отличие от кэширования с использованием только SSD-дисков, TIER позволяет значительно сэкономить, используя SSD только для действительно востребованных данных, при том что общая ёмкость всего быстрого хранилища в TIER составляет сумму из всех подключенных устройств хранения. Например, близкий аналог flashcache может поддерживать отдельный кэш из SSD-накопителей поверх традиционных дисков, дублируя данные, в то время как TIER максимально эффективно использует доступное пространство.