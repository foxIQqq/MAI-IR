Выпуск языка программирования Rust 1.63

Опубликован релиз языка программирования общего назначения Rust 1.63, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Методы работы с памятью в Rust избавляют разработчика от ошибок при манипулировании указателями и защищают от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами, учёт времени жизни объектов (области видимости) и оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок. Основные новшества: Добавлен API std::thread::scope, позволяющий создавать потоки в привязке к области видимости (Scoped threads). В отличие от ранее доступных потоков новый API std::thread::scope допускает передачу заимствованных (borrowing) нестатических данных, в то время как потоки, создаваемые при помощи классического API std::thread::spawn, должны были владеть всеми передаваемыми аргументами и не могли получать заимствованные переменные. API std::thread::scope гарантирует, что любые порождённые потоки будут завершены до возвращения данных, обеспечивая должный уровень безопасности для механизма заимствования. Предложены новые типы-обвязки для файловых дескрипторов - BorrowedFd и OwnedFd, обеспечивающие заимствование и владение. Типы помечены при помощи "#[repr(transparent)]", что позволяет напрямую использовать их во внешних Си-привязках с учётом владения. Предоставлена возможность вызова Condvar::new, Mutex::new и RwLock::new в контексте констант для создания глобальных статических значений Mutex, RwLock и Condvar без применения пакетов типа lazy_static. Для функций типа fn foo<T>(value: T, f: impl Copy) разрешено использование синтаксиса вида "foo::<u32>(3, 3)", явно указывая тип дженерика. Завершён переход на использование техники NLL (Non-Lexical Lifetimes) для выявления проблем с заимствованием переменных. NLL осуществляет учёт на уровне набора указателей в графе потока выполнения, что позволяет улучшить качество проверки заимствования переменных (borrow checker) и допустить выполнение некоторых видов корректного кода, использование которого ранее приводило к выводу ошибки. Поддержка старого механизма, использовавшего привязку времени жизни на лексическом уровне, теперь полностью удалена из rustc, а использование нового NLL внедрено повсеместно. В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: array::from_fn Box::into_pin BinaryHeap::try_reserve BinaryHeap::try_reserve_exact OsString::try_reserve OsString::try_reserve_exact PathBuf::try_reserve PathBuf::try_reserve_exact Path::try_exists Ref::filter_map RefMut::filter_map NonNull::<[T]>::len ToOwned::clone_into Ipv6Addr::to_ipv4_mapped unix::io::AsFd unix::io::BorrowedFd<'fd> unix::io::OwnedFd windows::io::AsHandle windows::io::BorrowedHandle<'handle> windows::io::OwnedHandle windows::io::HandleOrInvalid windows::io::HandleOrNull windows::io::InvalidHandleError windows::io::NullHandleError windows::io::AsSocket windows::io::BorrowedSocket<'handle> windows::io::OwnedSocket thread::scope thread::Scope thread::ScopedJoinHandle Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в функциях: array::from_ref slice::from_ref intrinsics::copy intrinsics::copy_nonoverlapping <*const T>::copy_to <*const T>::copy_to_nonoverlapping <*mut T>::copy_to <*mut T>::copy_to_nonoverlapping <*mut T>::copy_from <*mut T>::copy_from_nonoverlapping str::from_utf8 Utf8Error::error_len Utf8Error::valid_up_to Condvar::new Mutex::new RwLock::new Дополнительно можно отметить инициативу по использованию языка Rust для написания работающего на уровне ядра Linux драйвера для GPU Apple AGX, используемого в чипах Apple M1 и M2. Отмечается, что GPU Apple AGX выполняет прошивку и использует достаточно сложные совместно используемые структуры данных. Реализация управления прошивками и структурами на Rust позволила бы упростить разработку и добиться более высокой безопасности. Рассматриваются два варианта разработки: написание основой части на Си, но использование компонентов на Rust для взаимодействия с прошивкой и управления структурами данных в разделяемой памяти, или написание всего драйвера на Rust и создание Rust-обвязки для подсистемы DRM.