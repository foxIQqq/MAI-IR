Выпуск языка программирования Rust 1.51

Опубликован релиз языка системного программирования Rust 1.51, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Автоматическое управление памятью в Rust избавляет разработчика от ошибок при манипулировании указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Функциональность, связанная с применением константных дженериков ("const generics"), получила статус минимально жизнеспособного продукта (MVP), дающего зелёный свет на широкое применение. Константные дженерики позволяют обобщать типы для постоянных значений, т.е. использовать обобщённые аргументы, ограниченные диапазоном постоянных значений, а не типами и не временем жизни. Указанная возможность даёт возможность использовать типы, параметризованные целыми числами, и абстрагироваться при создании типажей для массивов любого размера без необходимости создания отдельного типа для каждого диапазона допустимых значений, чтобы гарантировать отсутствие выхода за пределы допустимого диапазона. Начиная с текущего выпуска, для массивов с типом "[T; N]" (тип T и размер N) предоставлена возможность абстрагироваться от типа и размера, используя значения с любыми целыми, булевыми и символьными типами (типы struct и enum пока не поддерживаются). Константные дженерики значительно упрощают разработку библиотек, например, для использования массива, не привязанного к конкретному типу и размеру, можно указать: struct Array<T, const LENGTH: usize> { // ^^^^^^^^^^^^^^^^^^^ определение константного дженерика list: [T; LENGTH] // ^^^^^^ его использование } При фактическом использовании c этим определением "Array<u8, 32>" компилятор сгенерирует мономорфную версию Array: struct Array<u8, 32> { list: [u8; 32] } Стабилизирован основанный на константных дженериках API std::array::IntoIter, при помощи которого для любого массива можно создавать итераторы по значению: fn main() { let array = [1, 2, 3, 4, 5]; // Раньше для перебора значение нужно было вызывать метод .iter() for item in array.iter().copied() { println!("{}", item); } // Теперь можно указать for item in std::array::IntoIter::new(array) { println!("{}", item); } } В пакетном менеджере cargo реализована поддержка нового поля resolver в Cargo.toml, при помощи которого можно включить вторую версию определителя доступных возможностей (feature resolver). Новая версия определителя избегает объединения возможностей зависимостей, перечисляемых в секции "[features]", там, где это неуместно, например, при подключении зависимости, запрашивающей какую-то стандартную возможность в сборочных скриптах и макросах, но при использовании нестандартной возможности в итоговом исполняемом файле. До сих пор возможности пакета, упоминаемого несколько раз в графе зависимости, объединялись. Например, если проект подключает зависимость foo, в которой определены возможности A и B, и этот пакет используется в других пакетах bar и baz, при том, что bar зависит от foo с возможностью A, а baz от foo с возможностью B, то в итоге cargo объединит эти возможности и откомпилирует foo с включением возможностей A и B. Подобный метод может привести к тому, что возможность включённая из-за какой-то зависимости может оказаться несовместимой с целевой системой, для которой осуществляется итоговая сборка. Например, когда требуется использовать версию foo с "#![no_std]" в исполняемом файле, собираемом с "#![no_std]", и одновременно использовать foo с "std" во время сборки в build.rs. При указании resolver="2" в Cargo.toml пакетный менеджер теперь попытается корректно обработать данный конфликт, разделяя dev-, host- и target-зависимости. В cargo реализована опция split-debuginfo, задаваемая в секции "[profile]" и соответствующий флаг "-Csplit-debuginfo=unpacked" в rustc, предлагающие реализацию нового метода сохранения отладочной информации, который позволяет избавиться от необходимости вызова утилиты dsymutil и существенно ускорить процесс сборки с отладочной информацией в macOS. Стабилизированы макросы "ptr::addr_of!" и "ptr::addr_of_mut!", позволяющие создавать raw-указатели для невыровненных полей. use std::ptr; #[repr(packed)] struct Packed { f1: u8, f2: u16, } let packed = Packed { f1: 1, f2: 2 }; // &packed.f2 создаст невыровненный указатель, приводящий к неопределённому поведению let raw_f2 = ptr::addr_of!(packed.f2); assert_eq!(unsafe { raw_f2.read_unaligned() }, 2); В разряд стабильных переведена новая порция API, в том числе стабилизированы методы: Arc::decrement_strong_count Arc::increment_strong_count Once::call_once_force Peekable::next_if_eq Peekable::next_if Seek::stream_position array::IntoIter panic::panic_any ptr::addr_of! ptr::addr_of_mut! slice::fill_with slice::split_inclusive_mut slice::split_inclusive slice::strip_prefix slice::strip_suffix str::split_inclusive sync::OnceState task::Wake Реализован третий уровень поддержки для платформ i386-unknown-linux-gnu, i486-unknown-linux-gnu, aarch64_be-unknown-linux-gnu, aarch64-unknown-linux-gnu_ilp32 и aarch64_be-unknown-linux-gnu_ilp32. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования, публикации официальных сборок и проверки возможности сборки кода.