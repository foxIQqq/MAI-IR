Выпуск пакетного фильтра nftables 0.9.2

Состоялся релиз пакетного фильтра nftables 0.9.2, развивающегося в качестве замены iptables, ip6table, arptables и ebtables за счёт унификации интерфейсов фильтрации пакетов для IPv4, IPv6, ARP и сетевых мостов. В пакет nftables входят компоненты пакетного фильтра, работающие в пространстве пользователя, в то время как на уровне ядра работу обеспечивает подсистема nf_tables, входящая в состав ядра Linux начиная с выпуска 3.13. Необходимые для работы выпуска nftables 0.9.2 изменения включения в состав ядра Linux 5.3. На уровне ядра предоставляется лишь общий интерфейс, не зависящий от конкретного протокола и предоставляющий базовые функции извлечения данных из пакетов, выполнения операций с данными и управления потоком. Непосредственно логика фильтрации и специфичные для протоколов обработчики компилируются в байткод в пространстве пользователя, после чего данный байткод загружается в ядро при помощи интерфейса Netlink и выполняется в специальной виртуальной машине, напоминающей BPF (Berkeley Packet Filters). Подобный подход позволяет значительно сократить размер кода фильтрации, работающего на уровне ядра и вынести все функции разбора правил и логики работы с протоколами в пространство пользователя. Основные новшества: Возможность проверки номера порта из заголовка пакета транспортного уровня независимо от типа протокола 4 уровня: add rule x y ip protocol { tcp, udp } th dport 53 Поддержка восстановления времени жизни набора элементов: add element ip x y { 1.1.1.1 timeout 30s expires 15s } Возможность проверки отдельных опций (lsrr, rr, ssrr и ra) из пакетов IPv4: add rule x y ip option rr exists drop Для опций маршрутизации возможна проверка полей type, ptr, length и addr: add rule x y ip option rr type 1 drop В выражениях теперь допустимо указание сетевых префиксов и диапазонов адресов: iifname ens3 snat to 10.0.0.0/28 iifname ens3 snat to 10.0.0.1-10.0.0.15 Поддержка использования переменных в определениях цепочек: define default_policy = accept add chain ip foo bar { type filter hook input priority filter; policy $default_policy } Указание приоритета цепочки теперь может производиться как в числовом, таки символьном виде: define prio = filter define prionum = 10 define prioffset = "filter - 150" add table ip foo add chain ip foo bar { type filter hook input priority $prio; } add chain ip foo ber { type filter hook input priority $prionum; } add chain ip foo bor { type filter hook input priority $prioffset; } Реализована поддержка модуля synproxy. Например, для размещения TCP-порта 8888 под защитой synproxy можно использовать набор правил: table ip x { chain y { type filter hook prerouting priority raw; policy accept; tcp dport 8888 tcp flags syn notrack } chain z { type filter hook forward priority filter; policy accept; tcp dport 8888 ct state invalid,untracked synproxy mss 1460 \\ wscale 7 timestamp sack-perm ct state invalid drop } } Для определения в таблице conntrack связанных с текущим соединением ожидаемых дополнительных соединений, которые применяются в требующих установки нескольких соединений протоколах и сценариях, теперь можно определять политики через штатные наборы правил. Например, для определения ожидаемых после соединений к TCP порту 8888 последующих соединений к порту 5432 можно указать следующие правила: table x { ct expectation myexpect { protocol tcp dport 5432 timeout 1h size 12 l3proto ip } chain input { type filter hook input priority 0; ct state new tcp dport 8888 ct expectation set myexpect ct state established,related counter accept } }