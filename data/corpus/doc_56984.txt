Выпуск языка программирования Rust 1.60

Опубликован релиз языка программирования общего назначения Rust 1.60, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Методы работы с памятью в Rust избавляют разработчика от ошибок при манипулировании указателями и защищают от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами, учёт времени жизни объектов (области видимости) и оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок. Основные новшества: В компиляторе rustc стабилизирована основанная на LLVM система для генерации coverage-данных, используемых для оценки охвата кода при тестировании. Для включения coverage-данных при сборке необходимо использовать флаг "-Cinstrument-coverage", например, запуская сборку командой "RUSTFLAGS="-C instrument-coverage" cargo build". После запуска собранного таким образом исполняемого файла в текущем каталоге будет сохранён файл default.profraw, для обработки которого можно использовать утилиту llvm-profdata из компонента llvm-tools-preview. Обработанный утилитой llvm-profdata вывод затем можно передать программе llvm-cov для генерации аннотированного отчёта со сведениями об охвате кода. Информация о привязке к исходным текстам берётся из исследуемого исполняемого файла, в который включаются необходимые данные о связи coverage-счётчиков с кодом. 1| 1|fn main() { 2| 1| println!("Hello, world!"); 3| 1|} В пакетном менеджере cargo стабилизирована поддержка флага "--timings", включающего формирование детального отчёта о ходе сборки и времени выполнения каждого шага. Отчёт может оказаться полезен для оптимизации производительности сборочного процесса. В пакетном менеджере cargo предложен новый синтаксис для механизма условной компиляции и выбора необязательных зависимостей, настраиваемого в файле Cargo.toml через перечисление списка именованных свойств в секции [features] и активируемого через включение свойств во время сборки пакета при помощи флага "--features". В новой версии добавлена поддержка зависимостей в отдельных пространствах имён и слабых (weak) зависимостей. В первом случае реализована возможность использования внутри секции "[features]" элементов с префиксом "dep:" для явной привязки к необязательной зависимости без неявного представления этой зависимости как свойства (feature). Во втором случае добавлена поддержка пометки знаком "?" ("package-name?/feature-name") необязательных зависимостей, которые следует включить только, если какое-то другое свойство включает данную необязательную зависимость. Например, в примере ниже включение свойства serde приведёт к включению зависимости "serde", а также свойства "serde" для зависимости "rgb", но только если где-то ещё включена зависимость "rgb": [dependencies] serde = { version = "1.0.133", optional = true } rgb = { version = "0.8.25", optional = true } [features] serde = ["dep:serde", "rgb?/serde"] Возвращена отключённая в прошлом выпуске поддержка инкрементальной компиляции. Ошибка в компиляторе, из-за которой функция была отключена, устранена. Решены некоторые проблемы с предоставлением для таймеров Instant гарантии монотонного расчёта времени, при котором учитывается время, проведённое системой в спящем режиме. Ранее для работы таймера по возможности использовался OS API, который не учитывал проблемные ситуации, нарушающие монотонность времени, такие как проблемы с оборудованием, применение виртуализации или ошибки в операционной системе. В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: Arc::new_cyclic Rc::new_cyclic slice::EscapeAscii <[u8]>::escape_ascii u8::escape_ascii Vec::spare_capacity_mut MaybeUninit::assume_init_drop MaybeUninit::assume_init_read i8::abs_diff i16::abs_diff i32::abs_diff i64::abs_diff i128::abs_diff isize::abs_diff u8::abs_diff u16::abs_diff u32::abs_diff u64::abs_diff u128::abs_diff usize::abs_diff Display для io::ErrorKind From для ExitCode Not для ! (тип "never") _Op_Assign<$t> arch::is_aarch64_feature_detected! Реализован третий уровень поддержки для платформ mips64-openwrt-linux-musl* и armv7-unknown-linux-uclibceabi (softfloat). Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования, публикации официальных сборок и проверки возможности сборки кода. Компилятор переведён на использование LLVM 14. Дополнительно можно отметить: Добавлена поддержка раскрутки компилятора (bootstrapping) rustc при помощи бэкенда rustc_codegen_gcc, позволяющего использовать библиотеку libgccjit от проекта GCC в качестве генератора кода в rustc, что позволяет обеспечить в rustc поддержку доступных в GCC архитектур и оптимизаций. Под раскруткой компилятора понимается возможность использования в rustc генератора кода на основе GCC для сборки самого компилятора rustc. С практической стороны подобная возможность позволяет собирать rust-программы для архитектур, ранее не поддерживаемых в rustc. Доступен выпуск инструментария uutils coreutils 0.0.13, в рамках которого развивается аналог пакета GNU Coreutils, переписанный на языке Rust. В состав coreutils входит более ста утилит, включая sort, cat, chmod, chown, chroot, cp, date, dd, echo, hostname, id, ln и ls. Целью проекта является создание кроссплатформенной альтернативной реализации Coreutils, способной работать в том числе на платформах Windows, Redox и Fuchsia, а также распространение под пермиссивной лицензией MIT, вместо копилефт-лицензии GPL. В новой версии улучшены реализации многих утилит, в том числе значительно улучшена совместимость утилит cp, dd, df, split и tr с аналогами от проекта GNU. Предоставлена online-документация. Для разбора аргументов командной строки задействован парсер clap, что позволило улучшить вывод для флага "--help" и добавить поддержку аббревиатур длинных команд (например, можно указывать "ls --col" вместо "ls --color").