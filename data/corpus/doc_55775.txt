Выпуск языка программирования Rust 1.55

Опубликован релиз языка системного программирования Rust 1.55, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Автоматическое управление памятью в Rust избавляет разработчика от ошибок при манипулировании указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: В пакетном менеджере Cargo реализована возможность объединения дубликатов ошибок и предупреждений, возникающих во время сборки. При выполнении таких команд как "cargo test" и "cargo check --all-targets", приводящих к многократной сборке пакета с разными параметрами, пользователю теперь показывается сводная информация о возникновении повторяющейся проблемы, вместо отображения нескольких одинаковых предупреждений при повторной сборке одного и того же файла. $ cargo +1.55.0 check --all-targets Checking foo v0.1.0 warning: function is never used: 'foo' --> src/lib.rs:9:4 | 9 | fn foo() {} | ^^^ | = note: '#[warn(dead_code)]' on by default warning: 'foo' (lib) generated 1 warning warning: 'foo' (lib test) generated 1 warning (1 duplicate) Finished dev [unoptimized + debuginfo] target(s) in 0.84s Код для разбора чисел с плавающей запятой в стандартной библиотеке переведён на использование более быстрого, но менее точного алгоритма Эйзеля-Лемира. В случае, когда этот алгоритм не может правильно разобрать число, происходит откат к старому алгоритму. Стабилизирована возможность указания незакрытых диапазонов в шаблонах ("X.." интерпретируется как диапазон, который начинается со значения X и заканчивается максимальным значением целого типа): match x as u32 { 0 => println!("zero!"), 1.. => println!("positive number!"), } Расширены варианты ошибок, охватываемые списком std::io::ErrorKind (классифицирует ошибки по категориям, таким как NotFound и WouldBlock). Раньше, ошибки не подпадающие под имеющиеся категории, попадали в категорию ErrorKind::Other, которая также применялась для ошибок в стороннем коде. Теперь для не подпадающих под имеющиеся категории ошибок создана отдельная внутренняя категория ErrorKind::Uncategorized, а категория ErrorKind::Other ограничена только ошибками, возникающими не в стандартной библиотеке (функции стандартной библиотеки, возвращающие io::Error, больше не используют категорию ErrorKind::Other). В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: Bound::cloned Drain::as_str IntoInnerError::into_error IntoInnerError::into_parts MaybeUninit::assume_init_mut MaybeUninit::assume_init_ref MaybeUninit::write array::map ops::ControlFlow x86::_bittest x86::_bittestandcomplement x86::_bittestandreset x86::_bittestandset x86_64::_bittest64 x86_64::_bittestandcomplement64 x86_64::_bittestandreset64 x86_64::_bittestandset64 Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в методе str::from_utf8_unchecked. Реализован третий уровень поддержки для платформы powerpc64le-unknown-freebsd. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования, публикации официальных сборок и проверки возможности сборки кода. Дополнительно можно отметить недавний доклад Мигеля Охеда (Miguel Ojeda), автора проекта Rust-for-Linux, о состоянии патчей для интеграции поддержки разработки на языке Rust для ядра Linux.