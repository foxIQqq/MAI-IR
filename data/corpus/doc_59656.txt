Выпуск Rust 1.72. Поставка пакета serde_derive только в скомпилированном виде

Опубликован релиз языка программирования общего назначения Rust 1.72, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Методы работы с памятью в Rust избавляют разработчика от ошибок при манипулировании указателями и защищают от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами, учёт времени жизни объектов (области видимости) и оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок. Основные новшества: В сообщениях об ошибках обеспечено отображение сведений об элементах, отключённых через атрибуты условной компиляции "cfg", позволяющие активировать выполнение Rust-кода в зависимости от наличия поддержки определённых возможностей crate или запуска на отдельных платформах. Ранее, элементы, отключённые через cfg, были не видны компилятору, но теперь компилятор запоминает их имена и условия скрытия, и отображает эту информацию в сообщениях об ошибках, что, например, позволяет понять, что какая-то функция недоступна из-за отключения определённых feature-свойств в crate. Compiling my-project v0.1.0 (/tmp/my-project) error[E0432]: unresolved import `rustix::io_uring` --> src/main.rs:1:5 | 1 | use rustix::io_uring; | ^^^^^^^^^^^^^^^^ no `io_uring` in the root | note: found an item that was configured out --> /home/username/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rustix-0.38.8/src/lib.rs:213:9 | 213 | pub mod io_uring; | ^^^^^^^^ = note: the item is gated behind the `io_uring` feature For more information about this error, try `rustc --explain E0432`. error: could not compile `my-project` (bin "my-project") due to previous error Убраны ограничения на время вычисления выражений const. Ранее, для предотвращения зацикливаний во время компиляции, Rust ограничивал максимальное число выражений, выполняемых в процессе вычисления констант. Данная особенность приводила к выводу ошибок при компиляции кода, не вписывающегося в ограничения, поэтому в новом выпуске решено заменить жёсткие ограничения на вывод предупреждения, информирующего о длительно выполняемых вычислениях констант. Также по умолчанию применена lint-проверка const_eval_long_running, выявляющая зацикливания. В компилятор rustc перенесена серия lint-проверок из Clippy: undropped_manually_drops, invalid_utf8_in_unchecked, invalid_nan_comparisons и invalid_reference_casting. В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: impl<T: Send> Sync for mpsc::Sender<T> impl TryFrom<&OsStr> for &str String::leak Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в функциях: CStr::from_bytes_with_nul CStr::to_bytes CStr::to_bytes_with_nul CStr::to_str Реализован третий уровень поддержки для платформ loongarch64-unknown-none*. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования, публикации официальных сборок и проверки возможности сборки кода. В будущем выпуске Rust 1.76 планируется прекратить поддержку платформ Windows 7, 8 и 8.1, и сделать Windows 10 минимальной версией как для самого компилятора, так и для целей компиляции. Дополнительно можно упомянуть разногласия в сообществе, возникшие из-за перехода разработчиков фреймворка Serde на поставку crate-пакета serde_derive с макросом derive только в уже скомпилированном бинарном виде. Пакет serde_derive применяется для сериализации и десериализации данных и используется в качестве зависимости в 5495 других пакетах, среди которых 10 имеют более 50 млн загрузок. Общее число загрузок serde_derive оценивается в 172 млн (до 400 тысяч загрузок в день). Опасение вызывает то, что поставка в бинарном виде затруднит аудит целостности пакета и повысит опасность компрометации зависимых проектов в случае успешной атаки на разработчиков фреймворка Serde. По мнению участвующих в дискуссии пользователей, повышение скорости сборки из-за поставки в предкомпилированном виде не оправдывает возникающих рисков, связанных с безопасностью. Поставка в бинарном виде также затруднит сопровождение Rust-пакетов в проектах и дистрибутивах, таких как Fedora Linux, запрещающих поставку сторонних бинарных компонентов. В качестве одного из решений представителями сообщества предложено продолжить поставку serde_derive как раньше в исходных текстах, а для бинарной сборки создать отдельный пакет, который можно будет использовать по желанию, без навязывания существующим пользователям. Мэйнтейнер проекта Serde отказался идти на компромисс и заявил, что предкомпилированная реализация макроса будет единственным вариантом поставки пакета serde_derive. Код Serde продолжает быть открытым и распространяется под лицензиями MIT и Apache 2.0, а несогласным с новой политикой разработчикам предложено создать и поддерживать собственный форк пакета. В ответ на критику, связанную с потерей возможности анализа кода пакета перед использованием, мэйнтейнер Serde указал, что даже на бросающийся в глаза перевод serde_derive в бинарную форму обратили внимание только спустя 4 недели и 12 релизов. При таком отношении профессионально обфусцированная вредоносная вставка в исходных текстах, вероятно, может годами оставаться незамеченной. Для подтверждения корректности сборок и выявления возможной подмены содержимого после успешной атаки рассматривается возможность задействования проверки на основе повторяемых сборок, позволяющих удостовериться, что бинарный файл собран из исходных текстов, размещённых в репозитории, без внесения изменений. Дополнение: В выпуске 1.0.184 разработчики вернулись к поставке пакета serde_derive в исходных текстах, решив отложить переход на поставку в бинарном виде до принятия в пакетный менеджер crate изменений для полноценной поддержки верификации предкомпилированных макросов. Разработчиками Serde подготовлен RFC с предложением реализовать в Crate верификацию предкомпилированных пакетов, проводимую на сервере репозитория crates.io через сверку бинарного файла с повторяемой сборкой из исходных текстов.