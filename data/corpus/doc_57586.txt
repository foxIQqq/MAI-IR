Восьмая версия патчей для ядра Linux с поддержкой языка Rust

Мигель Охеда (Miguel Ojeda), автор проекта Rust-for-Linux, предложил для рассмотрения разработчиками ядра Linux выпуск v8 компонентов для разработки драйверов устройств на языке Rust. Это девятая редакция патчей с учётом первого варианта, опубликованного без номера версии. Поддержка Rust рассматривается как экспериментальная, но уже включена в ветку linux-next, претендует на интеграцию в осенний выпуск 5.20/6.0 и достаточно развита для начала работы по созданию слоёв абстракции над подсистемами ядра, а также для написания драйверов и модулей. Разработка финансируется компанией Google и организацией ISRG (Internet Security Research Group), которая является учредителем проекта Let's Encrypt и способствует продвижению HTTPS и развитию технологий для повышения защищённости интернета. В новой версии: Инструментарий и вариант библиотеки alloc, избавленный от возможных генераций состояния "panic" при возникновении ошибок, обновлены до выпуска Rust 1.62. По сравнению с ранее используемой версией в инструментарии Rust стабилизирована поддержка функциональности const_fn_trait_bound, используемой в патчах к ядру. Код привязок выделен в отдельный crate-пакет "bindings", что упрощает пересборку в случае внесения изменений только в основной пакет "kernel". Реализация макроса "concat_idents!" переписана в форме процедурного макроса, не привязанного к функциональности concat_idents и допускающего применение ссылок на локальные переменные. Переписан макрос "static_assert!", что позволило использовать "core::assert!()" в любом контексте вместо констант. Макрос "build_error!" адаптирован для работы при выставлении для модулей режима "RUST_BUILD_ASSERT_{WARN,ALLOW}". Добавлен отдельный файл с настройками "kernel/configs/rust.config". Обрабатываемые в макроподстановках файлы "*.i" переименованы в "*.rsi". Прекращена поддержка сборки Rust-компонентов с уровнями оптимизации, отличными от применяемых для кода на языке Си. Добавлен модуль fs, предоставляющий обвязки для работы с файловыми системами. Предложен пример простой файловой системы, написанной на языке Rust. Добавлен модуль workqueue для работы с системными очередями (предоставляет обвязки над структурами ядра work_struct и workqueue_struct). Продолжено развитие модуля kasync с реализацией методов асинхронного программирования (async). Добавлен пример работающего на уровне ядра TCP-сервера, написанного на Rust. Добавлена возможность обработки прерываний на языке Rust при помощи типажей [Threaded]Handler и типов [Threaded]Registration`. Добавлен процедурный макрос "#[vtable]", упрощающий работу с таблицами указателей на функции, такими как структура file_operations. Добавлена реализация двунаправленных связных списков "unsafe_list::List". Добавлена начальная поддержка RCU (Read-copy-update) и тип Guard для проверки привязки блокировки на чтение к текущему потоку. Добавлена функция Task::spawn() для создания и автоматического запуска потоков ядра. Также добавлен метод Task::wake_up(). Добавлен модуль delay, позволяющий использовать задержки (обёртка над msleep()). Предложенные изменения дают возможность использовать Rust в качестве второго языка для разработки драйверов и модулей ядра. Поддержка Rust преподносится как опция, не активная по умолчанию и не приводящая к включению Rust в число обязательных сборочных зависимостей к ядру. Использование Rust для разработки драйверов позволит с минимальными усилиями создавать безопасные и более качественные драйверы, избавленные от таких проблем как обращение к области памяти после её освобождения, разыменование нулевых указателей и выход за границы буфера. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами и учёт времени жизни объектов (области видимости), а также через оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок.