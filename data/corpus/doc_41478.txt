Третий выпуск реализации kdbus для ядра Linux

Грег Кроа-Хартман (Greg Kroah-Hartman) представил в списке рассылки разработчиков ядра Linux третью версию патчей с реализацией kdbus, надёжной, быстрой и безопасной системы обмена сообщениями, поддерживающей доставку сообщений в режиме точка-точка и в режиме мультикаст (от одного отправителя к группе получателей). Kdbus может использоваться не только для альтернативных реализаций D-Bus, не требующих запуска отдельного демона в пространстве пользователя, но и в виде самодостаточного IPC, например, данная система уже поддерживается в systemd. В третьей версии патчей добавлен флаг FS_USERNS_MOUNT, при помощи которого пользователи могут примонтировать собственные обособленные экземпляры kdbusfs. Переписана большая часть кода, связанная с обработкой метаданных, что позволило обеспечить возможность трансляции привязанных к получателям пространств имён. Идентификаторы PID и TID перемещены из KDBUS_ITEM_CREDS в KDBUS_ITEM_PIDS, что дало возможность отслеживать ситуации с повторным использованием PID другим процессом. Прекращена поддержка интерфейса KDBUS_CMD_CANCEL, вместо которого следует использовать CANCEL_FD с ioctl CMD_SEND. Вызов KDBUS_CMD_MSG_SEND переименован в KDBUS_CMD_SEND, а KDBUS_CMD_MSG_RECV в KDBUS_CMD_RECV. Из основных достоинств реализации шины kdbus на уровне ядра отмечается: Высокая производительность за счёт минимизации переключения контекста процессов, меньшего выполнения операций копирования, сокращения системных вызовов, использования memfd; Высокая безопасность из-за исключения влияния пользовательских процессов на содержимое шины и использования механизмов ядра для управления передачей данных, в том числе с возможностью контроля со стороны модулей LSM; К сообщениям может быть прикреплено больше метаданных; Пригодность для приложений, обрабатывающих большие потоки данных, с возможностью расстановки сообщений в очереди на основании приоритетов и задания глобального упорядочивания сообщений. Например, некоторые разработчики нашли применение в kdbus даже для передачи звука в системе; Неподверженность многим состояниям гонки, которые трудно устранить в реализации на уровне пользователя. Например, ситуация отсоединения клиента от шины только при условии отсутствия сообщений в его очереди; Возможность мониторинга на уровне ядра. Привилегированные пользователи могут подключиться к потоку сообщений без создания специализированных механизмов в пространстве пользователя; Возможность прямой доставки сообщения без помещения в очередь, что удобно при организации обработки запросов активации по шине; Возможность раннего доступа к шине, на этапе выполнения initrd.