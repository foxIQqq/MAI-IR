DeepMind открыл код S6, библиотеки с реализацией JIT-компилятора для CPython

Компания DeepMind, получившая известность своими разработками в области искусственного интеллекта, открыла исходные тексты проекта S6, развивавшего JIT-компилятор для языка Python. Проект интересен оформлением в виде библиотеки-расширения, интегрируемой с штатным CPython, обеспечивающей полную совместимость с CPython и не требующей модификации кода интерпретатора. Проект развивался с 2019 года, но к сожалению был свёрнут и больше не развивается. Так как созданные наработки могут оказаться полезными для улучшения Python, было принято решение открыть исходные тексты. Код JIT-компилятора написан на языке C++, основан на CPython 3.7. и открыт под лицензией Apache 2.0. По решаемым задачам S6 для Python сравнивается с движком V8 для JavaScript. Библиотека заменяет существующий обработчик интерпретатора байткода ceval.c собственной реализацией, использующей JIT-компиляцию для ускорения выполнения. S6 проверяет, скомпилирована ли уже текущая функция и, если да - исполняет скомпилированный код, а если нет - запускает функцию в режиме интерпретации байткода, похожем на интерпретатор CPython. При интерпретации подсчитывается число выполненных инструкций и обращений, связанных с обрабатываемой функцией. После достижения определённого рубежа для ускорения часто выполняемого кода инициируется процесс компиляции. Компиляция производится в промежуточное представление strongjit, которое после оптимизации преобразуется в машинные инструкции целевой системы при помощи библиотеки asmjit. В зависимости от характера нагрузки S6 при оптимальных условиях демонстрирует повышение скорости выполнения тестов до 9.5 раз в сравнении с обычным CPython. При запуске 100 итераций тестового набора Richards наблюдается ускорение в 7 раз, а при запуске теста Raytrace, в котором присутствует большой объём математических вычислений, - в 3-4.5 раза. Из задач которые плохо поддаются оптимизации при помощи S6, называются проекты, использующие C API, такие как NumPy, а также операции, связанные с необходимостью проверки типов большого числа значений. Низкая производительность также наблюдается для единичных вызовов ресурсоёмких функций из-за использования в S6 собственной неоптимизированной реализации Python-интерпретатора (разработка не достигла стадии проведения оптимизации режима интерпретации). Например, в тесте Unpack Sequence, выполняющем распаковку больших наборов массивов/кортежей, при единичном вызове наблюдается замедление до 5 раз, а при цикличном вызове - производительность составляет 0.97 от CPython.