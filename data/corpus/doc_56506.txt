Выпуск языка программирования Rust 1.58

Опубликован релиз языка программирования общего назначения Rust 1.58, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Методы работы с памятью в Rust избавляют разработчика от ошибок при манипулировании указателями и защищают от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами, учёт времени жизни объектов (области видимости) и оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок. Основные новшества: В блоках форматирования строк, в дополнение к ранее доступной возможности подстановки явно перечисленных после строки переменных по номеру и имени, реализована возможность подстановки произвольных идентификаторов через добавление в строку выражений "{идентификатор}". Например: // Ранее поддерживались конструкции: println!("Hello, {}!", get_person()); println!("Hello, {0}!", get_person()); println!("Hello, {person}!", person = get_person()); // теперь можно указывать let person = get_person(); println!("Hello, {person}!"); Идентификаторы также можно указывать непосредственно в параметрах форматирования. let (width, precision) = get_format(); for (name, score) in get_scores() { println!("{name}: {score:width$.precision$}"); } Новая подстановка работает во всех макросах, поддерживающих определение формата строки, за исключением макроса "panic!" в версиях языка Rust 2015 и 2018, в которых panic!("{ident}") обрабатывается как обычная строка (в Rust 2021 подстановка срабатывает). Изменено поведение структуры std::process::Command на платформе Windows, которая при выполнении команд из соображений безопасности больше не ищет исполняемые файлы в текущем каталоге. Текущий каталог исключён так как может быть использован для организации выполнения кода злоумышленника в случае запуска программ в не заслуживающих доверия каталогах (CVE-2021-3013). Новая логика определения исполняемых файлов подразумевает поиск в каталогах Rust, в каталоге приложения, системном каталоге Windows и каталогах, указанных в переменной окружения PATH. В стандартной библиотеке расширено число функций, помеченных "#[must_use]" для вывода предупреждения в случае игнорирования возвращаемого значения, что помогает выявить ошибки, вызванные предположением, что функция изменит значения, а не вернёт новое значение. В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: Metadata::is_symlink Path::is_symlink {integer}::saturating_div Option::unwrap_unchecked Result::unwrap_unchecked Result::unwrap_err_unchecked Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в функциях: Duration::new Duration::checked_add Duration::saturating_add Duration::checked_sub Duration::saturating_sub Duration::checked_mul Duration::saturating_mul Duration::checked_div Разрешено разыменование указателей "*const T" в контекстах "const". В пакетном менеджере Cargo в метаданные пакета добавлено поле rust_version, а в команду "cargo install" добавлена опция "--message-format". В компиляторе реализована поддержка механизма защиты CFI (Control Flow Integrity), добавляющего перед каждым косвенным вызовом функции проверки для выявления некоторых форм неопределённого поведения, которые потенциально могут привести к нарушению нормального порядка выполнения (control flow) в результате применения эксплоитов, изменяющих хранимые в памяти указатели на функции. В компиляторе добавлена поддержка 5 и 6 версии формата coverage-сопоставлений LLVM, используемого для оценки охвата кода при тестировании. В компиляторе требования к минимальной версии LLVM подняты до LLVM 12. Реализован третий уровень поддержки для платформы x86_64-unknown-none. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования, публикации официальных сборок и проверки возможности сборки кода. Дополнительно можно отметить публикацию компанией Microsoft выпуска библиотек Rust for Windows 0.30, позволяющих использовать язык Rust для разработки приложений для ОС Windows. В набор входят два crate-пакета (windows и windows-sys), через которые можно обращаться к WinAPI в программах на языке Rust. Код для поддержки API генерируется динамически из метаданных с описанием API, что позволяет реализовать поддержку не только уже существующих вызовов WinAPI, но вызовов, которые появятся в будущем. В новой версии добавлена поддержка целевой платформы UWP (Universal Windows Platform), реализованы типажи Handle и Debug.