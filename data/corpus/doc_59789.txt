Доступен набор компиляторов LLVM 17.0

После шести месяцев разработки представлен релиз проекта LLVM 17.0 - GCC-совместимого инструментария (компиляторы, оптимизаторы и генераторы кода), компилирующего программы в промежуточный биткод RISC-подобных виртуальных инструкций (низкоуровневая виртуальная машина с многоуровневой системой оптимизаций). Сгенерированный псевдокод может быть преобразован при помощи JIT-компилятора в машинные инструкции непосредственно в момент выполнения программы. Основные улучшения в Clang 17.0: Реализованы возможности, определённые в будущем Си-стандарте C2x: Добавлены ключевые слова bool, static_assert, alignas, alignof и thread_local. Разрешено указание пустых скобок "{}" для инициализации в нулевые значения , т.е. теперь можно писать "struct S { int x, y } s = {};". Предоставлена возможность указания любых универсальных имён символов в символьных и строковых литералах. Например, "int \u0024 = 0;". В "stddef.h" добавлен макрос "unreachable". Из спецификации исключён макрос ATOMIC_VAR_INIT. Добавлена полная реализация типов nullptr и nullptr_t. Например, можно указывать "void func(nullptr_t); func(0); func((void *)0);". В коде на языке Си предоставлена возможность проброса через выражение "goto" внутри блоков "asm" по косвенно выбранным меткам. Например, goto("mov %1, %0\n\tjmp %l[label]" : "=r" (x) : "r" (45) : : label); Добавлена поддержка Си-расширения, позволяющего использовать в "_Generic" в качестве первого операнда тип, а не выражение. Например, "_Generic(typeof(i), int : 0, const int : 1);". В константных выражениях на языке Си разрешено использование структур, объединений и массивов, объявленных с признаком "const". Реализованы расширенные возможности, связанные со стандартом C++20: Для всех платформ, за исключением Windows, обеспечена полная поддержка сопрограмм (Coroutines). Реализованы дополнительные требования к операциям сравнения константных выражений. Обеспечен корректный разбор лямбда-шаблонов, указанных сразу после параметров шаблона и содержащих в блоке "requires" переменную с зависимым типом. Включён по умолчанию флаг "-Wreserved-module-identifier", приводящий к выводу предупреждения вместо ошибки при использовании зарезервированных идентификаторов в блоке экспорта модулей. Добавлена поддержка выражения "requires cplusplus20" в описаниях связей заголовочных файлов с модулями (module map). Реализованы дополнительные требования к применению операторов сравнения. Зарезервировано использование двойного подчёркивания в пользовательских литералах и объявлено устаревшим использования ключевого слова "operator" в определении функций с зарезервированными идентификаторами в имени (например, 'double operator"" _Bq(long double);'). Обеспечено определение макроса "__cpp_consteval". Разрешено использование CTAD для агрегатных типов. Разрешено использование спецификатора "auto" для указателей и ссылок на массивы. Реализованы расширенные возможности, связанные со стандартом C++23, который находится на финальной стадии утверждения в ISO: Изменена область действия хвостового возвращаемого типа (trailing-return-type) в лямбда-функциях, который теперь сначала смотрит в перехваты, а затем в окружающий текст. Ослаблены некоторые требования к "constexpr". Например, в constexpr-функциях разрешено указание переменных нелитеральных типов в качестве возвращаемых значений и параметров. Разрешён вызов в constexpr-функциях других функций и конструкторов, не являющихся "constexpr". Добавлена поддержка выражения "requires cplusplus23" в описаниях связей заголовочных файлов с модулями (module map). Реализовано требование, в соответствии с которым все функции, вызывающие функции с признаком consteval тоже становятся consteval, т.е. выполняются при компиляции. Реализованы расширенные возможности, связанные с будущим стандартом C++2с (C++26): В компилятор добавлены новые флаги "-std=c++2c" и "-std=gnu++2c" для включения экспериментальной поддержки развивающейся спецификации C++2c. Для constexpr реализована поддержка "стирания типа" через преобразование указателей в void* и обратно в исходный тип, что позволит добиться возможности выполнения std::format во время компиляции. Частично реализована поддержка невычисляемых строк (unevaluated string), которые используются только на стадии компиляции в _Pragma, asm, extern, static_assert, [[deprecated]] и [[nodiscard]], и не попадают в скомпилированную программу. Добавлена возможность использования в static_assert сгенерированных пользователем диагностических сообщений. При компиляции приложений языке C++ при использовании режима оптимизации "-O0" улучшена генерация кода для вызовов, подобных std::forward_like, std::move и std::forward, которые теперь обрабатываются как встроенные в компилятор и не использующие стандартную библиотеку. Кроме того, улучшена генерация кода при динамическом приведении (dynamic_cast) к окончательному типу (для сравнения данных RTTI больше не используется runtime-библиотека и указатели vtable сравниваются напрямую). Разрешено использование static_assert(false) в коде на C++ в контексте определения шаблона. Добавлена поддержка встроенных функций (builtin): "__builtin_nondeterministic_value" - возвращает недетерминированное значение с тем же типом. "__builtin_FILE_NAME" - аналог макроса __FILE_NAME__. "__builtin_FUNCSIG - аналог макроса "__FUNCSIG__". "__builtin_assume_separate_storage" - проверяет, что аргумент указывает на объекты в отдельно выделенной памяти. "__builtin_isfpclass" - проверяет сочетаемость значения с плавающей запятой с указанным классом данных. "__builtin_elementwise_round" - предоставляет доступ к llvm.round для типов с плавающей запятой. "__builtin_elementwise_rint" - предоставляет доступ к llvm.rint для типов с плавающей запятой. "__builtin_elementwise_nearbyint" - предоставляет доступ к llvm.nearbyint для типов с плавающей запятой. Добавлена поддержка встроенных функций stdio, доступных в GCC: __builtin_vprintf, __builtin_vfprintf, __builtin_fscanf, __builtin_scanf, __builtin_sscanf, __builtin_vfscanf, __builtin_vscanf, __builtin_vsscanf. Добавлена возможность определения многомерных массивов через "__declspec(property)". Добавлен новый встроенный типаж "__is_trivially_equality_comparable" проверяющий идентичность двух экземпляров типов (например, memcmp(&lhs, &rhs, sizeof(T)) == 0). Добавлена поддержка переменной окружения NO_COLOR для отключения выделения цветом вывода. Добавлены новые флаги компилятора: "-std=c++23", "-dumpdir", "-fcaret-diagnostics-max-lines", "-fkeep-persistent-storage-variables", "-f[no-]assume-unique-vtables", "-print-multi-flags-experimental". Для совместимости с GCC добавлены флаги "-maix32", "-maix64" и "-p". Объявлен устаревшим флаг "-fdouble-square-bracket-attributes". Удалены устаревшие флаги "-fmodules-ts", "-fcoroutines-ts", "-lower-global-dtors-via-cxa-atexit" и "-no-opaque-pointers". Добавлен новый атрибут функций "__attribute__((unsafe_buffer_usage))", сигнализирующий об осознанной небезопасной работе с буферами в функции (при указании атрибута для функции не выводится предупреждение "-Wunsafe-buffer-usage"). Значительно расширены средства диагностики и статического анализа, например, добавлены новые проверки переполнения знаковых целых чисел, корректности лямбда-шаблонов, выражений constexpr, сравнений с нулевыми указателями, использования неинициализированных структур и т.п. Доступен обзор новых возможностей диагностики с наглядными примерами. Основные новшества LLVM 17.0: В бэкенд для архитектуры X86 добавлена поддержка расширений архитектуры набора команд (ISA): AMX-COMPLEX, SHA512, SM3, SM4 и AVX-VNNI-INT16. Заметно расширены возможности бэкенда для архитектуры RISC-V. Добавлена поддержка процессора sifive-x280. Реализована поддержка процессорных расширений XTHeadBa, XTHeadBb, XTHeadBs, XTHeadCondMov, XTHeadMac, XTHeadMemPair, XTHeadMemIdx, Xsfvcp (SiFive VCIX), Xsfcie (SiFive CIE), Zawrs, XTHeadCmo, XTHeadSync, XTHeadFMemIdx, Xca 1.0.1, Zcf 1.0.1, Zcd 1.0.1, Zfa 0.2. В бэкенд для архитектуры LoongArch добавлена поддержка расширений LSX, LASX, LVZ и LBT ISA. Улучшены бэкенды для архитектур AArch64, ARM, WebAssembly, MIPS, PowerPC, AMDGPU. В отладчик LLDB добавлена новая команда "register info" для вывода всей информации, известной о регистре. Расширены возможности компоновщика LLD. В библиотеке Libc++ продолжена реализация поддержки возможностей стандартов C++20 и C++23, а также началась работа по обеспечению поддержки спецификации C++26.