Релиз языка программирования Rust 1.22

Состоялся релиз языка программирования Rust 1.22, развиваемого проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime. По структуре язык Rust напоминает C++, но существенно отличается в некоторых деталях реализации синтаксиса и семантики. Автоматическое управление памятью избавляет разработчика от манипулирования указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo, позволяющий получить нужные для программы библиотеки в один клик. Для размещения библиотек поддерживается репозиторий crates.io. В подготовке нового выпуска приняли участие 160 разработчиков. Основные новшества: В разряд стабильных переведена возможность использования оператора "?" вместе с конструкцией "Option<тип>" по аналогии с ранее обеспеченной поддержкой "?" в блоках "Result<тип, выражение>". Оператор "?" проверяет значение и если результат отличается от заданного, осуществляется выход с возвратом кода ошибки. Например: fn try_option_none() -> Option<u8> { let val = None?; Some(val) } assert_eq!(try_option_none(), None); Типы с операцией Drop теперь можно применять в элементах const и static, что позволяет использовать в них значения, вычисляемые на этапе компиляции. Например: struct Foo { a: u32 } impl Drop for Foo { fn drop(&mut self) {} } const F : Foo = Foo { a : 0 }; static S : Foo = Foo { a : 0 }; Операции вида "T op= &T" теперь применимы ко встроенным числовым типам, например: let mut x = 2; let y = &8; x += y; // Ранее нужно было явно выполнять разыменование, указывая x += *y. Увеличена скорость компиляции в отладочном режиме; В Rustdoc теперь можно добавлять тесты, обрывающие компиляцию ( compile-fail); Прекращена поддержка целевой платформы le32-unknown-nacl в связи с переводом PNaCl в разряд устаревших (теперь рекомендуется использовать WebAssembly); Стабилизированы API From<Cow<str>> в Box<Error>, Hasher в {&mut Hasher, Box<Hasher>}, fmt::Debug в SplitWhitespace; В пакетном менеджере Cargo появилась возможность определения примеров, состоящих из нескольких файлов (для подобных примеров создаётся поддиректория с main.rs). Добавлена поддержка взаимодействия с внешними Git-репозиториями вендоров.