Критическая уязвимость в реализации функции memcpy для ARMv7 из состава Glibc

Исследователи безопасности из компании Cisco раскрыли детали уязвимости (CVE-2020-6096) в реализации предоставляемой в Glibc функции memcpy() для 32-разрядной платформы ARMv7. Проблема вызвана некорректной обработкой отрицательных значений параметра, определяющего размер копируемой области, из-за использования ассемблерных оптимизаций, манипулирующих знаковыми 32-разрядными целыми числами. Вызов memcpy() на системах ARMv7 с отрицательным размером приводит к некорректному сравнению значений и записи в области вне границ указанного буфера. Уязвимость может быть эксплуатирована для выполнения кода в ситуации, когда атакующий может организовать формирование отрицательного значения переменной, через которую передаётся размер копируемых данных (например, уход в минус будет при передаче более 2 ГБ данных, но в процессе атаки для выхода за пределы буфера нужно передать как минимум 4ГБ). Функция memcpy() активно применяется в приложениях, а процессоры ARMv7 распространены в автомобильных системах, мобильных, промышленных, потребительских, коммуникационных и встраиваемых устройствах, которые потенциально могут стать объектами атак с использованием Bluetooth, HD Radio/DAB, USB, CAN bus, Wi-Fi и других внешних источников данных (например, могут быть атакованы доступные по сети сервисы и приложения, принимающие входные данные без ограничения размера). В качестве примера приводится создание рабочего эксплоита для атаки на встроенный в автомобильные информационные системы http-сервер, доступный через автомобильную Wi-Fi сеть. Посторонний атакующий может эксплуатировать уязвимость в memcpy в данном сервере через передачу GET-запроса очень большого размера и получить root-доступ к системе. На 32-разрядных системах x86 проблема не проявляется, так как реализация memcpy для данной архитектуры корректно интерпретирует переменную с размером как беззнаковое целое значение с типом size_t (в написанной на ассемблере реализации для ARMv7 вместо size_t оно обрабатывается как signed integer). Исправление пока доступно в виде патча, который войдёт в состав августовском обновлении Glibc 2.32. Исправление сводится к замене использования ассемблерных инструкций, оперирующих знаковыми операндами (bge и blt), на беззнаковые аналоги (blo и bhs). Проблема пока не устранена в Debian 9 и 10 (в Debian 8 не проявляется), Fedora, Ubuntu, OpenEmbedded, Tizen (используется glibc). RHEL и SUSE проблема не затрагивает, так как они не поддерживают 32-разрядные системы ARMv7. Android не подвержен уязвимости, так как использует собственную реализацию libc (Bionic). В OpenWRT по умолчанию в большинстве сборок используется Musl, но в репозитории имеется и glibc.