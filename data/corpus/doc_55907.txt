Выпуск языка программирования Python 3.10

После года разработки представлен значительный выпуск языка программирования Python 3.10. Новая ветка будет поддерживаться в течение полутора лет, после чего ещё три с половиной года для неё будут формироваться исправления с устранением уязвимостей. Одновременно началось альфа-тестирование ветки Python 3.11 (в соответствии с новым графиком разработки работа над новой веткой начинается за пять месяцев до релиза предыдущей ветки и к моменту очередного релиза достигает стадии альфа-тестирования). Ветка Python 3.11 будет находиться на стадии альфа-выпусков в течение семи месяцев, во время которых будут добавляться новые возможности и производиться исправление ошибок. После этого в течение трёх месяцев будет проводиться тестирование бета-версий, во время которого добавление новых возможностей будет запрещено и всё внимание будет уделяться исправлению ошибок. Последние два месяца перед релизом ветка будет находиться на стадии кандидата в релизы, на которой будет выполнена финальная стабилизация. Среди добавленных в Python 3.10 новшеств: Реализованы операторы "match" и "case" для сопоставления с образцом, которые позволяют улучшить читаемость кода, упростить сопоставление произвольных Python-объектов и повысить надёжность кода благодаря возможности расширенной статической проверки типов. Реализация во многом напоминает оператор "match", предоставляемый в языках Scala, Rust и F#, который выполняет сравнение результата выполнения указанного выражения со списком образцов, перечисленных в блоках на основе оператора "case". def http_error(status): match status: case 400: return "Bad request" case 401|403|404: return "Not allowed" case 418: return "I'm a teapot" case _: return "Something else" Возможна распаковка объектов, кортежей, списков и произвольных последовательностей для привязки переменных на основе имеющихся значений. Допускается определение вложенных шаблонов, использование в шаблоне дополнительных условий "if", применение масок ("[x, y, *rest]"), маппинга связок ключ/значение (например, {"bandwidth": b, "latency": l} для извлечения значений "bandwidth" и "latency" из словаря), извлечения подшаблонов (оператор ":="), использования именованных констант в шаблоне. В классах возможна настройка поведения при сопоставлении при помощи метода "__match__()". from dataclasses import dataclass @dataclass class Point: x: int y: int def whereis(point): match point: case Point(0, 0): print("Origin") case Point(0, y): print(f"Y={y}") case Point(x, 0): print(f"X={x}") case Point(): print("Somewhere else") case _: print("Not a point") match point: case Point(x, y) if x == y: print(f"Y=X at {x}") case Point(x, y): print(f"Not on the diagonal") RED, GREEN, BLUE = 0, 1, 2 match color: case RED: print("I see red!") case GREEN: print("Grass is green") case BLUE: print("I'm feeling the blues :(") Предоставлена возможность использования круглых скобок в операторе with для разнесения на несколько строк определения коллекции контекстных менеджеров. В том числе разрешено оставлять запятую после финального контекстного менеджера в группе: with ( CtxManager1() as example1, CtxManager2() as example2, CtxManager3() as example3, ): ... Улучшено информирование о местоположении в коде ошибок, связанных с незакрытыми фигурными скобками и кавычками в строковых литералах. Например, при незакрытой фигурной скобке вместо информировании об ошибке синтаксиса в следом идущей конструкции, указатель теперь подсвечивает открывающуюся фигурную скобку и информирует об отсутствии закрывающего блока. File "example.py", line 1 expected = {9: 1, 18: 2, 19: 2, 27: 3, 28: 3, 29: 3, 36: 4, 37: 4, ^ SyntaxError: '{' was never closed Добавлены дополнительные специализированные сообщения об ошибках синтаксиса: отсутствие символа ":" перед блоком и в словарях, не выделение кортежа скобками, отсутствие запятой в списках, указание блока "try" без "except" и "finally", использование "=" вместо "==" в сравнениях, указание *-выражений в f-строках. Кроме того, обеспечено выделение всего проблемного выражения, а не только его начала, и более явное информирование о контексте ошибок, связанных с неверной расстановкой отступов. >>> def foo(): ... if lel: ... x = 2 File "<stdin>", line 3 x = 2 ^ IndentationError: expected an indented block after 'if' statement in line 2 В ошибках, вызванных опечатками в названии атрибутов и имён переменных в функции, обеспечен вывод рекомендации с правильным именем. >>> collections.namedtoplo Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: module 'collections' has no attribute 'namedtoplo'. Did you mean: namedtuple? Для отладочных инструментов и профилировщиков обеспечено указание в событиях трассировки точных номеров строк выполненного кода. Добавлена настройка sys.flags.warn_default_encoding для вывода предупреждения о потенциальных ошибках, связанных с обработкой в TextIOWrapper и open() файлов в кодировке UTF-8 без явного указания опции 'encoding="utf-8"' (по умолчанию используется кодировка ASCII). Также в новом выпуске предоставлена возможность указания значения 'encoding="locale"' для установки кодировки на основе текущей локали. В модуль typing, предоставляющий средства для задания аннотаций типов, добавлен новый оператор, позволяющий использовать синтаксис "X | Y" для выбора одного из типов (тип X или тип Y). def square(number: int | float) -> int | float: return number ** 2 эквивалентно ранее поддерживаемой конструкции: def square(number: Union[int, float]) -> Union[int, float]: return number ** 2 В модуль typing добавлен оператор Concatenate и переменная ParamSpec, которые позволяют передать дополнительную информацию для статической проверки типов при использовании Callable. В модуль typing также добавлены специальные значения TypeGuard для аннотирования функций защиты типов и TypeAlias для явного определения псевдонима типа. StrCache: TypeAlias = 'Cache[str]' # a type alias В функции zip() реализован необязательный флаг "strict", при указании которого осуществляется проверка на одинаковую длину перебираемых аргументов. >>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True)) [('a', 1), ('b', 2), ('c', 3)] >>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True)) Traceback (most recent call last): ... ValueError: zip() argument 2 is longer than argument 1 Предложены новые встроенные функции aiter() и anext() с реализацией асинхронных аналогов функциям iter() и next(). На 30-40% ускорена работа конструкторов str(), bytes() и bytearray() при работе с мелкими объектами. Сокращено число операций импорта в модуле runpy. Команда "python3 -m имя_модуля" теперь запускается в среднем в 1.4 раза быстрее за счёт сокращения импортируемых модулей с 69 до 51. В инструкции LOAD_ATTR задействован механизм кэширования отдельных опкодов, который позволил ускорить работу с обычными атрибутами до 36%, а со слотами до 44%. При сборке Python с опцией "--enable-optimizations" теперь включается режим "-fno-semantic-interposition", позволяющий по сравнению со сборкой с опцией "--enable-shared" ускорить работу интерпретатора до 30%. В модулях hashlib и ssl добавлена поддержка OpenSSL 3.0.0 и прекращена поддержка версий OpenSSL старше 1.1.1. Удалён старый парсер, на смену которому в прошлой ветке пришёл парсер PEG (Parsing Expression Grammar). Удалён модуль formatter. Из API asyncio удалён параметр loop.Удалены методы, ранее объявленные устаревшими. Удалены функции Py_UNICODE_str*, манипулирующие строками Py_UNICODE*. Объявлен устаревшим модуль distutils, который запланирован для удаления в Python 3.12. Вместо distutils рекомендовано использовать модули setuptools, packaging, platform, shutil, subprocess и sysconfig. В число устаревших и намеченных для удаления переведена структура wstr в PyUnicodeObject.