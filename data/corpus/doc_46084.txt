Уязвимость в ядре Linux, позволяющая получить права root

В ядре Linux выявлена уязвимость (CVE-2017-6074), позволяющая непривилегированному локальному пользователю выполнить код с правами root. Проблема устранена 17 февраля и проявляется во всех ядрах с поддержкой DCCP, начиная с 2.6.14 (октябрь 2005 г.) и вплоть до выпуска 4.9.11. Следует отметить, что уязвимости в реализации DCCP выявляются не в первый раз, похожие критические проблемы обнаруживались в 2008 и 2014 годах. Обнаруживший уязвимость исследователь сообщил о создании рабочего эксплоита, который будет опубликован через несколько дней, как только основные дистрибутивы выпустят обновление с устранением проблемы. Обновления пакетов пока выпущены для RHEL и Ubuntu. Проблема остаётся неисправленной в Debian, Fedora, openSUSE, SUSE (дополнение: спустя несколько часов вышли обновления для openSUSE и Debian). Уязвимость проявляется только в ядрах, собранных с опцией CONFIG_IP_DCCP, которая почти во всех дистрибутивах включена по умолчанию. Если DCCP собран в форме модуля ядра в качестве обходного пути защиты можно запретить загрузку этого модуля, который в обычных условиях загружается автоматически: echo "install dccp /bin/true" >> /etc/modprobe.d/disable-dccp.conf Уязвимость выявлена Андреем Коноваловым при fuzzing-тестировании ядра при помощи пакета syzkaller. Проблема вызвана двойным освобождением блока памяти в функции dccp_rcv_state_process (net/dccp/input.c) и может быть эксплуатирована при обработке специально оформленного пакета DCCP_PKT_REQUEST, переданного через сокет, открытый с опцией IPV6_RECVPKTINFO. В обычных условиях выделенный под пакет буфер dccp_skb освобождается вызовом __kfree_skb из функции dccp_rcv_state_process при успешном завершении функции dccp_v6_conn_request. При наличии флага IPV6_RECVPKTINFO адрес буфера dccp_skb дополнительно сохраняется в структуре ireq->pktopts и выставляется флаг использования буфера. Функция очистки в dccp_rcv_state_process вызывается независимо от флага, что может быть использовано для манипуляции с данными после их освобождения (use-after-free). В частности, атакующий может переписать произвольными данными содержимое другого объекта в ядре, используя технику "heap spraying". Если перезаписанный объект содержал указатели на функции, вызываемые в процессе работы, то атакующий может добиться выполнения своего кода на уровне ядра.