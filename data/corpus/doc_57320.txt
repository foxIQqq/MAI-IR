Представлен Pyston-lite, JIT-компилятор для штатного Python

Разработчики проекта Pyston, предлагающего высокопроизводительную реализацию языка Python, использующую современные технологии JIT-компиляции, представили расширение Pyston-lite с реализацией JIT-компилятора для CPython. Если Pyston является ответвлением от кодовой базы CPython и развивается обособленно, то Pyston-lite оформлен в виде универсального расширения, предназначенного для подключения к штатному интерпретатору Python (CPython). Pyston-lite позволяет использовать базовые технологии Pyston без замены интерпретатора, через установку дополнительного расширения при помощи пакетного менеджера PIP или Conda. Pyston-lite уже размещён в репозиториях PyPI и Conda и для установки достаточно выполнить команду "pip install pyston_lite_autoload" или "conda install pyston_lite_autoload -c pyston". Предложено два пакета: pyston_lite (непосредственно JIT) и pyston_lite_autoload (выполняет автоматическую подстановку JIT при запуске процесса Python). Возможно и программное управление включением JIT из приложения без установки модуля autoload, используя функцию pyston_lite.enable(). Несмотря на то, что Pyston-lite не охватывает все доступные в Pyston оптимизации, его использование позволяет повысить производительность примерно 10-25% по сравнению с обычным Python 3.8. В дальнейшем планируется перенос в Pyston-lite большинства оптимизаций, присутствующих в Pyston, а также расширение поддерживаемых версий CPython (первый выпуск поддерживает только Python 3.8). Из более глобальных планов отмечается совместная работа с командой CPython по реализации новых API для JIT, позволяющих более полно контролировать работу Python. Обсуждается включение предложенных изменений в ветку Python 3.12. В идеале рассматривается возможность переноса всей функциональности из Pyston в расширение, что позволит уйти от поддержания собственного форка CPython. Кроме Pyston-lite проектом также выпущено обновление полноценного пакета Pyston 2.3.4, в котором предложены новые оптимизации. В тесте pyperformance версия 2.3.4 быстрее выпуска 2.3.3 примерно на 6%. Общий выигрыш производительности по сравнению с CPython оценивается в 66%. Дополнительно можно отметить развиваемые в рамках цикла разработки CPython 3.11 оптимизации в основном проекте, которые в некоторых тестах позволили поднять производительность на 25%. Например, в CPython 3.11 повышена эффективность кэширования состояния байткода базовых модулей, что на 10-15% ускорит запуск скриптов. Значительно ускорен вызов функций и добавлены специализированные быстрые интерпретаторы типовых операций. Также ведётся работа по переносу некоторых оптимизации, подготовленных проектами Cinder и HotPy. Дополнительно в рамках проекта nogil ведётся работа над экспериментальным режимом сборки CPython без глобальной блокировки интерпретатора (GIL, Global Interpreter Lock), не допускающей параллельное обращение к разделяемым объектам из разных потоков, что мешает распараллеливанию операций на многоядерных системах. В качестве другого варианта решения проблемы с GIL развивается возможность привязки отдельного GIL к каждому интерпретатору, выполняемому внутри процесса (в одном процессе может выполняться несколько интерпретаторов, но эффективность их параллельного выполнения упирается в GIL).