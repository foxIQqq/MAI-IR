Релиз набора компиляторов LLVM 16.0

После шести месяцев разработки представлен релиз проекта LLVM 16.0 - GCC-совместимого инструментария (компиляторы, оптимизаторы и генераторы кода), компилирующего программы в промежуточный биткод RISC-подобных виртуальных инструкций (низкоуровневая виртуальная машина с многоуровневой системой оптимизаций). Сгенерированный псевдокод может быть преобразован при помощи JIT-компилятора в машинные инструкции непосредственно в момент выполнения программы. Основные улучшения в Clang 16.0: Применяемый по умолчанию стандарт C++/ObjC++ выставлен в gnu++17 (ранее применялся gnu++14), что подразумевает поддержку по умолчанию возможностей C++17 с расширениями GNU. Для возвращения прежнего поведения можно использовать опцию "-std=gnu++14". Реализованы расширенные возможности, связанные со стандартом C++20: Условно-тривиальные специальные функции-члены, захват структурированных привязок в лямбда-функциях, Оператор равенства внутри выражений, Возможность не указывать ключевое слово typename в некоторых контекстах, Допустимость агрегированной инициализации в скобках ("Aggr(val1, val2)"). Реализованы возможности, определённые в будущем стандарте C++2b: Разрешено размещение меток в конце составных выражений, static operator(), static operator[], Обеспечена совместимость с типом char8_t, Расширен спектр символов, допустимых для использования в "\N{...}", Добавлена возможность использования переменных, объявленных как "static constexpr", в функциях, объявленных как constexpr. Реализованы возможности, определённые в будущем Си-стандарте C2x: Для отключения предупреждения "-Wunused-label" разрешено применение атрибута "[[maybe_unused]]" к меткам, Разрешено размещение меток в любых местах внутри составных выражений, Добавлены операторы typeof и typeof_unqual, Новый тип nullptr_t и константа nullptr для определения нулевых указателей, которая может конвертироваться в любой тип указателей и представлять вариант NULL, не привязанный к целочисленным типам и типу void*. В режиме C2x разрешён вызов макроса va_start с переменным числом аргументов (variadic). В режимах соответствия стандартам C99, C11 и C17 опции "-Wimplicit-function-declaration" и "-Wimplicit-int" по умолчанию теперь приводят к выводу ошибки вместо предупреждения. Косвенное использование "void *" (например, "void func(void *p) { *p; }") в режиме C++ теперь приводит к генерации ошибки, по аналогии с ISO C++, GCC, ICC и MSVC. Указание битовых полей в качестве операндов инструкций (например, "__asm { mov eax, s.bf }") в ассемблерных inline-блоках в стиле Microsoft теперь приводит к генерации ошибки. Добавлена диагностика наличия отличающихся структур и объединений с одинаковыми именами в разных модулях. Расширены возможности, связанные с поддержкой OpenCL и OpenMP. Улучшена диагностика шаблонов C++, используемых в аргументах ядра OpenCL. Улучшена поддержка блока подстановки в очередь для AMDGPU. Ко всем функциям неявно добавлен атрибут nounwind. Улучшена поддержка встроенных функций. Предоставлена возможность использования переменной окружения CLANG_CRASH_DIAGNOSTICS_DIR для определения каталога, в который сохраняются диагностические данные об аварийных завершениях. Поддержка Unicode обновлена до спецификации Unicode 15.0. Разрешено применение некоторых математических символов в идентификаторах, таких как "₊" (например, "double xₖ₊₁"). Добавлена поддержка загрузки нескольких файлов конфигурации (вначале загружаются файлы конфигурации по умолчанию, а затем заданные через флаг "--config=", который теперь можно указывать несколько раз). Изменён порядок загрузки файлов конфигурации по умолчанию: clang вначале пытается загрузить файл <triple>-<driver>.cfg, а если он не найден пытается загрузить два файла <driver>.cfg и <triple>.cfg. Для отключения загрузки файлов конфигурации по умолчанию добавлен флаг "--no-default-config". Для обеспечения повторяемых сборок предоставлена возможность замены значений текущей даты и времени в макросах __DATE__, __TIME__ и __TIMESTAMP__ на время, заданное в переменной окружения SOURCE_DATE_EPOCH. Для проверки наличия встроенных функций (builtin), которые могут быть использованы в контексте констант, добавлен макрос "__has_constexpr_builtin". Добавлен новый флаг компиляции "-fcoro-aligned-allocation" для выровненного распределения кадров сопрограмм. В флаге "-fstrict-flex-arrays=" реализована поддержка третьего уровня проверки гибкого элемента-массива в структурах (Flexible Array Members, массив неопределённого размера в конце структуры). На третьем уровне только размер "[]" (например, "int b[]") обрабатывается как гибкий массив, а размер "[0]" (например, "int b[0]") - нет. Добавлен флаг "-fmodule-output" для включения однофазной модели компиляции стандартных модулей C++. Добавлен режим "-Rpass-analysis=stack-frame-layout", позволяющий диагностировать проблемы с раскладной стековых кадров. Добавлен новый атрибут __attribute__((target_version("cpu_features"))) и расширена функциональность атрибута __attribute__((target_clones("cpu_features1","cpu_features2",...))) для выбора определённых версий функций, предоставляемых CPU AArch64. Расширены средства диагностики: Добавлено предупреждение "-Wsingle-bit-bitfield-constant-conversion" для определения неявного усечения при присвоении единицы одноразрядному знаковому битовому полю. Расширена диагностика неинициализированных constexpr-переменных. Добавлены предупреждения "-Wcast-function-type-strict" и "-Wincompatible-function-pointer-types-strict" для выявления потенциальных проблем при приведении типов функций. Добавлена диагностика использования некорректных или зарезервированных имён модулей в блоках экспорта. Улучшено выявление пропущенных ключевых слов "auto" в определениях. В реализации предупреждения "-Winteger-overflow" добавлены проверки дополнительных ситуаций, приводящих к переполнениям. Реализована поддержка архитектуры набора команд LoongArch (-march=loongarch64 или -march=la464), применяемой в процессорах Loongson 3 5000 и реализующей новый RISC ISA, похожий на MIPS и RISC-V. Основные новшества LLVM 16.0: В коде LLVM разрешено использование элементов, определённых в стандарте C++17. Повышены требования к окружению для сборки LLVM. Сборочный инструментарий теперь должен поддерживать стандарт C++17, т.е. для сборки необходимы как минимум GCC 7.1, Clang 5.0, Apple Clang 10.0 или Visual Studio 2019 16.7. В бэкенд для архитектуры AArch64 добавлена поддержка CPU Cortex-A715, Cortex-X3 и Neoverse V2, ассемблера для RME MEC (Memory Encryption Contexts), расширений Armv8.3 (Complex Number) и мултиверсионирования (Function Multi Versioning). В бэкенде LLVM для архитектуры ARM прекращена поддержка целевых платформ Armv2, Armv2A, Armv3 и Armv3M, генерация корректного кода для которых не гарантировалась. В clang в опции "-march" прекращена поддержка значений armv2, armv2A, armv3 и armv3M. Добавлена возможность генерации кода для инструкций работы с комплексными числами. В бэкенд для архитектуры X86 добавлена поддержка архитектур набора команд (ISA) AMX-FP16, CMPCCXADD, AVX-IFMA, AVX-VNNI-INT8, AVX-NE-CONVERT. Добавлена поддержка инструкций RDMSRLIST, RMSRLIST и WRMSRNS. Реализованы опции "-mcpu=raptorlake", "-mcpu=meteorlake", "-mcpu=emeraldrapids", "-mcpu=sierraforest", "-mcpu=graniterapids" и "-mcpu=grandridge". Добавлена официальная поддержка платформы LoongArch. Улучшены бэкенды для архитектур MIPS, PowerPC и RISC-V В отладчик LLDB добавлена поддержка отладки 64-разрядных исполняемых файлов для архитектуры LoongArch. Улучшена обработка отладочных символов COFF. Обеспечено отсеивание дубликатов DLL в списке загружаемых Windows-модулей. В библиотеке Libc++ основная работа была сосредоточена на реализации поддержки новых возможностей стандартов C++20 и C++23. В компоновщике LDD значительно сокращено время связывания за счёт распараллеливания операций сканирования перемещений адресов и инициализации секций. Добавлена поддержка сжатия секций с использованием алгоритма ZSTD.