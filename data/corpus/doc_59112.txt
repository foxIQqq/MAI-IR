Доступен язык программирования Julia 1.9

Опубликован релиз языка программирования Julia 1.9, сочетающего такие качества как высокая производительность, поддержка динамической типизации и встроенные средства для параллельного программирования. Синтаксис Julia близок к MATLAB с заимствованием некоторых элементов из Ruby и Lisp. Метод манипуляции строками напоминает Perl. Код проекта распространяется под лицензией MIT. Ключевые особенности языка: Высокая производительность: одной из ключевых целей проекта является достижение производительности близкой к программам на языке Си. Компилятор Julia основан на наработках проекта LLVM и генерирует эффективный нативный машинный код для многих целевых платформ; Поддержка различных парадигм программирования, включая элементы объектно-ориентированного и функционального программирования. Стандартная библиотека предоставляет в том числе функции для асинхронного ввода/вывода, управления процессами, ведения логов, профилирования и управления пакетами; Динамическая типизация: язык не требует явного определения типов для переменных по аналогии со скриптовыми языками программирования. Поддерживается интерактивный режим работы; Опциональная возможность явного указания типов; Синтаксис, превосходно подходящий для численных вычислений, научных расчётов, систем машинного обучения и визуализации данных. Поддержка многих числовых типов данных и средств для распараллеливания вычислений. Возможность прямого вызова функций из библиотек на языке Си без дополнительных прослоек. Основные изменения в Julia 1.9: Новые возможности языка Разрешено выполнение присвоений в другом модуле с помощью "setproperty!(::Module, ::Symbol, x)". Разрешено множественное присваивание не в финальной позиции. Например строка "a, b..., c = 1, 2, 3, 4" будет обработана как "a = 1; b..., = 2, 3; c = 4". Это обрабатывается через Base.split_rest. Литералы отдельных символов теперь поддерживают тот же синтаксис, что и строковые литералы; т.е. синтаксис может представлять недопустимые последовательности UTF-8, как это разрешено типом Char. Добавлена поддержка спецификации Unicode 15. Вложенные комбинации кортежей и именованные кортежи символов теперь можно использовать в качестве параметров типа. Новые встроенные функции "getglobal(::Module, ::Symbol[, order])" и "setglobal!(::Module, ::Symbol, x[, order])" для чтения и записи исключительно в глобальные переменные. Метод getglobal теперь должен быть предпочтительнее для доступа к глобальным переменным, чем метод getfield. Изменения в языке Макрос "@invoke", представленный в версии 1.7, теперь экспортируется и доступен для использования. Кроме того, теперь он использует метод "Core.Typeof(x)", а не "Any" в случае, когда аннотация типа опущена для аргумента "x". Это необходимо для того, чтобы типы, передаваемые в качестве аргументов, обрабатывались правильно. Включено экспортирование функции "invokelatest" и макроса "@invokelatest", появившихся в версии 1.7. Улучшения компилятора/среды выполнения Значительно сокращено время до первого выполнения (TTFX - Time to first execution). Предварительная компиляция пакета теперь сохраняет машинный код в "pkgimage", что означает, что код, сгенерированный в процессе предварительной компиляции, не потребует повторной компиляции после загрузки пакета. Использование режима pkgimages можно отключить с помощью опции "--pkgimages=no". Исправлена известная проблема квадратичной сложности выведения типов, и в целом вывод использует меньше памяти. Некоторые граничные случаи с автоматически сгенерированными длинными функциями (например, ModelingToolkit.jl с уравнениями в частных производных и большими причинно-следственными моделями) компилируются намного быстрее. Вызовы с аргументами без конкретных типов теперь могут быть оптимизированы методом Union-splitting для внедрения или статического разрешения, даже если существует несколько разнотиповых кандидатов для диспетчеризации. Это может улучшить производительность в определённых ситуациях, когда типы объектов не полностью статически разрешены, за счёт статического разрешения сайтов вызова "@nospecialize-d" и избежания повторной компиляции. Все варианты использования макроса @pure в модуле Base заменены на Base.@assume_effects. Вызовы invoke(f, invokesig, args...) с менее конкретными типами чем обычно используются для f(args...) больше не приводят к перекомпиляции пакета. Изменения параметров командной строки В Linux и Windows параметр "--threads=auto" теперь пытается определить доступное количество процессоров на основе CPU affinity, маска которого обычно устанавливается в средах высокопроизводительных вычислений и облачных средах. Отключён параметр "--math-mode=fast", вместо которого рекомендуется использовать макрос "@fastmath", имеющий чётко определённую семантику. Параметр "--threads" теперь имеет формат "auto | N[,auto|M]", где M указывает количество создаваемых интерактивных потоков (в настоящее время auto означает 1). Добавлена опция "--heap-size-hint=<size>", устанавливающая порог, после которого начинается активная сборку мусора. Размер может быть указан в байтах, килобайтах (1000 КБ), мегабайтах (300 МБ) или гигабайтах (1,5 ГБ). Изменения в многопоточности "Threads.@spawn" теперь имеет опциональный первый аргумент со значением ":default" или ":interactive". Интерактивная задача требует малой задержки отклика и рассчитана быть короткой или часто выполняемой. Интерактивные задачи будут выполняться в интерактивных потоках, если они указаны при запуске Julia. Потоки, запущенные вне среды выполнения Julia (например, из C или Java), теперь могут вызывать код Julia, используя "jl_adopt_thread". Это происходит автоматически при вводе кода Julia через "cfunction" или точку входа "@ccallable". Как следствие, количество потоков теперь может изменяться во время выполнения. Новые библиотечные функции Новая функция "Iterators.flatmap". Новая функция "pkgversion(m::Module)" для получения версии пакета, который загрузил данный модуль, аналогично "pkgdir(m::Module)". Новая функция "stack(x)", которая обобщает "reduce(hcat, x::Vector{<:Vector})" до любой размерности и допускает любой итератор итераторов. Метод "stack(f, x)" обобщает "mapreduce(f, hcat, x)" и является более эффективным. Новый макрос для анализа выделенной памяти "@allocations", аналогичный "@allocated", за исключением того, что возвращает количество операций выделения памяти, а не общий размер выделенной памяти. Новые возможности библиотеки "RoundFromZero" теперь работает для типов, отличных от "BigFloat". "Dict" теперь можно уменьшить вручную с помощью "sizehint!". "@time" теперь указывает отдельно процент времени, потраченного на перекомпиляцию недействительных методов. Изменения в стандартной библиотеке Устранена проблема параллельного доступа в методах итерации для Dict и других производных объектов, таких как keys(::Dict), values(::Dict) и Set. Эти методы итерации теперь можно вызывать для Dict или Set параллельно для неограниченного количества потоков при условии, что нет действий, изменяющих словарь или набор. Отрицание функции-предиката "!f" теперь возвращает составную функцию "(!) ∘ f" вместо анонимной функции. Функции среза размерности теперь работают в нескольких измерениях: "eachslice", "eachrow" и "eachcol" возвращают объект "Slices", который позволяет выполнять диспетчеризацию для предоставления более эффективных методов. В общедоступный API добавлен макрос "@kwdef". Исправлена проблема с порядком операций в "fld1". Сортировка теперь всегда стабильна по времени (переработан QuickSort). "Base.splat" теперь экспортируется. Возвращаемое значение представляет собой тип "Base.Splat", а не анонимную функцию, что позволяет его красиво выводить. Менеджер пакетов "Package Extensions": поддержка загрузки фрагмента кода из других пакетов, загружаемых в сеансе Julia. Применение сходное с пакетом "Requires.jl", но поддерживается предварительная компиляция и совместимость настроек. Библиотека LinearAlgebra Из-за риска путаницы с поэлементным делением удалены методы "a / b" и "b \ a" со скаляром "a" и вектором "b", которые были эквивалентны "a * pinv(b)". Для вызова BLAS и LAPACK теперь применяется "libblastrampoline (LBT)". OpenBLAS поставляется по умолчанию, но сборка образа системы с другими библиотеками BLAS/LAPACK не поддерживается. Вместо этого рекомендуется использовать механизм LBT для замены BLAS/LAPACK на иной имеющийся комплект библиотек. "lu" поддерживает новую стратегию поворота матрицы "RowNonZero()", которая выбирает первый ненулевой элемент поворота для использования с новыми арифметическими типами и для учебных целей. "normalize(x, p=2)" теперь поддерживает любое нормированное векторное пространство "x", включая скаляры. Количество потоков BLAS по умолчанию теперь равно количеству потоков CPU на архитектуре ARM и половине числа потоков CPU на других архитектурах. Printf: Для лучшей читаемости переработаны сообщения об ошибках для строк неправильного формата. Profile: Новая функция "Profile.take_heap_snapshot(file)", которая записывает файл в формате ".heapsnapshot" на основе JSON, поддерживаемом в Chrome. Random: randn и randexp теперь работают для любого типа AbstractFloat, определяющего rand. REPL Нажатие комбинации клавиш "Alt-e" теперь открывает текущий ввод в редакторе. Содержимое (если оно изменено) будет выполнено при выходе из редактора. Текущий контекст модуля, активный в REPL, можно изменить (по умолчанию это Main) с помощью функции "REPL.activate(::Module)" или путём ввода модуля в REPL и нажатия комбинации клавиш "Alt-m". Режим "нумерованной подсказки", который выводит числа для каждого входа и выхода и сохраняет оценённые результаты в Out, может быть активирован с помощью "REPL.numbered_prompt!()". Автодополнение с помощью табуляции отображает доступные аргументы ключевого слова. SuiteSparse: Код для решателя "SuiteSparse" перемещён в "SparseArrays.jl". Решатели теперь повторно экспортируются "SuiteSparse.jl". SparseArrays Решатели "SuiteSparse" теперь доступны как подмодули "SparseArrays". Режимы защиты потоков UMFPACK и CHOLMOD улучшены за счет исключения глобальных переменных и использования блокировок. Многопоточный "ldiv!" объектов UMFPACK теперь можно выполнять безопасно. Экспериментальная функция "SparseArrays.allowscalar(::Bool)" позволяет отключать или включать скалярное индексирование разрежённых массивов. Эта функция предназначена для обнаружения случайного скалярного индексирования объектов "SparseMatrixCSC", что является распространённым источником проблем с производительностью. Новый отказоустойчивый режим для наборов тестов, который досрочно завершает тестовый запуск в случае сбоя или ошибки. Устанавливается либо через "@testset kwarg failfast=true", либо "export JULIA_TEST_FAILFAST=true". Подобное бывает необходимо в запусках CI для досрочного получения сообщений об ошибке. Dates: Пустые строки больше не анализируются неправильно как допустимые значения "DateTime", "Dates" или "Times" и вместо этого выдают ошибку "ArgumentError" в конструкторах и синтаксическом анализе, в то время как "tryparse" ничего не возвращает. Пакет Distributed Конфигурация пакета (активный проект, "LOAD_PATH", "DEPOT_PATH") теперь распространяется при добавлении локальных рабочих процессов (например, с помощью "addprocs(N::Int)" или с помощью флага командной строки "--procs=N"). "addprocs" для локальных рабочих процессов теперь принимает аргумент с именем "env" для передачи переменных окружения рабочим процессам. Unicode: "graphemes(s, m:n)" возвращает подстроку от m-й до n-й графемы в "s". Пакет DelimitedFiles вынесен из системных библиотек и теперь распространяется как отдельный пакет, который должен быть явно установлен для использования. Внешние зависимости В Linux автоматически определяется версия системной библиотеки libstdc++ и если она новее, то загружается. Старое поведение загрузки, встроенной libstdc++ независимо от версии системы, можно восстановить, установив переменную окружения "JULIA_PROBE_LIBSTDCXX=0". Из бинарного файла julia удалён "RPATH", что может привести в Linux к поломке библиотек, которым не удалось определить переменную "RUNPATH". Улучшения инструментов: Вывод "MethodError" и методов (например, из "methods(my_func)") теперь оформлен и раскрашен в соответствии с принципом вывода методов при трассировке стека.