Выпуск языка программирования Rust 1.33

Состоялся релиз языка системного программирования Rust 1.33, развиваемого проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime. Автоматическое управление памятью в Rust избавляет разработчика от манипулирования указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo, позволяющий получить нужные для программы библиотеки в один клик. Для размещения библиотек поддерживается репозиторий crates.io. В подготовке нового выпуска приняли участие 163 разработчика. Основные новшества: Расширены возможности функций, определённых с использованием выражения "const fn", которые могут вызываться не только как обычные функции, но и использоваться в любом контексте вместо констант. Данные функции вычисляются на этапе компиляции, а не в ходе выполнения, поэтому на них накладываются определённые ограничения, такие как запрет булевых операторов ("&&" и "||") и возможность чтения только из констант. В новом выпуске внутри функций "const fn" добавлена возможность вызова других функций, определённых через выражение "const unsafe" (ранее допускался только вызов функций, определённых через "const fn"). Также обеспечена поддержка инициализированных присвоений let (например, "let mut x = 1" и "let mut x = 1"), явно типизированных шаблонов вида "const fn foo((x, y): (u8, u8)) { ... }", операторов присвоения ("x=y" и "x += y") и обособленных выражений (например, "3;"). Указанные изменения позволили применить признак "const" для многих функций и методов стандартной библиотеки, включая overflowing_{add, sub, mul, shl, shr}, rotate_left, rotate_right, wrapping_{add, sub, mul, shl, shr}, is_positive, is_negative, get, count_ones, count_zeros, leading_zeros, trailing_zeros, swap_bytes, from_be, from_le, to_be, to_le и Ipv4Addr::new; Представлена концепция закрепления объектов в определённой области памяти (Pinning), основанная на использовании типа std::pin::Pin<P> и типажа (trait) std::marker::Unpin. Закрепление гарантирует, что объекты не будут перемещены и их размещение в памяти будет постоянным; Добавлена возможность импортирования элементов как "_", что позволяет импортировать реализации (impl) без определения отдельного имени в пространстве имён. Например "use std::io::Read as _;" Добавлен атрибут "cfg(target_vendor)", позволяющий выполнить код в привязке к целевой платформе, например "#[cfg(target_vendor="apple")] fn main() { println!("Hello Apple!"); }"; Реализована возможность указания нескольких условий в выражениях "if let" и "while let", например, "if let Creature::Crab(name) | Creature::Person(name) = state {"; В разряд стабильных переведена новая порция API, в том числе стабилизированы методы unix::FileExt::read_exact_at, unix::FileExt::write_all_at, Option::transpose, Result::transpose, convert::identity, pin::Pin, marker::Unpin, marker::PhantomPinned, Vec::resize_with, VecDeque::resize_with, Duration::as_millis, Duration::as_micros и Duration::as_nanos; В пакетный менеджер Cargo добавлена поддержка пересборки пакетов (crate) в случае изменения файла во время начальной сборки; В репозитории Crates.io для публикации новых пакетов теперь обязательно требуется подтверждение своего email; В компиляторе повышены требования к минимальной версии LLVM (теперь требуется 6.0) и добавлена поддержка архитектуры PowerPC64 во FreeBSD.