Опубликован стандарт параллельного программирования OpenMP 5.0

После трёх лет разработки опубликован набор спецификаций OpenMP 5.0 (Open Multi-Processing), определяющих API и способы применения методов параллельного программирования для языков Си, Си++ и Фортран на многоядерных и гибридных (CPU+GPU/DSP) системах с общей памятью и блоками векторизации (SIMD). Начальная реализация OpenMP 5.0 уже включена в кодовую базу GCC, на основе которой развивается ветка GCC 9. Отдельные элементы OpenMP 5.0 также будут включены в следующий выпуск LLVM/Clang 8.0. Основные новшества OpenMP 5.0: Полная поддержка специализированных аппаратных ускорителей. В том числе реализованы: Механизмы, использующие унифицированную разделяемую память между хост-системой и устройствами сопроцессора; Возможность использования специфичных для определённых устройств реализаций функций; Улучшенное управление неявным отображением данных (data mapping); Возможность смены устройств-ускорителей не прерывая работу; Поддержка обратного выделения вычислительных ресурсов ускорителям (reverse offload); Поддержка неявной генерации функций; Возможность упрощённого копирования объектно-ориентированных структур данных. Два новых программных интерфейса для разработки внешних инструментов отладки и анализа производительности; Поддержка последних версий стандартов языков C, C++ и Fortran: C11, C++17 и Fortran 2008; Поддержка описательных конструкций циклов (descriptive loop) , позволяющих компилятору оптимизировать операции в цикле, не привязываясь к определённой реализации. Новые конструкции циклов предоставляют компилятору больше свободы в выборе оптимальной реализации для специфичной целевой системы; Многоуровневые системы памяти. Предоставлены механизмы распределения памяти, позволяющие размещать данные в различных типах памяти, например, отличающихся пропускной способностью. Новые возможности управления памятью также упрощают работу с современными высокопроизводительными NUMA-системами; Улучшена переносимость. Директива "declare variant" и метадирективы (блок "metadirective", дающий возможность определить несколько вариантов директив, выбираемых в зависимости от контекста) позволяют разработчикам повысить эффективность портирования, адаптируя прагмы OpenMP и пользовательский код на стадии компиляции.