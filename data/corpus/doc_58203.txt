Доступен Wasmer 3.0, инструментарий для создания приложений на базе WebAssembly

Представлен третий значительный выпуск проекта Wasmer, развивающего runtime для выполнения модулей WebAssembly, который можно использовать для создания универсальных приложений, способных выполняться в разных операционных системах, а также для изолированного выполнения кода, не заслуживающего доверия. Код проекта написан на языке Rust и распространяется под лицензией MIT. Возможность запуска одного приложения на разных платформах обеспечивается благодаря компиляции кода в низкоуровневый промежуточный код WebAssembly, который может запускаться в любых ОС или встраиваться в программы на других языках программирования. Программы представляют собой легковесные контейнеры, в которых выполняется псевдокод WebAssembly. Данные контейнеры не привязаны к операционной системе и могут включать код, изначально написанный на любом языке программирования. Для компиляции в WebAssembly может использоваться инструментарий Emscripten. Для трансляции WebAssembly в машинный код текущей платформы поддерживается подключение разных бэкендов компиляции (Singlepass, Cranelift, LLVM) и движков (задействование JIT или генерация машинного кода). Приложения изолированы от основной системы в sandbox-окружении и имеют доступ только к заявленной функциональности (механизм безопасности на основе управления возможностями - для действий с каждым из ресурсов (файлы, каталоги, сокеты, системные вызовы и т.п.) приложению должны быть даны соответствующие полномочия). Управление доступом и взаимодействие с системой обеспечивается при помощи API WASI (WebAssembly System Interface), предоставляющем программные интерфейсы для работы с файлами, сокетами и другими функциями, предоставляемыми операционной системой. Платформа позволяет добиться производительности выполнения приложений, близкой к выполнению родных сборок. При помощи Native Object Engine для WebAssembly-модуля можно сгенерировать машинный код ("wasmer compile --native" для генерации предкомпилированных объектных файлов .so, .dylib и .dll), для запуска которого требуется минимальный runtime, но сохраняются все возможности sandbox-изоляции. Возможна поставка предкомпилированных программ со встроенным Wasmer. Для создания надстроек и дополнений предлагаются Rust API и Wasm-C-API. Для запуска WebAssembly-контейнера достаточно установить в системе runtime Wasmer, который поставляется без внешних зависимостей ("curl https://get.wasmer.io -sSfL | sh"), и запустить необходимый файл ("wasmer test.wasm"). Программы распространяются в форме обычных WebAssembly-модулей, для управления которыми можно использовать пакетный менеджер WAPM. Wasmer также доступен в форме библиотеки, которую можно использовать для встраивания кода WebAssembly в программы на языках Rust, С/C++, C#, D, Python, JavaScript, Go, PHP, Ruby, Elixir и Java. Основные изменения в Wasmer 3.0: Добавлена возможность создания родных исполняемых файлов для любых платформ. Полностью переработана команда "wasmer create-exe", которая позволяет преобразовать файл с промежуточным кодом WebAssembly в самодостаточные исполняемые файлы для платформ Linux, Windows и macOS, которые могут работать без установки самого Wasmer. Предоставлена возможность запуска WAPM-пакетов, размещённых в каталоге wapm.io, при помощи команды "wasmer run". Например, выполнение "wasmer run python/python" приведёт к загрузке из репозитория wapm.io пакета python и его запуску. Полностью переработан Wasmer Rust API, в котором изменён стиль работы с памятью и обеспечена возможность безопасного сохранения объектов Wasm в структуре Store. Предложена новая структура MemoryView, позволяющая читать и записывать данные в линейную область памяти. Реализован набор компонентов wasmer-js для запуска Wasmer в web-браузере и взаимодействия с ним из JavaScript, используя библиотеку wasm-bindgen. Упрощены движки. Вместо раздельных движков для JIT, динамического и статического связывания (Universal, Dylib, StaticLib) теперь предлагается один общий движок и загрузка и сохранение кода в котором управляется на уровня выставления параметров. Для десериализации артефактов задействован фреймворк rkyv, обеспечивающий работу в режиме zero-copy, т.е. не требующий выделения дополнительной памяти и выполняющий десериализацию только с использованием изначально предоставленного буфера. Применение rkyv позволило значительно повысить скорость запуска. Улучшен однопроходный компилятор Singlepass, в котором появилась поддержка функций с несколькими аргументами (multi-value), повышена надёжность работы и добавлена поддержка кадров обработки исключений. Улучшена реализация API WASI (WebAssembly System Interface). Решены проблемы в программном интерфейсе WASI для работы с файловой системой. Внутренние типы переработаны с использованием WAI (WebAssembly Interfaces), что в будущем позволит воплотить в жизнь серию новых возможностей.