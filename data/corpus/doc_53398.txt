Выпуск языка программирования Rust 1.45

Опубликован релиз 1.45 языка системного программирования Rust, основанного проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime. Автоматическое управление памятью в Rust избавляет разработчика от ошибок при манипулировании указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo, позволяющий получить нужные для программы библиотеки в один клик. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Устранена давняя недоработка при выполнении преобразований между целыми числами и числами с плавающей запятой. Так как компилятор Rust использует LLVM в качестве бэкенда, операции преобразования типов выполнялись через инструкции промежуточного кода LLVM, такие как fptoui, в которых имеется одна существенная особенность - неопределённое поведение, если результирующее значение не умещается в целевой тип. Например, при преобразовании вещественного значения 300 с типом f32 в целый тип u8 результат непредсказуем и может отличаться на разных системах. Проблема в том, что подобная особенность проявляется в коде, не помеченном как "unsafe". Начиная с Rust 1.45 поведение при переполнении размера типа жёстко регламентировано, а операция преобразования "as" выполняет проверку на переполнение и приводит преобразуемое значение к максимальному или минимальному значению целевого типа (для вышеотмеченного примера значение 300 будет преобразовано в 255). Для отключения подобных проверок предусмотрены дополнительные вызовы API "{f64, f32}::to_int_unchecked", работающие в режиме unsafe. fn cast(x: f32) -> u8 { x as u8 } fn main() { let too_big = 300.0; let too_small = -100.0; let nan = f32::NAN; let x: f32 = 1.0; let y: u8 = unsafe { x.to_int_unchecked() }; println!("too_big_casted = {}", cast(too_big)); // на выходе 255 println!("too_small_casted = {}", cast(too_small)); // на выходе 0 println!("not_a_number_casted = {}", cast(nan)); // на выходе 0 } Стабилизировано использование процедурных макросов, похожих на функции, в выражениях, шаблонах и утверждениях. Ранее подобные макросы могли вызываться не везде, а только в определённых частях кода (отдельным вызовом, не переплетающимся с другим кодом). Расширение способов вызова макросов, похожих на функции, было одним из требовалось для обеспечения работы web-фреймворка Rocket в стабильных выпусках Rust. Ранее для достижения дополнительной гибкости задания обработчиков в Rocket требовалось включение экспериментальной возможности "proc_macro_hygiene", недоступной в стабильных версиях Rust. Теперь указанная функциональность встроена в стабильные выпуски языка. Разрешено использование диапазонов с типом "char" для перебора значений диапазона (ops::{Range, RangeFrom, RangeFull, RangeInclusive, RangeTo}): for ch in 'a'..='z' { print!("{}", ch); } println!(); // Будет выведено "abcdefghijklmnopqrstuvwxyz" В разряд стабильных переведена новая порция API, в том числе стабилизированы Arc::as_ptr, BTreeMap::remove_entry, Rc::as_ptr, rc::Weak::as_ptr, rc::Weak::from_raw, rc::Weak::into_raw, str::strip_prefix, str::strip_suffix, sync::Weak::as_ptr, sync::Weak::from_raw, sync::Weak::into_raw, char::UNICODE_VERSION, Span::resolved_at, Span::located_at, Span::mixed_site, unix::process::CommandExt::arg0. В компилятор rustc добавлена поддержка переопределения различных возможностей целевой платформы при помощи флага "target-feature", например, "-C target-feature=+avx2,+fma". Также добавлены новые флаги: "force-unwind-tables" для генерации "раскрученных" (unwind) таблиц вызовов, независимо от стратегии обработки краха; "embed-bitcode" для управления включением биткода LLVM в генерируемые rlibs. Флаг "embed-bitcode" по умолчанию задействован в Cargo для оптимизации времени сборки и потребления дискового пространства. Обеспечен третий уровень поддержи для платформ mipsel-sony-psp и thumbv7a-uwp-windows-msvc. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования и публикации официальных сборок. Дополнительно можно отметить рассказ о создании простейшего приложения на языке Rust, стартующего при помощи системного загрузчика и готового к самодостаточной загрузке вместо операционной системы. Статья является первой в серии, посвящённой демонстрацией приёмов, востребованных при низкоуровневом программировании и разработке ОС.