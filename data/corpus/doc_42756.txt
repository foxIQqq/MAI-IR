Релиз компилятора D версии 2.068.0

Вышла версия 2.068 кроссплатформенного компилятора языка программирования D: Digital Mars D (DMD). D — это компилируемый в машинный код язык из семейства си‐подобных, включающий в себя опциональный сборщик мусора, мощную систему метапрограммирования, удобные шаблоны, исполнение D-кода во время компиляции, систему модулей вместо «include». D позволяет без труда использовать библиотеки на языке C, а также имеет возможность использовать некоторые C++-библиотеки и ObjC-библиотеки. Компилятор DDMD поддерживает системы GNU/Linux, Windows, OS X, FreeBSD, и архитектуры x86, x86_64, x64. Основные изменения и новшества версии 2.068: Изменения в компиляторе: Новый ключ командной строки "-profile=gc" позволяет профилировать выделение памяти. Блоки юниттестов (unittest) больше не парсятся, пока не задан ключ командной строки "-unittest". Сгенерированые компилятором деструкторы и постблиттеры (postblitter) теперь доступны по именам «__xdtor» и «__xpostblit». Изменения в языке: Добавлена директива pragma(inline), для указания компилятору на то, что некоторые функции следует инлайнить всегда «pragma(inline, true)» или использовать для них обычные правила «pragma(inline, false)». Для функций, тип возвращаемого значения у которых указан как auto, компилятор теперь будет автоматически выводить атрибуты pure, @safe, nothrow, @nogc (раньше это делалось только для шаблонов). Парcер теперь позволяет использовать индексированные кортежи (tuple - структура, существующая только во время компиляции и позволяющая хранить типы) как декларации типов: «T[0].S myvar;». Подробнее см. в http://dlang.org/changelog.html#index-type-followed-ident. Аргументы шаблонов теперь могут быть выведены на основе аргументов функции: void previously(T=int) (T t=0) {} // раньше необходимо было так void now(T) (T t=0) {} // а теперь можно и так Некоторые ошибочные приведения типов, которые раньше определялись на стадии генерации кода, теперь определяются на стадии семантического анализа. Это улучшило сообщения об ошибках и работу CTFE-движка, ответственного за исполнение D-кода во время компиляции. Изменения в стандартной библиотеке: Множество функций теперь работают с InputRange и OutputRange (абстракциями для получения входных данных и выдачи выходных данных) вместо массивов. Модуль std.typetuple был переименован в std.meta. Для обеспечения совместимости std.typetuple сохранён в виде псевдонима std.meta. Сущность TypeTuple была переименована в AliasSeq. Для обеспечения совместимости сохранён псевдоним. Добавлен CTFE-шаблон hexString, который должен заменить встроенные в язык hex-строки: x"304A314B» // было hexString!»304A314B» // стало Добавлена CTFE-функция hasUDA для проверки наличия у символов UDA (определяемых пользователем атрибутов времени компиляции). Вызовы GC API теперь могут быть отдельно профилированы. Переписана работа с синхронизированными (synchronized) объектами в druntime. Починена ошибка с гонкой во время инициализации мьютекса. Сгенерированный вручную интерфейсный файл object.di больше не нужен, компилятор использует оригинальный object.d. Новая реализация AA (ассоциативных массивов), с новой схемой разрешения конфликтов при совпадении хэшей. Чуть быстрее и лучше дружит с кэшем процессоров. Улучшена работа встроенного инструмента code coverage. Функция executeShell теперь игнорирует переменную среды SHELL и всегда использует sh. Функция byLine (чтение текстового файла построчно) была переписана и значительно ускорена (до трёх раз). В пакет std.algorithm добавлены предикаты ordered и strictlyOrdered для проверки, отсортирована ли последовательность значений. Шаблон RefCounted использует новый атрибут return, чтобы указать компилятору, что внутренний объект шаблона не может быть использован вне лексического блока (espace checking). Также следует отметить, что в будущем релизе 2.069 используемый сейчас фронтэнд, написанный на подмножестве языка C++, будет заменён фронтэндом, написаным на языке D. Фронтэнд на языке D делается при помощи полуавтоматической трансляции C++ кода, поэтому до версии 2.069 никаких изменений (кроме очевидных исправлений ошибок) во фронтэнде не будет. Кодовая база библиотек druntime и Phobos, тем не менее, не заморожена.