Выпуск языка программирования Rust 1.47

Опубликован релиз 1.47 языка системного программирования Rust, основанного проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Автоматическое управление памятью в Rust избавляет разработчика от ошибок при манипулировании указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Реализована поддержка типажей для массивов произвольного размера. Ранее, из-за невозможности определить generic-функции для всех целых значений, стандартная библиотека предоставляла встроенную поддержку типажей только для массивов, размер которых не превышал 32 элемента (типажи для каждого размера были определены статически). Благодаря созданию функциональности константных дженериков ("const generics") появилась возможность определения generic-функций для любых размеров массива, но они пока не включены в состав стабильных возможностей языка, хотя реализованы в компиляторе и теперь задействованы в стандартной библиотеке для типажей массивов любого размера. Например, следующая конструкция в Rust 1.47 приведёт к выводу содержимого массива, хотя раньше привела бы к ошибке: fn main() { let xs = [0; 34]; println!("{:?}", xs); } Обеспечен вывод более коротких трассировок (backtrace), выводимых при внештатных ситуациях. Из трассировки исключены элементы, не представляющие интереса в большинстве ситуаций, но захламляющие вывод и отвлекающие внимание от первичных причин проблемы. Для возвращения полной трассировки можно использовать переменную окружения "RUST_BACKTRACE=full". Например, для кода fn main() { panic!(); } раньше выводилась трассировка в 23 этапа, а теперь она будет сведена к 3 этапам, позволяющим сразу уловить суть: thread 'main' panicked at 'explicit panic', src/main.rs:2:5 stack backtrace: 0: std::panicking::begin_panic at /rustc/d...d75a/library/std/src/panicking.rs:497 1: playground::main at ./src/main.rs:2 2: core::ops::function::FnOnce::call_once at /rustc/d...d75a/library/core/src/ops/function.rs:227 Компилятор rustc обновлён до сборки с использованием LLVM 11 (Rust использует LLVM в качестве бэкенда для генерации кода). При этом сохранена возможность сборки со старыми LLVM, вплоть до версии 8, но по умолчанию (в rust-lang/llvm-project) теперь используется LLVM 11. Релиз LLVM 11 ожидается в ближайшие дни. На платформе Windows в компиляторе rustc обеспечена поддержка включения проверок целостности потока выполнения (Control Flow Guard), активируемых при помощи флага "-C control-flow-guard". На других платформах данный флаг пока игнорируется. В разряд стабильных переведена новая порция API, в том числе стабилизированы Ident::new_raw, Range::is_empty, RangeInclusive::is_empty, Result::as_deref, Result::as_deref_mut, Vec::leak, pointer::offset_from, f32::TAU и f64::TAU. Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в методах: new для всех целых, отличных от нуля; checked_add, checked_sub, checked_mul,checked_neg, checked_shl, checked_shr, saturating_add, saturating_sub и saturating_mul для всех целых; is_ascii_alphabetic, is_ascii_uppercase, is_ascii_lowercase, is_ascii_alphanumeric, is_ascii_digit, is_ascii_hexdigit, is_ascii_punctuation, is_ascii_graphic, is_ascii_whitespace и is_ascii_control для типов char и u8. Для FreeBSD задействован инструментарий из FreeBSD 11.4 (FreeBSD 10 не поддерживает LLVM 11).