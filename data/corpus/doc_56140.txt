Web-фреймворк Pusa, переносящий логику JavaScript-фронтэнда на сторону сервера

Опубликован web-фреймворк Pusa с реализацией концепции, переносящей логику фронтэнда, выполняемую в браузере при помощи JavaScript, на сторону бэкенда - управление браузером и DOM элементами, а также бизнеслогика выполняются на бэкенде. Выполняемый на стороне браузера JavaScript код заменяется на универсальную прослойку, вызывающую обработчики, находящиеся на стороне бэкенда. Необходимость разработки с использованием JavaScript для фронтэнда отсутствует. Эталонная реализация Pusa написана на языке PHP и распространяется под лицензией GPLv3. Кроме PHP технология может быть реализована на любому другом языке, включая JavaScript/Node.js, Java, Python, Go и Ruby. Pusа определяет протокол обмена на базе минималистичного набора команд. При загрузке страницы браузер загружает базовое содержимое DOM и JavaScript-ядро Pusa-Front. Pusa-Front посредством Ajax-запросов направляет события браузера (такие как click, blur, focus и keypress) и параметры запроса (элемент вызвавший событие, его атрибуты, URL и т.п.) в серверный обработчик Pusa-Back. На основании полученных данных Pusa-Back определяет контроллер, выполняет полезную нагрузку и формирует ответный набор команд. Получив ответ запроса Pusa-Front выполняет команды, изменяя содержимое DOM и окружение браузера. Состояние фронтэнда формируется но не контролируется бэкендом, что делает разработку для Pusa схожей с кодом для видеокарты или Canvas, где результат исполнения не контролируется разработчиком. Для создания интерактивных приложений на базе Canvas и onmousemove предусмотрена возможность загрузки и использования дополнительных скриптов JavaScript на стороне клиента. Из недостатков метода также отмечается перенос части нагрузки с фронтэнда на бэкенд и увеличение частоты обмена данными с сервером. Среди достоинств выделяются: исключение необходимости участия JavaScript-разработчиков фронтэнда, стабильный и компактный клиентский код (11кб), недоступность основного кода со стороны фронтэнда, отсутствие необходимости в сериализации REST и в средствах типа gRPC, исключение проблем согласования маршрутизации запросов между фронтэндом и бэкендом.