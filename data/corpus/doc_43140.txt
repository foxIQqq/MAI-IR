Выпуск СУБД SQLite 3.9.0 с поддержкой JSON

После двух лет существования ветки 3.8.x представлен релиз SQLite 3.9.0, легковесной базы данных, оформленной в виде подключаемой библиотеки. Код SQLite распространяется как общественное достояние (public domain), т.е. может использоваться без ограничений и безвозмездно в любых целях. Финансовую поддержку разработчиков SQLite осуществляет специально созданный консорциум, в который входят такие компании, как Adobe, Oracle, Mozilla, Bentley и Bloomberg. Нумерация версий SQLite отныне будет производиться в соответствии со спецификацией "Cемантическое версионирование", подразумевающей использование нотации X.Y.Z (вместо ранее используемой W.X.Y.Z), в которой X меняется при внесении изменений, нарушающих обратную совместимость, Y меняется при расширении функциональности и Z при исправлении ошибок. В выпуске SQLite 3.9.0 смена значительного номера версии обусловлена включением серии существенных улучшений, среди которых поддержка формата JSON, новый движок полнотекстового поиска FTS5, возможность создания индексов для выражений и поддержка использования функций с табличным значением. Подробнее об изменениях: В состав включён модуль json1, активируемый на этапе компиляции опцией SQLITE_ENABLE_JSON1. Модуль включает набор функций для манипуляции данными в формате JSON, которые позволяют организовать обработку данного формата в SQL-запросах. При этом, вместо введения нового типа, работа с JSON симулируется поверх полей с типом text, т.е. в конфигурациях без модуля данные поля остаются доступны для разбора внешними инструментами. Пример перебора значений в блоках JSON в SELECT-запросе: SELECT DISTINCT user.name FROM user, json_each(user.phone) WHERE json_each.value LIKE '704-%'; В блоке "FROM" в составе запросов "SELECT" реализована возможность использования функций с табличным значением (table-valued), которые выдают на выходе набор строк, воспринимаемый в запросе как вывод из виртуальной таблицы; Интеграция FTS5, нового поколения движка полнотекстового поиска, в котором устранены некоторые концептуальные проблемы движков FTS3/4, которые не удавалось решить без нарушения обратной совместимости. Например, для сокращения потребления памяти в FTS5 реализована техника инкрементальной загрузки списков в память, возможно определение наличия подмножества без полного перебора списка, преодолён лимит SQLITE_MAX_LENGTH, добавлена поддержка сортировки по релевантности ("ORDER BY rank"), представлена возможность подключения собственных функций для расчёта веса результата и обработки текста. Модуль с реализаций FTS5 пока помечен как экспериментальный и требует сборки SQLite с опцией SQLITE_ENABLE_FTS5; Поддержка использования индексов для выражений (раньше создание индексов допускалось только для столбцов, но не для операций с ними). В качестве элемента индекса можно использовать функцию над столбцом или операции над столбцами. Например, индексы CREATE INDEX acctchng_magnitude ON account_change(id, abs(amt)); CREATE INDEX t2xy ON t2(x+y); сработают при выполнении SELECT * FROM account_change WHERE id=$xyz AND abs(amt)>=10000; SELECT * FROM t2 WHERE y+x=22; Поддержка "эпонимических" (eponymous) виртуальных таблиц, которые автоматически присутствуют в схеме "main" при всех соединениях с БД, не требуя предварительного выполнения выражения "CREATE VIRTUAL TABLE". Имя эпонимической таблицы соответствует имени загружаемого модуля, реализующего данную таблицу; В выражении "CREATE VIEW" теперь допустимо опционально указывать список имён столбцов, выводимых в данном представлении; При создании представлений теперь можно ссылаться на неопределённые таблицы и функции - предупреждение об их отсутствии будет выведено при непосредственном использовании представления в запросе; В планировщике запросов реализована возможность задействования частичных индексов, охватывающих подмножество строк, заданное через условие AND в блоке WHERE; В утилиту sqlite3_analyzer добавлен вывод уровня разветвления для btree и индексов; Виртуальная таблица dbstat расширена для использования в качестве функции с табличным значением, в которых в качестве аргумента передаётся имя анализируемой схемы; Устранена критическая ошибка в реализации расширения для шифрования данных (SQLite Encryption Extension), которая может привести к невозможности прочитать и восстановить содержимое БД после изменения размера шифрованного блока в процессе выполнения VACUUM.