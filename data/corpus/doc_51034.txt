Выпуск языка программирования Rust 1.36

Опубликован релиз языка системного программирования Rust 1.36, основанного проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime. Автоматическое управление памятью в Rust избавляет разработчика от манипулирования указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo, позволяющий получить нужные для программы библиотеки в один клик. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Стабилизирован типаж (trait) Future, который представляет значение, вычисление которого возможно ещё не завершено в процессе использования блоков async / .await. Определяемые при помощи Future асинхронные значения дают возможность продолжить выполнение в потоке полезной работы, попутно ожидая завершения вычислений определённого значения; Стабилизирована библиотека alloc, предоставляющая умные указатели и коллекции для управления размещаемыми в памяти значениями. Для выделения памяти в std теперь применяется тип Vec, который реэкспортируются из alloc. Отдельное использование alloc имеет смысл в приложениях не привязанных к std ("#![no_std]"), а также в библиотеках, рассчитанных на применение в подобных программах без std; Для обхода проверок корректной инициализации значений предложен промежуточный тип MaybeUninit, который можно использовать вместо функции mem::uninitialized, в качестве её более безопасной альтернативы. Функция mem::uninitialized удобна для быстрого создания массивов, но вводит компилятор в заблуждение, так как создаёт видимость выполнения инициализации, но в действительности значение остаётся неинициализированным. MaybeUninit позволяет явно указать компилятору, что значение неинициализировано, учесть связанное с этим возможное неопределённое поведение, а также в программах организовать проверку через "maybe_t:" и поэтапную инициализацию с пометкой её завершения при помощи вызова ".assume_init()". С появлением MaybeUninit функция mem::uninitialized переведена в разряд устаревших и не рекомендована к использованию; Техника NLL (Non-Lexical Lifetimes), расширившая систему учёта времени жизни заимствованных переменных, стабилизирована для языка Rust 2015 (изначально NLL поддерживался только Rust 2018). Вместо привязки времени жизни на лексическом уровне, NLL осуществляет учёт на уровне набора указателей в графе потока выполнения. Подобный подход позволяет увеличить качество проверки заимствования переменных (borrow checker) и допустить выполнение некоторых видов корректного кода, использование которого ранее приводило к выводу ошибки. Новое поведение также существенно упрощает отладку; Включена новая реализация ассоциативных массивов HashMap, основанная на применении структуры Swiss Table (автоматически загружается hashbrown::HashMap, если явно не указано иное, например, std::HashMap, который основан на SipHash 1-3). Программный интерфейс остался прежним, а заметные разработчику отличия сводятся к увеличению производительности и снижению потребления памяти; В пакетный менеджер cargo добавлена опция "--offline", включающая режим работы без обращения по сети, при котором при установке зависимостей используются только прокэшированные в локальной системе пакеты. Если зависимость отсутствует в локальном кэше, то будет выведена ошибка. Для предварительной загрузки зависимостей в локальный кэш перед переходом в offline можно использовать команду "cargo fetch"; Реализована возможность вызова макроса "dbg!" с указанием нескольких аргументов; Признак "const", определяющий возможность использования в любом контексте вместо констант, применён для методов Layout::from_size_align_unchecked, mem::needs_drop, NonNull::dangling и NonNull::cast; В разряд стабильных переведена новая порция API, в том числе стабилизированы методы task::Waker, task::Poll, VecDeque::rotate_left, VecDeque::rotate_right, Read::read_vectored, Write::write_vectored, Iterator::copied, BorrowMut (для строк) и str::as_mut_ptr.