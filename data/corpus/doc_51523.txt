Релиз набора компиляторов LLVM 9.0

После шести месяцев разработки представлен релиз проекта LLVM 9.0 - GCC-совместимого инструментария (компиляторы, оптимизаторы и генераторы кода), компилирующего программы в промежуточный биткод RISC-подобных виртуальных инструкций (низкоуровневая виртуальная машина с многоуровневой системой оптимизаций). Сгенерированный псевдокод может быть преобразован при помощи JIT-компилятора в машинные инструкции непосредственно в момент выполнения программы. Из новых возможностей LLVM 9.0 отмечается обеспечение снятия метки экспериментальной разработки с целевой платформы RISC-V, поддержка C++ для OpenCL, возможность разделения программы на динамически подгружаемые части в LLD и реализация конструкции "asm goto", используемой в коде ядра Linux. В libc++ добавлена поддержка WASI (WebAssembly System Interface), а в LLD появилась начальная поддержка динамического связывания WebAssembly. Улучшения в Clang 9.0: Добавлена реализация специфичного для GCC выражения "asm goto", которое позволяет выполнить переход из ассемблерного inline-блока к метке в коде на языке Си. Указанная возможность необходима для сборки ядра Linux в режиме "CONFIG_JUMP_LABEL=y" с использованием Clang на системах с архитектурой x86_64. С учётом добавленных в прошлых выпусках изменений, ядро Linux теперь может собираться в Clang и для архитектуры x86_64 (ранее поддерживалась только сборка для архитектур arm, aarch64, ppc32, ppc64le и mips). Более того, проекты Android и ChromeOS уже переведены на использование Clang для сборки ядра и Google тестирует Clang в качестве основной платформы для сборки ядер для своих рабочих Linux-систем. В дальнейшем в процессе сборки ядра можно будет использовать и другие компоненты LLVM, включая LLD, llvm-objcopy, llvm-ar, llvm-nm и llvm-objdump; Добавлена экспериментальная поддержка использования C++17 в OpenCL. Из специфичных возможностей отмечается поддержка атрибутов адресного пространства, блокировка преобразования адресного пространства операторами приведения типов, предоставление векторных типов как в OpenCL для C, наличие специфичных OpenCL-типов для изображений, событий, каналов и т.п. Добавлены новые флаги компилятора "-ftime-trace" и "-ftime-trace-granularity=N" для генерации отчета о времени выполнения различных стадий работы фронтэнда (парсинг, инициализация) и бэкенда (стадии оптимизации). Отчёт сохраняется в формате json, совместимом с chrome://tracing и speedscope.app; Добавлена обработка спецификатора "__declspec(allocator)" и генерация сопутствующей отладочной информации, позволяющей отслеживать потребление памяти в среде Visual Studio; Для языка Си добавлена поддержка макроса "__FILE_NAME__", напоминающего макрос "__FILE__", но включающий только имя файла без полного пути; Для языка C++ расширена поддержка атрибутов адресного пространства, охватывающих различные возможности C++, включая шаблоны параметров и аргументов, ссылочные типы, вывод типа возвращаемого значения, объекты, автоматически генерируемые функции, встроенные операторы и т.п. Расширены возможности, связанные с поддержкой OpenCL, OpenMP и CUDA. В том числе обеспечена начальная поддержка неявного включения встроенных функций OpenCL (добавлен флаг "-fdeclare-opencl-builtins"), реализовано расширение cl_arm_integer_dot_product и расширены средства диагностики; Улучшена работа статического анализатора и добавлена документация по выполнению статического анализа. Добавлены флаги для отображения доступных модулей проверки и поддерживаемых опций ("-analyzer-checker[-option]-help", "-analyzer-checker[-option]-help-alpha" и "-analyzer-checker[-option]-help-developer"). Добавлен флаг "-analyzer-werror" для реагирования на предупреждения как на ошибки. Добавлены новые режимы проверки: security.insecureAPI.DeprecatedOrUnsafeBufferHandling для выявления небезопасных приёмов работы с буферами; osx.MIGChecker для поиска нарушений правил оформления вызовов MIG (Mach Interface Generator); optin.osx.OSObjectCStyleCast для поиска некорректных преобразований объектов XNU libkern; apiModeling.llvm с набором моделирующих функций проверки для выявления ошибок в кодовой базе LLVM; Стабилизирован код для проверки неинициализированных объектов С++ (UninitializedObject в пакете optin.cplusplus); В утилиту clang-format добавлена поддержка форматирования кода на языке C# и обеспечена поддержка применяемого в Microsoft стиля оформления кода; В clang-cl, альтернативном интерфейсе командной строки, обеспечивающем совместимость на уровне опций с компилятором cl.exe из состава Visual Studio, добавлена эвристика для восприятия несуществующих файлов как опций командной строки с выводом соответствующего предупреждения (например, при запуске "clang-cl /diagnostic:caret /c test.cc"); В linter clang-tidy добавлена большая порция новых проверок, в том числе добавлены проверки, специфичные для API OpenMP; Расширены возможности сервера clangd (Clang Server), в котором по умолчанию включен режим построения индекса в фоновом режиме, добавлена поддержка контекстных действий с кодом (извлечение переменной, раскрытие определений auto и макросов, преобразование экранированных строк в неэкранированные), появилась возможность вывода предупреждений от Clang-tidy, расширена диагностика ошибок в заголовочных файлах и добавлена возможность вывода информации об иерархии типов; Основные новшества LLVM 9.0: В компоновщик LLD добавлена экспериментальная возможность партицирования, позволяющая разделить одну программу на несколько частей, каждая из которых размещается в отдельном ELF-файле. Указанная возможность позволяет запускать основную часть программы, которая по мере необходимости в процессе работы будет подгружать остальные компоненты (например, можно выделить встроенный PDF-просмотрщик в отдельный файл, который будет загружаться только когда пользователь открыл PDF-файл). Компоновщик LLD доведён до состояния, пригодного для компоновки ядра Linux для архитектур arm32_7, arm64, ppc64le и x86_64. Предложены новые опции "-" (вывод в stdout), "--[no-]allow-shlib-undefined", "--undefined-glob", "-nmagic", "-omagic", "--dependent-library", "-z ifunc-noplt" и "-z common-page-size". Для архитектуры AArch64 добавлена поддержка инструкций BTI (Branch Target Indicator) и PAC (Pointer Authentication Code). Существенно улучшена поддержка платформ MIPS, RISC-V и PowerPC. Добавлена начальная поддержка динамического связывания для WebAssembly; В libc++ реализованы функции ssize, std::is_constant_evaluated, std::midpoint и std::lerp, в std::span добавлены методы "front" и "back", добавлены признаки типов std::is_unbounded_array и std::is_bounded_array, расширены возможности std::atomic. Прекращена поддержка GCC 4.9 (возможно использование с GCC 5.1 и более новых выпусков). Добавлена поддержка WASI (WebAssembly System Interface, интерфейс для использования WebAssembly вне браузера); Добавлены новые оптимизации. Обеспечено преобразование вызовов memcmp в bcmp в некоторых ситуациях. Реализован пропуск проверки диапазонов для таблиц переходов, в которых нижние блоки switch недостижимы или когда инструкции не используются, например, при вызове функций с типом void; Стабилизирован бэкенд для архитектуры архитектуры RISC-V, который больше не позиционируется как экспериментальный и собирается по умолчанию. Обеспечена полная поддержка генерации кода для вариантов наборов инструкций RV32I и RV64I с расширениями MAFDC; Внесены многочисленные улучшения в бэкенды для архитектур X86, AArch64, ARM, SystemZ, MIPS, AMDGPU и PowerPC. Например, для архитектуры AArch64 добавлена поддержка инструкций SVE2 (Scalable Vector Extension 2) и MTE (Memory Tagging Extensions), в бэкенде ARM добавлена поддержка архитектуры Armv8.1-M и расширения MVE (M-Profile Vector Extension). В бэкенд AMDGPU добавлена поддержка архитектуры GFX10 (Navi), по умолчанию включена возможности вызова функций и активирован комбинированный проход DPP (Data-Parallel Primitives). В отладчике LLDB появилась цветная подсветка обратных трассировок, добавлена поддержка блоков DWARF4 debug_types и DWARF5 debug_info; В утилиты llvm-objcopy и llvm-strip добавлена поддержка объектных и исполняемых файлов в формате COFF.