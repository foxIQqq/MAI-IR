Выпуск фреймворка для создания сетевых приложений ErgoFramework 2.2

Состоялся очередной релиз ErgoFramework 2.2, реализующего полный сетевой стек Erlang и его библиотеку OTP на языке Go. Фреймворк предоставляет разработчику гибкий инструментарий из мира Erlang для создания распределённых решений на языке Go с помощью готовых шаблонов проектирования общего назначения gen.Application, gen.Supervisor и gen.Server, а также специализированных - gen.Stage (distributed pub/sub), gen.Saga (distributed transactions, реализация шаблона проектирования SAGA) и gen.Raft (реализация протокола Raft). Помимо этого, фреймворк предоставляет функциональность прокси с возможностью сквозного шифрования, недоступного в Erlang/OTP и Elixir. Поскольку в языке Go отсутствует прямой аналог процесса Erlang, то во фреймворке используются goroutine как основы для gen.Server с обёрткой "recover" для возможности обработки исключительных ситуаций. Код проекта распространяется под лицензией MIT. Сетевой стек в ErgoFramework полностью реализует спецификацию DIST протокола Erlang. Это значит, что приложения, написанные на основе ErgoFramework нативно работают с любыми приложениями, написанными на языках программирования Erlang или Elixir (пример взаимодействия с Erlang нодой). Стоит также отметить, что шаблон проектирования gen.Stage реализован по спецификации Elixir GenStage и полностью совместим с ним (пример реализации). В новом выпуске: Добавлены новые шаблоны gen.Web - шаблон проектирования Web API Gateway (также известный как Backend For Frontend). Пример. gen.TCP - шаблон, позволяющий реализовывать пул акцепторов TCP соединений с минимальными усилиями в написании кода. Пример. gen.UDP - аналогичен шаблону gen.TCP, только для протокола UDP. Пример. Предложена новая функциональность Events с реализацией простой событийной шины внутри ноды, которая позволяет создавать механизмы обмена событиями (pub/sub) среди локальных процессов. Пример. Добавлена поддержка регистрации типов, которая позволяет автоматически проводить сериализацию/десериализацию сообщений в нативный тип данных Golang. Это значит больше не нужно использовать etf.TermIntoStruct для каждого полученного сообщения. Зарегистрированные типы будут трансформированы в заданный тип автоматически, что значительно ускоряет производительность обмена сообщениями между распределёнными нодами.