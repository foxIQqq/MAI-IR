Выпуск языка программирования Julia 1.7

Опубликован релиз языка программирования Julia 1.7, сочетающего такие качества как высокая производительность, поддержка динамической типизации и встроенные средства для параллельного программирования. Синтаксис Julia близок к MATLAB с заимствованием некоторых элементов из Ruby и Lisp. Метод манипуляции строками напоминает Perl. Код проекта распространяется под лицензией MIT. Ключевые особенности языка: Высокая производительность: одной из ключевых целей проекта является достижение производительности близкой к программам на языке Си. Компилятор Julia основан на наработках проекта LLVM и генерирует эффективный нативный машинный код для многих целевых платформ; Поддержка различных парадигм программирования, включая элементы объектно-ориентированного и функционального программирования. Стандартная библиотека предоставляет в том числе функции для асинхронного ввода/вывода, управления процессами, ведения логов, профилирования и управления пакетами; Динамическая типизация: язык не требует явного определения типов для переменных по аналогии со скриптовыми языками программирования. Поддерживается интерактивный режим работы; Опциональная возможность явного указания типов; Синтаксис, превосходно подходящий для численных вычислений, научных расчётов, систем машинного обучения и визуализации данных. Поддержка многих числовых типов данных и средств для распараллеливания вычислений. Возможность прямого вызова функций из библиотек на языке Си без дополнительных прослоек. Новые возможности языка Julia 1.7: Новый синтаксис для создания многомерных массивов. Символы точки с запятой используются для разделения измерений массива, при этом количество точек с запятой указывает размер. Например, одна точка с запятой в "[A; B]" означает конкатенацию в первом измерении (по вертикали в одномерном массиве), две точки с запятой "[A;; B]" делают это во втором измерении (по горизонтали как новую строку матрицы), три точки с запятой ";;;" в третьем и т.д. Обратная косая черта (\) в конце строки внутри строкового литерала теперь удаляет символ перевода строки и отступы. Это можно использовать для разделения длинных строк на несколько строк кода без добавления лишних символов. Обратная косая черта перед новой строкой в литералах запуска консольных команд `cmd \...` теперь всегда удаляет перевод строки и интерпретирует последовательность как непрерывный строковые литерал, тогда как результат раньше не был чётко определён. Выражение "(; a, b) = x" для создания отдельных переменных a и b из x. Этот синтаксис эквивалентен "a = getproperty(x, :a); b = getproperty(x, :b)". Неявное перемножение теперь разрешено для символов радикалов (например, x√y и x∛y). Логические операторы "&&" и "||" теперь могут быть использованы применительно к элементам массива в форме ".&&" и ".||". Операторы ⫪(U + 2AEA, \Top, \downvDash) и ⫫(U + 2AEB, \Bot, \upvDash, \indep) теперь могут быть использованы в качестве бинарных операторов. Добавлена опция "--check-bounds=yes|no|auto" для контроля за макросами @inbounds со значением по-умолчанию auto. Изменения языка Применяемый по умолчанию генератор псевдослучайных чисел изменён с Mersenne Twister на Xoshiro256++, поэтому все случайные числа будут разными (даже с одним и тем же начальным числом), если только не используется явный объект RNG. Новый генератор имеет лучшую производительность, превосходные статистические характеристики и используется для воспроизводимой случайности в многопоточных программах (сохраняет состояние для каждой выполняемой задачи и ответвляет отдельное состояние при создании новой задачи). Деструктуризация больше не изменяет значения в процессе присвоения левой части при получении значений из правой части выражения. Например, для массива x, выражение "x[2], x[1] = x" теперь будет менять местами первый и второй элемент x, в то время как ранее для заполнения обеих записей использовалось x[1] потому что x[2] изменялся в ходе итерации присвоения x. macroexpand, @macroexpand и @macroexpand1 больше не генерируют ошибку LoadError. @test_throws также был изменен, чтобы сохранить работоспособными затронутые тесты. Средняя точка "·" ( \cdotpU + 00b7) и греческий интерпункт ·(U + 0387) теперь обрабатываются как эквивалент оператора точки "⋅" (\cdotU + 22c5). Знак минус "−" (\minusU + 2212) теперь рассматривается как эквивалент знака дефиса-минус "-" (U + 002d). Iterators.peel(itr) теперь возвращает "nothing" когда itr пусто, а не выбрасывает исключение BoundsError. Несколько последовательных точек с запятой в выражении массива ранее игнорировались (например, "[1 ;; 2] == [1 ; 2]"). Теперь этот синтаксис используется для разделения измерений. Несбалансированные директивы форматирования "#= ... =#" в Unicode теперь запрещены в строках и комментариях, чтобы уменьшить вероятность инъекций parse/eval кода. Изменения параметров командной строки Параметр julia --project и переменная окружения JULIA_PROJECT теперь поддерживают выбор общих сред. Например, теперь эквивалентны julia --project=@myenv и export JULIA_PROJECT="@myenv". Изменения многопоточности Внутренние функции для операций с атомарными указателями теперь определены для конкретных размеров байтов. Добавлена поддержка объявления и использования отдельных полей для mutable struct как атомарных; см. новый макрос @atomic. Если для переменной окружения JULIA_NUM_THREADS задано значение "auto", то количество потоков будет равно количеству потоков процессора. Каждый объект Task имеет локальное состояние генератора случайных чисел, что по умолчанию обеспечивает воспроизводимое (не зависящее от расписания) выполнение кода параллельного моделирования. Генератор по умолчанию также работает параллельно значительно быстрее, чем в предыдущих версиях. Задачи теперь могут перемещаться между потоками. Раньше задача всегда запускалась в том потоке, который запустил ее первым. Новые функции библиотеки Добавлены методы findmax(f, domain), argmax(f, domain) и соответствующие "min"-версии с двумя аргументами. isunordered(x) возвращает true, если x - это значение, которое должно быть неупорядочено, например NaN или missing. Новая функция keepat!(vector, inds), которая является эквивалентом vector[inds] списка inds целых чисел. Метод lock(f, lck) для двух аргументов теперь принимает Channel качестве второго аргумента. Новый функтор Returns(value) возвращает value для любых аргументов. Новые макросы @something и, @coalesce которые являются версиями something и coalesce, соответственно. Новая функция redirect_stdio для перенаправления stdin, stdoutи stderr. Новый макрос "Base.@invoke f(arg1::T1, arg2::T2; kwargs…)" обеспечивает простой синтаксис для вызова "invoke(f, Tuple{T1,T2}, arg1, arg2; kwargs...)". Новый макрос "Base.@invokelatest f(args...; kwargs…)" обеспечивает удобный способ вызова "Base.invokelatest(f, args...; kwargs...)". Новые возможности библиотеки Кортеж может быть создан с ключевым словом context в формате ":key => value", чтобы указать атрибуты для передачи в IOContext. bytes2hex и hex2bytes больше не ограничиваются аргументами типа "Union{String,AbstractVector{UInt8}}" и теперь требуют только того, чтобы типы были последовательностями и имели вычислимую длину. stat(file) получил более подробный и удобный show метод. Изменения стандартной библиотеки count и findall теперь принимают AbstractChar аргумент для поиска символа в строке. Новые методы range(start, stop) и range(start, stop, length). range теперь поддерживается start как опциональный ключевой аргумент. Некоторые операции с диапазонами теперь возвращают StepRangeLen вместо StepRange позволяя быть нулевым конечному шагу. Раньше λ .* (1:9) выдавал ошибку при λ = 0. islowercase и isuppercase теперь обрабатывают Unicode-категории нижнего и верхнего регистра. iseven и isodd функции теперь поддерживают типы отличные от Integer. escape_string теперь принимает набор символов через ключевое слово keep, для символов, которые должны оставаться такими, какие они есть. getindex для NamedTuple теперь принимает кортеж символов для индексации нескольких значений. Подтипы AbstractRange следуют общему поведению индексации массивов при индексировании Bool, ошибках для скаляров Bool и при обработке массивов (включая диапазоны) Bool как логических индексов. keys(::RegexMatch) возвращает capture-ключи регулярного выражения по имени, или по индексу, если имён нет. keys(::Generator) возвращает ключи итератора. RegexMatch теперь итерируется, выдавая захваченные подстроки. lpad/rpad определены в для textwidth. Test.@test теперь принимает именованные аргументы broken и skip, которые повторяют поведение Test.@test_broken и Test.@test_skip, но позволяют пропускать тесты, которые заваливаются только при определенных условиях. Например if T == Float64 @test_broken isequal(complex(one(T)) / complex(T(Inf), T(-Inf)), complex(zero(T), zero(T))) else @test isequal(complex(one(T)) / complex(T(Inf), T(-Inf)), complex(zero(T), zero(T))) end можно заменить на @test isequal(complex(one(T)) / complex(T(Inf), T(-Inf)), complex(zero(T), zero(T))) broken=(T == Float64) @lock теперь экспортируется из Base. Экспериментальная функция Base.catch_stack() переименована в current_exceptions() и получила конкретный тип возвращаемого значения. Некоторые тригонометрические функции (sind, cosd, tand, asind, acosd, asecd, acscd, acotd, atand) теперь принимают квадратную матрицу. replace(::String) теперь принимает несколько шаблонов, которые будут применяться слева направо одновременно, поэтому к любому символу будет применяться только один шаблон, а шаблоны будут применяться только к входному тексту, но не к их последовательным заменам. Функция length на заданных диапазонах определённых типов больше не проверяет integer-переполнение в большинстве случаев. checked_length - новая функция, которая использует проверенную арифметику до точки переполнения, если результат может быть с переносом. Или используйте пакет SaferIntegers.jl, если есть риск переполнения диапазона. Новые replace методы для замены элементов в Tuple. Менеджер пакетов В режиме консоли "julia>" для using- или import-пакетов которые не установлены, но доступны в реестре "pkg> add", предлагается установить пакет автоматически. Manifest.toml использует новый формат с новыми метаданными, включая версию julia, которая сгенерировала манифест. Манифесты старого формата по-прежнему поддерживаются в исходном формате, до тех пор, пока пользователь не запустит Pkg.upgrade_manifest(). "pkg> precompile" теперь будет предварительно компилировать новые версии уже загруженных пакетов, а не откладывать их до следующего сеанса. "pkg> rm, pin и free" теперь поддерживают аргумент "--all" для вызова действия для всех пакетов сразу. Реестры, загруженные с Pkg Server (не git), больше не распаковываются в файлы, а читаются непосредственно из архива в память. Чтобы отключить эту функцию, установите переменную среды JULIA_PKG_UNPACK_REGISTRY=true. Теперь можно использовать внешний исполняемый файл git вместо библиотеки libgit2 по умолчанию для загрузок, которые происходят через протокол Git, установив переменную среды JULIA_PKG_USE_CLI_GIT=true. Реестры, загруженные с сервера Pkg (не git), теперь считаются неизменяемыми. Изменения, внесённые вручную в их файлы, могут не быть приняты запущенным сеансом Pkg. Добавление пакетов по имени каталога в режиме REPL теперь требует добавления "./" к имени, если пакет находится в текущем каталоге; например "add ./Package" вместо "add Package". Это сделано для того, чтобы избежать путаницы между именем пакета Package и локальным каталогом Package. Удалено ключевое слово mode для PackageSpec. Линейная алгебра Используйте Libblastrampoline для подключения BLAS и LAPACK во время выполнения. По умолчанию OpenBLAS подключается в составе дистрибутива Julia. Новый механизм подключения может быть использован для замены BLAS и LAPACK пользовательскими настройками. На aarch64 OpenBLAS теперь использует ILP64 BLAS, также как и все другие 64-битные платформы. OpenBLAS обновлен до версии 0.3.13. SuiteSparse обновлен до версии 5.8.1. Форма матрицы UpperHessenberg сохраняется при определенных арифметических операциях, например, при умножении или делении на UpperTriangular матрицу. Действительные квазитреугольные факторизации Шура теперь можно преобразовать в сложную верхнетреугольную форму с помощью выражения "Schur{Complex}(S)". cis(A) теперь поддерживает матрицы как аргументы. dot поддерживает UniformScaling для типа AbstractMatrix. qr[!] и lu[!] теперь поддерживают значения LinearAlgebra.PivotingStrategy одноэлементного типа в качестве необязательного pivot-аргумента: значения по умолчанию qr(A, NoPivot()) по сравнению qr(A, ColumnNorm()) с поворотом и lu(A, RowMaximum()) по сравнению с lu(A, NoPivot()) без поворота. Прежние Val{true/false} вызовы устарели. det(M::AbstractMatrix{BigInt}) вызывает det_bareiss(M), который использует алгоритм Bareiss для вычисления точных значений. REPL Длинные строки теперь удаляются с использованием синтаксиса "head" ⋯ 12345 bytes ⋯ "tail" при отображении в REPL. Вставка Repl примеров из буфера обмена в REPL теперь поддерживает все режимы Repl ( julia, pkg, shell, help?) и режим автоматически переключается. "help?>" для модулей без строк документации теперь возвращает список экспортированных имен и выводит содержимое связанного, README.md если оно найдено. SparseArrays Новый метод sizehint!(::SparseMatrixCSC, ::Integer)\. cholesky() теперь полностью сохраняет указанную пользователем перестановку. issparse теперь применяется согласованно ко всем массивам-обёрткам, включая вложенные, путём проверки issparse родительского массива обёртки. Манипуляции с датами Функция Dates.periods может быть использована для получения Vector-значений из Period из CompoundPeriod. Загрузки Если заголовок cookie установлен в перенаправленном запросе, cookie теперь будет отправляться в последующих запросах. Если файл ~/.netrc существует, он используется как источник паролей для веб-сайтов с аутентификацией. Индикация имени сервера теперь выполняется со всеми TLS-соединениями, даже если идентичность сервера не проверена (см. NetworkOptions). При проверке TLS-соединений в Windows, если сервер отзыва сертификатов недоступен, соединение разрешено; это соответствует тому, что делают другие приложения и как выполняется отзыв в macOS. Теперь существует 30-секундное ожидание факта соединение и 20-секундное ожидание на отправку данных. Это гарантирует, что соединения являются живыми, или же они будут отключены менее чем через минуту. Tar Tar.extract теперь игнорирует точный режим разрешений в tarball и нормализует режимы так же, как делает это Tar.create. Что аналогично git. Функции, использующие архивы tar, теперь обрабатывают жесткие ссылки: целью ссылки должен быть ранее просмотренный файл; Tar.list перечисляет запись с :hardlink типом и .link полем, указывающим путь к цели; другие функции - Tar.extract, Tar.rewrite, Tar.tree_hash - преобразуют жесткую связь в копию целевого файла. Стандартный формат, созданный Tar.create и Tar.rewrite теперь включает записи для непустых каталогов. Некоторые инструменты, использующие tarball (включая докер), сбиваются с толку из-за отсутствия этих записей в каталоге. Tar теперь принимает tarball с начальными пробелами в восьмеричных целочисленных полях заголовка: технически это недопустимый формат согласно спецификации POSIX, но старые tar команды Solaris создавали такие архивы, поэтому этот формат действительно встречается в дикой природе, и кажется безвредным его принимать. Tar.extract теперь принимает set_permissions аргумент ключевого слова, который по умолчанию равен true; если false передаётся вместо этого, разрешения извлечённых файлов не изменяются при извлечении. Mmap mmap теперь экспортируется и доступен для использования. DelimitedFiles Readdlm теперь по умолчанию использует use_mmap=false во всех операционных системах для обеспечения стабильной надёжности в ненормальных ситуациях с файловой системой.