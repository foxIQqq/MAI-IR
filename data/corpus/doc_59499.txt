Опубликован PRQL, компилируемый в SQL язык обработки данных

Доступен выпуск языка формирования запросов и преобразования данных PRQL 0.9 (Pipelined Relational Query Language), развиваемого в качестве более простой и функциональной замены SQL, упрощающей создание сложных аналитических запросов. Код на языке PRQL компилируется в SQL, что позволяет использовать его с любыми реляционными СУБД. Компилятор PRQL написан на языке Rust и распространяется под лицензией Apache 2.0. PRQL позволяет формировать сценарии обработки данных в форме конвейеров, в которых по цепочке друг за другом выполняются операции преобразования, которые могут включать блоки для фильтрации потока данных, выполнения вычислении и таких действий, как сортировка, агрегирование и группировка. Поддерживается разделение проекта на несколько файлов. В сценариях PRQL допускается определение функций, использование циклов, создание переменных, массивов, регулярных выражений и кортежей. При необходимости поддерживается прямая подстановка SQL-кода в сценарии на PRQL. В разработке находится возможность использования системы типов и модулей. В планах упоминается расширение библиотеки функций и предоставление плагинов для интеграции с интегрированными средами разработки. В отдалённой перспективе намечено создание компилятора из SQL в PRQL и разработка бэкендов для других языков запросов, таких как RQ (Relational Query). Обвязки для использования PRQL развиваются для языков Java, JavaScript, .NET, Elixir, R, Rust, PHP и Python. Через плагины обеспечена интеграция с Jupyter/IPython, Visual Studio Code и Prefect. Подготовлено расширение для выполнения кода PRQL в СУБД DuckDB. В компиляторе поддерживается генерация SQL с учётом диалектов и возможностей, применяемых в СУБД PostgreSQL, MySQL, DuckDB, Сlickhouse, MS SQL и SQLite. Для тестирования компиляции предложен online-сервис, работающий в браузере. Пример кода: from employees filter start_date > @2021-01-01 # более понятный синтаксис работы с датами derive { # блок derive для добавления столбцов и переменных gross_salary = salary + (tax ?? 0), gross_cost = gross_salary + benefits_cost, } filter gross_cost > 0 group {title, country} ( # блок group выполняет код для каждой группы aggregate { # блок aggregate агрегирует группу в значение average gross_salary, sum_gross_cost = sum gross_cost, } ) filter sum_gross_cost > 100_000 # блок filter заменяет SQL-операции WHERE и HAVING. derive id = f"{title}_{country}" # f-строки, как в Python derive country_code = s"LEFT(country, 2)" # s-строки для прямой вставки SQL-кода sort {sum_gross_cost, -country} # минус сигнализирует сортировку в обратном порядке take 1..20 # take задаёт диапазон для вывода