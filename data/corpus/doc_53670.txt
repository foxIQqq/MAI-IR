Утверждён стандарт C++20

Комитет ISO по стандартизации языка C++ утвердил международный стандарт "C++20". Представленные в спецификации возможности, за исключением единичных случаев, поддерживаются в компиляторах GCC, Clang и Microsoft Visual C++. Поддерживающие C++20 стандартные библиотеки реализованы в рамках проекта Boost. В следующие два месяца утверждённая спецификация будет находиться на стадии подготовки документа к публикации, на которой будет проведена работа по редакторской правке орфографических ошибок и опечаток. В начале ноября результирующий вариант документа будет направлен в ISO для публикации под формальным именем ISO/IEC 14882:2020. Тем временем, комитет уже приступил к работе над следующим стандартом C++23 (C++2b) и на ближайшем виртуальном совещании рассмотрит возможные новшества. Основные особенности C++20 (примеры кода): Добавлены "концепции", расширения шаблонов, позволяющие определить набор требований к параметрам шаблона, которые во время компиляции ограничивают набор аргументов, которые могут приниматься в качестве параметров шаблона. Концепции можно применять для того, чтобы избежать логических несоответствий между свойствами типов данных, используемых внутри шаблона, и свойствами типов данных входных параметров. template<typename T> concept EqualityComparable = requires(T a, T b) { { a == b } -> std::boolean; { a != b } -> std::boolean; }; В состав приняты расширения для работы с модулями, которые можно использовать вместо заголовочных файлов. Модули предоставляют новый способ организации исходных текстов на основании определения границ компонентов, без подключаемых через "#include" заголовочных файлов. Макрос __VA_OPT__ для адаптивного раскрытия вариативных макросов в зависимости от наличия токенов в вариативном аргументе. Поддержка оператора "<=>" для трехстороннего сравнения. Поддержка инициализаторов элементов по умолчанию для битовых полей. Возможность лямбда-захвата выражений "*this". struct int_value { int n = 0; auto getter_fn() { // BAD: // return [=]() { return n; }; // GOOD: return [=, *this]() { return n; }; } }; Вызов элементов по указателю (Pointer-to-member), используя определённые через выражение "const &" указатели на временные объекты. Оператор delete с деструктором, описанный в документе P0722R1. Классам разрешено использование параметров шаблона без типа. struct foo { foo() = default; constexpr foo(int) {} }; template <foo f> auto get_foo() { return f; } get_foo(); // uses implicit constructor get_foo<foo{123}>(); Не сохраняемые лямбда-выражения с конструктором. Допустимость использования синтаксиса шаблонов для ламбда-выражений ("auto f = []<typename T>(std::vector<T> v)"). Возможность использования строковых литералов в параметрах шаблона. Поддержка синтаксиса инициализации в стиле Си - явно не перечисленные в списке инициализации поля, инициализируются по умолчанию. struct A { int x; int y; int z = 123; }; A a {.x = 1, .z = 2}; // a.x == 1, a.y == 0, a.z == 2 Поддержка пустых членов структур данных. Поддержка атрибутов likely и unlikely для информирования оптимизатора о вероятности срабатывания условной конструкции ("[[likely]] if (random > 0) {"). Возможность использования диапазонов для инициализации значений переменной в цикле "for" for (auto v = std::vector{1, 2, 3}; auto& e : v) { Автоматическое вычисление размера массива в new ("new double[]{1,2,3}"); Атрибут "[[no_unique_address]]" при котором переменные без данных не занимают места. Атомарные указатели (std::atomic<shared_ptr<T>> и std::atomic<weak_ptr<T>>). Возможность вызова виртуальных функций в условных выражениях. Поддержка быстрых (immediate) функций, которые могут работать только с константами. consteval int sqr(int n) { return n * n; } constexpr int r = sqr(100); // OK int x = 100; int r2 = sqr(x); // ERROR: 'x' не может использоваться как константа Возможность применения constexpr с виртуальными функциями ("constexpr virtual int f() const { return 2; }"). В стандартной библиотеке: Добавлена поддержка типа char8_t для строк UTF-8. Добавлены заголовочные файлы bit (битовые операции) и version. Появилась возможность проверки префикса и суффикса строк (starts_with, ends_with). Добавлены типажи std::remove_cvref, std::unwrap_reference, std::unwrap_decay_ref, std::is_nothrow_convertible и std::type_identity. Добавлены функции std::midpoint, std::lerp, std::bind_front, std::source_location, std::visit, std::is_constant_evaluated и std::assume_aligned. В std::make_shared добавлена поддержка массивов. Добавлена функция std::to_array для преобразования похожих на массив объектов в std::array. В состав включена библиотека std::ranges, позволяющая использовать итераторы над группой элементов. Более удобный синтаксис перечислений: enum class rgba_color_channel { red, green, blue, alpha }; std::string_view to_string(rgba_color_channel my_channel) { switch (my_channel) { using enum rgba_color_channel; case red: return "red"; case green: return "green"; case blue: return "blue"; case alpha: return "alpha"; } } В индексах из-за неопределённого поведения запрещено использование операции "," ("a[b,c]"). Прекращена поддержка большинства операций с переменными, объявленными с ключевым словом volatile, в том числе запрещены операции "++" и "--" со стандартными типами. Сокращено число ситуаций, в которых требуется указание "typename" для информировании о наличии типа.