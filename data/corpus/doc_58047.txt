Выпуск языка программирования Rust 1.65

Опубликован релиз языка программирования общего назначения Rust 1.65, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Методы работы с памятью в Rust избавляют разработчика от ошибок при манипулировании указателями и защищают от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами, учёт времени жизни объектов (области видимости) и оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок. Основные новшества: Добавлена поддержка обобщённых ассоциированных типов (GAT, Generic Associated Types), дающие возможность создавать псевдонимы типов, ассоциированные с другим типом, и позволяющие связывать конструкторы типов с типажами. trait Foo { type Bar<'x>; } Реализовано выражение "let ... else", позволяющее проверять условие соответствия шаблону непосредственно внутри выражения "let" и выполнять произвольный код, если шаблон не совпадает. let Ok(count) = u64::from_str(count_str) else { panic!("Can't parse integer: '{count_str}'"); }; Разрешено использование выражения break для преждевременного выхода из именованных блоков, используя имя блока (метку) для определения завершаемого блока. let result = 'block: { do_thing(); if condition_not_met() { break 'block 1; } do_next_thing(); if condition_not_met() { break 'block 2; } do_last_thing(); 3 }; Для Linux добавлена возможность раздельного сохранения отладочной информации (split-debuginfo), ранее доступная только для платформы macOS. При указании опции "-Csplit-debuginfo=unpacked" данные debuginfo в формате DWARF будут сохранены в несколько отдельных объектных файлов с расширением ".dwo". При указании "-Csplit-debuginfo=packed" будет создан один пакет в формате ".dwp", включающий все данные debuginfo для проекта. Для интеграции debuginfo непосредственно в секцию .debug_* ELF-объектов можно использовать опцию "-Csplit-debuginfo=off". В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: std::backtrace::Backtrace Bound::as_ref std::io::read_to_string <*const T>::cast_mut <*mut T>::cast_const Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в функциях <*const T&>::offset_from и <*mut T>::offset_from В рамках финальной стадии перевода реализации протокола LSP (Language Server Protocol) на rust-analyzer, устаревшая реализация Rust Language Server (RLS) заменена на cервер-заглушку, выдающий предупреждение с предложением перейти на использование rust-analyzer. При компиляции включена поддержка inline-развёртывания промежуточного кода MIR, приводящая к ускорению компиляции типовых crate-пакетов на 3-10%. Для ускорения сборок по расписанию в пакетном менеджере Cargo обеспечена сортировка работ, ожидающих выполнения в очереди. Реализован второй уровень поддержки целевой платформы x86_64-unknown-none, предназначенной для формирования исполняемых файлов, способных работать без операционной системы. Например, указанная целевая платформа может использоваться при написании компонентов ядра. Второй уровень поддержки подразумевает гарантию сборки. Реализован третий уровень поддержки для платформ powerpc64-unknown-openbsd, riscv64-unknown-openbsd и armv4t-none-eabi. Одобрен перевод на третий уровень поддержки платформ aarch64-unknown-uefi, i686-unknown-uefi и x86_64-unknown-uefi, позволяющих собирать для UEFI компоненты на языке Rust. Второй уровень поддержки подразумевает гарантию сборки. Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования, публикации официальных сборок и проверки возможности сборки кода. Дополнительно можно отметить интервью о применении языка Rust в компании Volvo для разработки компонентов автомобильных информационных систем. Уже существующий и протестированный код переписывать на Rust не планируют, но для нового кода Rust является одним из предпочтительных вариантов для повышения качества с меньшими затратами. Связанные с использованием языка Rust рабочие группы также созданы в автомобильных объединениях AUTOSAR (AUTomotive Open System ARchitecture) и SAE (Society of Automotive Engineers). Кроме того, Дэвид Клейдермахер (David Kleidermacher), вице-президент Google по инжинирингу, рассказал о переводе на язык Rust кода, используемого в платформе Android для управления ключами шифрования, а также применении Rust в реализации протокола DNS over HTTPS, в стеке для UWB-чипов (Ultra-Wideband) и во фреймворке виртуализации (Android Virtualization Framework), связанном с чипом Tensor G2. Для Android также развиваются новые стеки для Bluetooth и Wi-Fi, переписанные на языке Rust. Общая стратегия заключается в постепенном усилении защиты вначале через перевод на использование Rust наиболее незащищённых и жизненно важных программных компонентов, а затем охватывая и другие связанные с ними подсистемы. В прошлом году язык Rust был включён в число языков, допустимых для разработки платформы Android.