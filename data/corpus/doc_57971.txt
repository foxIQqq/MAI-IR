Выпуск языка программирования Python 3.11

После года разработки опубликован значительный выпуск языка программирования Python 3.11. Новая ветка будет поддерживаться в течение полутора лет, после чего ещё три с половиной года для неё будут формироваться исправления с устранением уязвимостей. Одновременно началось альфа-тестирование ветки Python 3.12 (в соответствии с новым графиком разработки работа над новой веткой начинается за пять месяцев до релиза предыдущей ветки и к моменту очередного релиза достигает стадии альфа-тестирования). Ветка Python 3.12 будет находиться на стадии альфа-выпусков в течение семи месяцев, во время которых будут добавляться новые возможности и производиться исправление ошибок. После этого в течение трёх месяцев будет проводиться тестирование бета-версий, во время которого добавление новых возможностей будет запрещено и всё внимание будет уделяться исправлению ошибок. Последние два месяца перед релизом ветка будет находиться на стадии кандидата в релизы, на которой будет выполнена финальная стабилизация. Среди добавленных в Python 3.11 новшеств: Проведена значительная работа по оптимизации производительности. В новую ветку включены изменения, связанные с ускорением и inline-развёртыванием вызова функций, применением быстрых интерпретаторов типовых операций (x+x, x*x, x-x, a[i], a[i] = z, f(arg) C(arg), o.method(), o.attr = z, *seq), а также оптимизациями, подготовленными проектами Cinder и HotPy. В зависимости от вида нагрузки отмечается прирост скорости выполнения кода на 10-60%. В среднем производительность при прохождении тестового набора pyperformance увеличилась на 25%. Переработан механизм кэширования байткода, что позволило сократить время запуска интерпретатора на 10-15%. Объекты с кодом и байткод теперь статически разамещаются интерпретатором, что дало возможность исключить стадии демаршалинга извлечённого из кэша байткода и преобразования объектов с кодом для размещения в динамической памяти. При отображении трассировки вызовов в диагностических сообщениях обеспечен вывод информации о выражении, из-за которого возникла ошибка (ранее подсвечивалась лишь строка без детализации, какая именно часть строки стала причиной ошибки). Расширенную информацию о трассировке также можно получить через API и использовать для сопоставления отдельных инструкций байткода с конкретной позицией в исходном коде, используя метод codeobject.co_positions() или функцию C API PyCode_Addr2Location(). Изменение существенно упрощает отладку проблем, связанных с вложенными объектами словарей, множественными вызовами функций и сложными арифметическими выражениями. Traceback (most recent call last): File "calculation.py", line 54, in result = (x / y / z) * (a / b / c) ~~~~~~^~~ ZeroDivisionError: division by zero Добавлена поддержка групп исключений, дающих программе возможность генерировать и обрабатывать сразу несколько разных исключений одновременно. Для группировки нескольких исключений и их совместного вызова предложены новые типы исключений ExceptionGroup и BaseExceptionGroup, а для выделения отдельных исключений из группы добавлено выражение "except*". В класс BaseException добавлен метод add_note(), позволяющий прикрепить текстовое примечание к исключению, например, добавить контекстную информацию, недоступную во время генерации исключения. Добавлен специальный тип Self, представляющий текущий закрытый класс. Self может применяться для аннотирования методов, возвращающих экземпляр своего класса, более простым путём, чем при использовании TypeVar. class MyLock: def __enter__(self) -> Self: self.lock() return self Добавлен специальный тип LiteralString, который может включать только строковые литералы, совместимые с типом LiteralString (т.е. голые строки и строки с типом LiteralString, но не произвольные и не комбинированные строки с типом str). Тип LiteralString можно использовать для ограничения передачи функциям строковых аргументов, произвольная подстановка частей строк в которых может привести к уязвимостям, например, при формировании строк для SQL-запросов или shell-команд. def run_query(sql: LiteralString) -> ... ... def caller( arbitrary_string: str, query_string: LiteralString, table_name: LiteralString, ) -> None: run_query("SELECT * FROM students") # ok run_query(literal_string) # ok run_query("SELECT * FROM " + literal_string) # ok run_query(arbitrary_string) # Ошибка run_query( # Ошибка f"SELECT * FROM students WHERE name = {arbitrary_string}" ) Добавлен тип TypeVarTuple, позволяющий использовать вариативные дженерики, в отличие от TypeVar охватывающие не один тип, а произвольное число типов. В стандартную библиотеку включён модуль tomllib с функциями для разбора формата TOML. Предоставлена возможность пометки отдельных элементов типизованных словарей (TypedDict) метками Required и NotRequired для определения обязательных и не обязательных полей (по умолчанию все объявленные поля обязательны для заполнения, если параметр total не выставлен в значение False). class Movie(TypedDict): title: str year: NotRequired[int] m1: Movie = {"title": "Black Panther", "year": 2018} # OK m2: Movie = {"title": "Star Wars"} # OK (поле year необязательное) m3: Movie = {"year": 2022} # Ошибка, не заполнено обязательное поле title) В модуль asyncio добавлен класс TaskGroup с реализацией асинхронного контекстного менеджера, ожидающего завершения группы задач. Добавление задач в группу осуществляется при помощи метода create_task(). async def main(): async with asyncio.TaskGroup() as tg: task1 = tg.create_task(some_coro(...)) task2 = tg.create_task(another_coro(...)) print("Both tasks have completed now.") Добавлен декоратор классов, методов и функций @dataclass_transform, при указании которого система проверки статических типов трактует объект как при использовании декоратора @dataclasses.dataclass. В примере ниже класс CustomerModel при проверке типов будет обработан по аналогии с классом с декоратором @dataclasses.dataclass, т.е. как имеющий метод __init__, допускающий переменные id и name. @dataclass_transform() class ModelBase: ... class CustomerModel(ModelBase): id: int name: str В регулярных выражениях добавлена возможность использования атомарной группировки ((?>…)) и ревнивых (possessive) квантификаторов (*+, ++, ?+, {m,n}+). Добавлена опция командной строки "-P" и переменная окружения PYTHONSAFEPATH для отключения автоматического прикрепления к sys.path потенциально небезопасных файловых путей. Значительно улучшена утилита py.exe для платформы Windows, в которой реализована поддержка синтаксиса "-V:<company>/<tag>" в дополнение к "-<major>.<minor>". Многие макросы в C API преобразованы в обычные или статические inline-функции. Объявлены устаревшими и будут удалены в выпуске Python 3.13 модули uu, cgi, pipes, crypt, aifc, chunk, msilib, telnetlib, audioop, nis, sndhdr, imghdr, nntplib, spwd, xdrlib, cgitb, mailcap, ossaudiodev и sunau. Удалены функции PyUnicode_Encode*.