Вышел компилятор языка D 2.076

Команда разработчиков языка D представила новую версию компилятора 2.076. Язык D использует статическую типизацию, обладает синтаксисом, схожим с C/C++, и обеспечивает производительность компилируемых языков, при этом заимствуя некоторые полезные возможности динамических языков в области эффективности разработки и обеспечения безопасности. Например, предоставляется поддержка ассоциативных массивов, косвенное определение типов, автоматическое управление памятью, средства параллельного программирования, опциональный сборщик мусора, система шаблонов, компоненты для метапрограммирования, возможность использовать библиотеки на языке C, а также некоторые библиотеки на C++ и Objective-C. Компилятор DDMD поддерживает системы GNU/Linux, Windows, OS X, FreeBSD, и архитектуры x86, x86_64, x64. Главным нововведением является режим "-betterC", который позволяет разрабатывать на D полностью совместимые с Си библиотеки, при этом ликвидируя огромное количество проблем чистого Си. Краткий список особенностей данного режима: Отсутствие препроцессора Более высокая скорость компиляции Полноценная модульность. Поддержка различных видов импорта (статический импорт, частичный импорт, ренейминг при импорте и тд) В момент компиляции возможна: генерация кода, интроспекция, проверка различных условий. Ветвление на этапе компиляции через "static if" и "static foreach" возможны работа блоков вида version(linux) { ... } возможность написания циклов вида: "foreach(i; 1 .. 11) { ...}" Шаблоны Аналог borrow checking из Rust через "scope pointers (scope T*)", "scope slices (scope T[])" и "scope references (scope ref T)" Поддержка модификаторов доступа "const" и "immutable" TLS по умолчанию Поддержка контрактного программирования Удобные массивы с поддержкой слайсинга Ускорение работы с массивами за счет SIMD Удобные unit-тесты Встроенная система профилирования User-defined атрибуты Встроенный и очень удобный генератор документации Привычный каждому программисту Си синтаксис Поддержка Unicode Лучшие чем у C средства безопасного доступа памяти (memory safety) Замыкания RAII Код на Си: /* Eratosthenes Sieve prime number calculation. */ #define true 1 #define false 0 #define size 8190 #define sizepl 8191 char flags[sizepl]; int main() { int i, prime, k, count, iter; printf ("10 iterations\n"); for (iter = 1; iter <= 10; iter++) { count = 0; for (i = 0; i {= size; i++) flags[i] = true; for (i = 0; i {= size; i++) { if (flags[i]) { prime = i + i + 3; k = i + prime; while (k <= size) { flags[k] = false; k += prime; } count += 1; } } } printf ("\n%d primes", count); return 0; } Код в режиме betterC: import core.stdc.stdio; extern (C): __gshared bool[8191] flags; int main() { int count; printf("10 iterations\n"); foreach (iter; 1 .. 11) { count = 0; flags[] = true; foreach (i; 0 .. flags.length) { if (flags[i]) { const prime = i + i + 3; auto k = i + prime; while (k < flags.length) { flags[k] = false; k += prime; } count += 1; } } } printf("%d primes\n", count); return 0; } Для включения данного режима в dub.sdl необходимо добавить строку: dflags "-betterC" Для dub.json строка будет: "dflags" : ["betterC"], Предыдущая версия получила также возможность работы компилятора как библиотеки, что сделало возможным развитие средств качественного автодополнения. Частично данные возможности уже используются плагином для Visual Studio. Кроме этого следует отметить выпуск компилятора LDC 1.4.0-beta1 в котором появилась полная поддержка разработки под Android и режим кросскомпиляции. Для тех кто только начинает изучать программирование доступна альфа версия русской книги по программированию на D на русском языке.