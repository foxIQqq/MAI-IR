Релиз языка программирования Rust 2021 (1.56)

Опубликован релиз языка системного программирования Rust 1.56, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Кроме штатного номера версии выпуск также обозначен как Rust 2021 и знаменует собой стабилизацию изменений, предложенных за последние три года. Rust 2021 также выступит основой для наращивания функциональности в последующие три года, по аналогии с тем, как выпуск Rust 2018 стал базисом для развития языка в прошедшие три года. Для сохранения совместимости разработчики могут использовать в своих программах метки "2015", "2018" и "2021", позволяющие привязать программы к срезам состояния языка, соответствующим выбранным редакциям Rust. Редакции были введены для разделения несовместимых изменений и настраиваются в метаданных cargo-пакетов через поле "edition" в секции "[package]". Например, редакция "2018" включает стабилизированную на конец 2018 года функциональность и также охватывает все дальнейшие изменения, не нарушающие совместимость. Редакция "2021" дополнительно включает нарушающие совместимость новшества, предложенные в текущем выпуске 1.56 и утверждённые для реализации в будущем. Кроме самого языка редакции также учитывают состояние инструментария и документации. Основные несовместимости, зафиксированные в Rust 2021: Раздельный захват в замыканиях - замыкания теперь могут захватывать отдельные имена полей вместо всего идентификатора. Например, "|| a.x + 1" захватит только "a.x" вместо "a". Типаж IntoIterator для массивов: array.into_iter() позволяет организовать перебор элементов массива по значениям, а не по ссылкам. В macro_rules изменена обработка выражений "|" (логическая операция OR) в шаблонах - спецификатор ":pat" в сопоставлениях теперь учитывает шаблоны "A | B". В пакетном менеджере cargo включена по умолчанию вторая версия определителя доступных возможностей (feature resolver), поддержка которой появилась в Rust 1.51. Типажи (trait) TryFrom, TryInto и FromIterator добавлены в состав модуля стандартной библиотеки prelude. Макросы panic!(..) и assert!(expr, ..) теперь всегда используют format_args!(..) для форматирования строк по аналогии с println!(). В синтаксисе языка зарезервированы выражения ident#, ident"..." и ident'...'. Предупреждения bare_trait_objects и ellipsis_inclusive_range_patterns переведены в категорию ошибок. Новшества Rust 1.56: В Cargo.toml в секции "[package]" добавлено поле rust-version, через которое можно определить минимально поддерживаемую версию Rust для crate-пакета. Если текущая версия не соответствует указанному параметру Cargo прекратит работу с выводом ошибки. При сопоставлении с образцом при помощи выражений "binding @ pattern" реализована поддержка указания дополнительных привязок (например, "let matrix @ Matrix { row_len, .. } = get_matrix();"). В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: std::os::unix::fs::chroot UnsafeCell::raw_get BufWriter::into_parts core::panic::{UnwindSafe, RefUnwindSafe, AssertUnwindSafe} Vec::shrink_to String::shrink_to OsString::shrink_to PathBuf::shrink_to BinaryHeap::shrink_to VecDeque::shrink_to HashMap::shrink_to HashSet::shrink_to Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в функциях std::mem::transmute [T]::first [T]::split_first [T]::last [T]::split_last Компилятор переведён на использование версии LLVM 13. Реализован второй уровень поддержки для платформы aarch64-apple-ios-sim и третий уровень для платформ powerpc-unknown-freebsd и riscv32imc-esp-espidf . Третий уровень подразумевает базовую поддержку, но без автоматизированного тестирования, публикации официальных сборок и проверки возможности сборки кода. Напомним, что язык Rust сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Автоматическое управление памятью в Rust избавляет разработчика от ошибок при манипулировании указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io.