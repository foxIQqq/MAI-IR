Выпуск языка программирования Rust 1.59 с поддержкой ассемблерных вставок

Опубликован релиз языка программирования общего назначения Rust 1.59, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Методы работы с памятью в Rust избавляют разработчика от ошибок при манипулировании указателями и защищают от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами, учёт времени жизни объектов (области видимости) и оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок. Основные новшества: Предоставлена возможность использования ассемблерных вставок, востребованных в приложениях, которым необходимо управлять выполнением на низком уровне или иметь возможность использования специализированных машинных инструкций. Ассемблерные вставки добавляются при помощи макросов "asm!" и "global_asm!" с использованием для именования регистров синтаксиса форматирования строк, аналогичного тому, что используется в строковых подстановках в Rust. Компилятором поддерживаются ассемблерные инструкции для архитектур x86, x86-64, ARM, AArch64 и RISC-V. Пример вставки: use std::arch::asm; // Multiply x by 6 using shifts and adds let mut x: u64 = 4; unsafe { asm!( "mov {tmp}, {x}", "shl {tmp}, 1", "shl {x}, 2", "add {x}, {tmp}", x = inout(reg) x, tmp = out(reg) _, ); } assert_eq!(x, 4 * 6); Добавлена поддержка деструктурированных (параллельных) присвоений, в которых в левой части выражения указывается несколько типажей, слайсов или структур. Например: let (a, b, c, d, e); (a, b) = (1, 2); [c, .., d, _] = [1, 2, 3, 4, 5]; Struct { e, .. } = Struct { e: 5, f: 3 }; assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]); Предоставлена возможность указания значений по умолчанию для константных дженериков ("const generics"): struct ArrayStorage<T, const N: usize = 2> { arr: [T; N], } impl<T> ArrayStorage<T> { fn new(a: T, b: T) -> ArrayStorage<T> { ArrayStorage { arr: [a, b], } } } В пакетном менеджере Cargo обеспечен вывод предупреждений об использовании в зависимостях недопустимых конструкций, обрабатываемых из-за ошибок в компиляторе (например, из-за ошибки допускалось заимствование полей упакованных структур в safe-блоках). Поддержка подобных конструкций будет прекращена в будущей версии Rust. В cargo и rustc встроена возможность генерации исполняемых файлов, очищенных от отладочных данных (strip = "debuginfo") и символов (strip = "symbols"), без необходимости вызова отдельной утилиты. Настройка очистки реализуется через параметр "strip" в Cargo.toml: [profile.release] strip = "debuginfo", "symbols" По умолчанию отключена инкрементальная компиляция. В качестве причины называется временный обход ошибки в компиляторе, приводящей к сбоям и выводу ошибок десериализации. Исправление ошибки уже подготовлено и войдёт в состав следующего выпуска. Для возвращения инкрементальной компиляции можно использовать переменную окружения RUSTC_FORCE_INCREMENTAL=1. В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: std::thread::available_parallelism Result::copied Result::cloned arch::asm! arch::global_asm! ops::ControlFlow::is_break ops::ControlFlow::is_continue TryFrom for u8 char::TryFromCharError (Clone, Debug, Display, PartialEq, Copy, Eq, Error) iter::zip NonZeroU8::is_power_of_two NonZeroU16::is_power_of_two NonZeroU32::is_power_of_two NonZeroU64::is_power_of_two NonZeroU128::is_power_of_two DoubleEndedIterator для структуры ToLowercase DoubleEndedIterator для структуры ToUppercase TryFrom<&mut [T]> for [T; N] UnwindSafe для структуры Once RefUnwindSafe для Once встроенные в компилятор функции поддержки armv8 neon для aarch64 Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в функциях: mem::MaybeUninit::as_ptr mem::MaybeUninit::assume_init mem::MaybeUninit::assume_init_ref ffi::CStr::from_bytes_with_nul_unchecked Дополнительно можно отметить публикацию компанией Microsoft выпуска библиотек Rust for Windows 0.33, позволяющих использовать язык Rust для разработки приложений для ОС Windows. В набор входят два crate-пакета (windows и windows-sys), через которые можно обращаться к WinAPI в программах на языке Rust. Код для поддержки API генерируется динамически из метаданных с описанием API, что позволяет реализовать поддержку не только уже существующих вызовов WinAPI, но вызовов, которые появятся в будущем. В новой версии добавлены типы для PCSTR и PCWSTR, упрощена реализация интерфейсов WinRT.