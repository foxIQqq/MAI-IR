Выпуск языка программирования Rust 1.61

Опубликован релиз языка программирования общего назначения Rust 1.61, основанного проектом Mozilla, но ныне развиваемого под покровительством независимой некоммерческой организации Rust Foundation. Язык сфокусирован на безопасной работе с памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Методы работы с памятью в Rust избавляют разработчика от ошибок при манипулировании указателями и защищают от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Безопасная работа с памятью обеспечивается в Rust во время компиляции через проверку ссылок, отслеживание владения объектами, учёт времени жизни объектов (области видимости) и оценку корректности доступа к памяти во время выполнения кода. Rust также предоставляет средства для защиты от целочисленных переполнений, требует обязательной инициализации значений переменных перед использованием, лучше обрабатывает ошибки в стандартной библиотеке, применяет концепцию неизменяемости (immutable) ссылок и переменных по умолчанию, предлагает сильную статическую типизацию для минимизации логических ошибок. Основные новшества: Предоставлена возможность определения собственных кодов возврата из функции main. Изначально функция main в Rust могла возвращать только тип "()" (unit), что всегда указывало на успешный статус завершения, если разработчиком явно не вызвана функция "process::exit(code)". В Rust 1.26 при помощи нестабильного типажа Termination в функции main была предоставлена возможность возвращение значений "Ok" и "Err", соответствующих кодам EXIT_SUCCESS и EXIT_FAILURE в программах на языке Си. В Rust 1.61 типаж Termination переведён в разряд стабильных, а для представления конкретного кода возврата предложен отдельный тип ExitCode, который абстрагирует специфичные для платформы типы возвращаемых значений, предоставляя как предопределённые константы SUCCESS и FAILURE, так и метод From<u8> для возвращения произвольного кода возврата. use std::process::ExitCode; fn main() -> ExitCode { if !check_foo() { return ExitCode::from(42); } ExitCode::SUCCESS } Стабилизированы дополнительные возможности функций, определённых с использованием выражения "const fn", которые могут вызываться не только как обычные функции, но и использоваться в любом контексте вместо констант. Данные функции вычисляются на этапе компиляции, а не в ходе выполнения, поэтому на них накладываются определённые ограничения, такие как возможность чтения только из констант. В новой версии внутри const-функций разрешены базовые операции с указателями на функции (разрешено создание, передача и приведение указателей, но не вызов функции по указателю); ограничения типажей (trait bounds) для обобщённых параметров const-функций, таких как T: Copy; динамически диспетчеризируемые типажи (dyn Trait); типы impl Trait для аргументов и возвращаемых значений функции. Дескрипторы потоков Stdin, Stdout и Stderr в std::io теперь имеют cтатическое время жизни ("'static") при блокировке, что позволяет использовать конструкции вида "let out = std::io::stdout().lock();" с получением дескриптора и выставлением блокировки в одном выражении. В разряд стабильных переведена новая порция API, в том числе стабилизированы методы и реализации типажей: Pin::static_mut Pin::static_ref Vec::retain_mut VecDeque::retain_mut Write для Cursor<[u8; N]> std::os::unix::net::SocketAddr::from_pathname std::process::ExitCode std::process::Termination std::thread::JoinHandle::is_finished Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в функциях: <*const T>::offset и <*mut T>::offset <*const T>::wrapping_offset и <*mut T>::wrapping_offset <*const T>::add и <*mut T>::add <*const T>::sub и <*mut T>::sub <*const T>::wrapping_add и <*mut T>::wrapping_add <*const T>::wrapping_sub и <*mut T>::wrapping_sub <[T]>::as_mut_ptr <[T]>::as_ptr_range <[T]>::as_mut_ptr_range Дополнительно можно отметить статью "Rust: A Critical Retrospective" с обобщением впечатлений о языке Rust после написания на нём 100 тысяч строк кода в процессе разработки микроядерной операционной системы Xous, используемой в прошивках. Из недостатков отмечается трудный для восприятия синтаксис, незавершённость и продолжение развития языка, отсутствие повторяемых сборок, типовые проблемы с доверием к зависимостям в Crates.io, необходимость соблюдения определённой дисциплины для написания безопасного кода. Из возможностей превзошедших ожидания упоминаются средства для рефакторинга кода и переделки "хаков", добавленных при быстром создании прототипов.