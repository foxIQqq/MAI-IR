Выпуск cppcheck 2.6, статического анализатора кода для языков C++ и С

Вышла новая версия статического анализатора кода cppcheck 2.6, позволяющего выявлять различные классы ошибок в коде на языках Си и Си++, в том числе при использовании нестандартного синтаксиса, типичного для встраиваемых систем. Предоставляется коллекция плагинов, через которые обеспечена интеграция cppcheck с различными системами разработки, непрерывной интеграции и тестирования, а также предоставлены такие возможности как проверка соответствия кода стилю оформления кода. Для разбора кода может применяться как собственный парсер, так и внешний парсер от Clang. В состав также входит скрипт donate-cpu.py для предоставления локальных ресурсов для выполнения работы по совместной проверке кода пакетов Debian. Исходные тексты проекта распространяются под лицензией GPLv3. Развитие cppcheck сосредоточено на выявлении проблем, связанных с неопределённым поведением и применением конструкций, опасных с точки зрения безопасности. Целью также является минимизация ложных срабатываний. Среди выявляемых проблем: указатели на несуществующие объекты, деления на ноль, целочисленные переполнения, некорректные операции битового сдвига, некорректные преобразования, проблемы при работе с памятью, некорректное использование STL, разыменование нулевых указателей, применение проверок после фактического обращения к буферу, выход за границы буферов, использование неинициализированных переменных. В новой версии: В ядро анализатора добавлены следующие проверки: Отсутствия оператора return в теле функции; Записи перекрывающихся данных, определения неопределённого поведения; Сравниваемое значение находится за пределами представления значений типа; Оптимизация копирования не применяется для return std::move(local); Файл не может быть открыт одновременно для чтения и для записи в разных потоках (stream); Для Unix-платформ добавлена поддержка вывода диагностических сообщений разными цветами; Добавлен символьный анализ для ValueFlow. Используется простая дельта при вычислении различий между двумя неизвестными переменными; Правила, используемые для списка токенов "define", также могут соответствовать и #include; Библиотечный тег <function> теперь может содержать тег <container>, и соответственно функции free, которые могут принимать такие контейнеры как std::size, std::empty, std::begin, std::end и т.д. могут указывать yeld или action для контейнеров; Библиотечный тег <smart-pointer> теперь может содержать тег <unique> для умных указателей, которые имеют исключительное владение (unique ownership). Теперь выдаётся предупреждение о "висячих" ссылках на такого рода умные указатели; Исправлены проблемы с обработкой параметра --cppcheck-build-dir; htmlreport теперь может выводить информацию об авторе (при помощи git blame); Расширена выдача предупреждений о переменных, которые не являются константными, но которые можно перевести в константные; Исправлены накопившиеся ошибки и недоработки анализатора. Дополнительно были полностью реализованы проверки из Misra C 2012, включая Amendment 1 и Amendment 2, кроме правил 1.1 , 1.2 and 17.3. Проверки 1.1 и 1.2 должны выполняться компилятором. Проверка 17.3 может выполнять компилятором, например GCC.