Выпуск Java SE 15

После шести месяцев разработки компания Oracle выпустила платформу Java SE 15 (Java Platform, Standard Edition 15), в качестве эталонной реализации которой используется открытый проект OpenJDK. В Java SE 15 сохранена обратная совместимость с прошлыми выпусками платформы Java, все ранее написанные Java-проекты без изменений будут работоспособны при запуске под управлением новой версии. Готовые для установки сборки Java SE 15 (JDK, JRE и Server JRE) подготовлены для Linux (x86_64), Windows и macOS. Разработанная в рамках проекта OpenJDK эталонная реализация Java 15 полностью открыта под лицензией GPLv2 с исключениями GNU ClassPath, разрешающими динамическое связывание с коммерческими продуктами. Java SE 15 отнесён к категории выпусков с обычным сроком поддержки, обновления для которого будут выпускаться до следующего релиза. В качестве ветки с длительным сроком поддержки (LTS) следует использовать Java SE 11, обновления для которого будут выпускаться до 2026 года. Прошлая LTS-ветка Java 8 будет поддерживаться до декабря 2020 года. Следующий LTS-релиз намечен на сентябрь 2021 года. Напомним, что начиная с выпуска Java 10 проект перешёл на новый процесс разработки, подразумевающий более короткий цикл формирования новых релизов. Новая функциональность теперь развивается в одной постоянно обновляемой master-ветке, в которую включаются уже готовые изменения и от которой раз в шесть месяцев ответвляются ветки для стабилизации новых выпусков. Из новшеств Java 15 можно отметить: Встроена поддержка алгоритма создания цифровой подписи EdDSA (Edwards-Curve Digital Signature Algorithm RFC 8032). Предложенная реализация EdDSA не зависит от аппаратных платформ, защищена от атак по сторонним каналам (обеспечено постоянное время всех вычислений) и по производительности опережает существующую реализацию ECDSA, написанную на языке Си, при том же уровне защиты. Например, EdDSA при использовании эллиптической кривой со 126-битным ключом демонстрирует производительность аналогичную ECDSA с эллиптической кривой secp256r1 и 128-битным ключом. Добавлена экспериментальная поддержка запечатанных ("sealed") классов и интерфейсов, которые не могут использоваться другими классами и интерфейсами для наследования, расширения или переопределения реализации. Запечатанные классы также предоставляют более декларативный способ ограничения использования суперкласса, чем модификаторы доступа, основанный на явном перечислении подклассов, разрешённых для расширения. package com.example.geometry; public sealed class Shape permits com.example.polar.Circle, com.example.quad.Rectangle, com.example.quad.simple.Square {...} Добавлена поддержка скрытых классов, которые не могут быть использованы напрямую байткодом других классов. Ключевым назначением скрытых классов является использование во фреймворках, динамически генерирующих классы во время выполнения и использующих их косвенно, через отражение. Подобные классы обычно имеют ограниченный жизненный цикл, поэтому их поддержание для доступа из статически сгенерированных классов не оправдано и приведёт лишь к увеличению потребления памяти. Скрытые классы также позволяют обойтись без нестандартного API sun.misc.Unsafe::defineAnonymousClass, который намечен на удаление в будущем. Стабилизирован и признан готовым для повсеместного использования сборщик мусора ZGC (Z Garbage Collector). ZGC работает в пассивном режиме, насколько это возможно минимизирует задержки из-за сборки мусора (время остановки при использовании ZGC не превышает 10 мс.) и может работать как с небольшими, так и с огромными кучами, размером от нескольких сотен мегабайт до многих терабайт. Стабилизирован и признан готовым для повсеместного использования сборщик мусора Shenandoah, работающий с минимальными приостановками (Low-Pause-Time Garbage Collector). Shenandoah разработан компанией Red Hat и примечателен использованием алгоритма, сокращающего время остановок во время сборки мусора за счёт проведения чистки параллельно с выполнением Java-приложений. Размер, вносимых сборщиком мусора задержек, предсказуем, и не зависит от размера кучи, т.е. для куч в 200 MB и 200 GB задержки будут идентичны (не выходят за пределы 50 мс и обычно укладываются в 10 мс); Стабилизирована и введена в язык поддержка текстовых блоков - новой формы строковых литералов, позволяющих включать в исходный код многострочные текстовые данные без применения в них экранирования символов и сохраняя исходное форматирования текста в блоке. Обрамление блока осуществляется тремя двойными кавычками. Например, вместо кода String html = "<HTML>" + "\n\t" + "<BODY>" + "\n\t\t" + "<H1>\"Java 15 is here!\"</H1>" + "\n\t" + "</BODY>" + "\n" + "</HTML>"; можно указать: String html = """ <HTML> <BODY> <H1>"Java 15\ is here!"</H1> </BODY> </HTML>"""; Переработан API Legacy DatagramSocket. Старые реализации java.net.DatagramSocket и java.net.MulticastSocket, заменены на современную реализацию, более простую для отладки и сопровождения, а также совместимую с виртуальными потоками, развиваемыми в рамках проекта Loom. На случай возможного нарушения совместимости с существующим кодом старая реализация не удалена и может быть активирована при помощи опции jdk.net.usePlainDatagramSocketImpl. Предложена вторая экспериментальная реализация сопоставления c образцом в операторе "instanceof", которая позволяет сразу определить локальную переменную для обращения к проверенному значению. Например, можно сразу писать "if (obj instanceof String s && s.length() > 5) {.. s.contains(..) ..}" без явного определения "String s = (String) obj". Было: if (obj instanceof Group) { Group group = (Group) obj; var entries = group.getEntries(); } Теперь можно обойтись без определения "Group group = (Group) obj": if (obj instanceof Group group) { var entries = group.getEntries(); } Предложена вторая экспериментальная реализация ключевого слова "record", предоставляющего компактную форму для определения классов, позволяющую обойтись без явного определения различных низкоуровневых методов, таких как equals(), hashCode() и toString(), в случаях, когда данные сохраняются только в полях, поведение работы с которыми не меняется. Когда в классе используются типовые реализации методов equals(), hashCode() и toString(), в нём можно обойтись без их явного определения: public record BankTransaction(LocalDate date, double amount, String description) {} Данное объявление приведёт к автоматическому добавлению реализаций методов equals(), hashCode() и toString() в дополнение к конструктору и методам, контролирующим изменение данных (getter). Предложен второй предварительный вариант API Foreign-Memory Access, позволяющий Java-приложениям безопасно и эффективно получить доступ к областям памяти, вне кучи Java, манипулируя новыми абстракциями MemorySegment, MemoryAddress и MemoryLayout. Отключена и объявлена устаревшей техника оптимизации Biased Locking, применявшаяся в HotSpot JVM для сокращения накладных расходов из-за блокировок. Данная техника потеряла актуальность на системах с атомарными инструкциями, предоставляемыми современными CPU, и слишком трудоёмка для сопровождения из-за своей сложности. Объявлен устаревшим механизм RMI Activation, который будет удалён в одном из следующих выпусков. Отмечается, что RMI Activation устарел, переведён в разряд опции ещё в Java 8 и почти не применяется в современной практике. Удалён JavaScript-движок Nashorn, который был объявлен устаревшим в Java SE 11. Удалены порты для ОС Solaris и процессоров SPARC (Solaris/SPARC, Solaris/x64 и Linux/SPARC). Удаление указанных портов позволит сообществу ускорить разработку новых возможностей OpenJDK, не тратя время на поддержание особенностей, специфичных для Solaris и SPARC.