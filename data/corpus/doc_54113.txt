Выпуск языка программирования Rust 1.48

Опубликован релиз 1.48 языка системного программирования Rust, основанного проектом Mozilla. Язык сфокусирован на безопасной работе с памятью, обеспечивает автоматическое управление памятью и предоставляет средства для достижения высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime (runtime сводится к базовой инициализации и сопровождению стандартной библиотеки). Автоматическое управление памятью в Rust избавляет разработчика от ошибок при манипулировании указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Для распространения библиотек, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo. Для размещения библиотек поддерживается репозиторий crates.io. Основные новшества: Расширены возможности утилиты rustdoc, применяемой для генерации документации из примечаний в коде или файлов в формате Markdown. Добавлены средства для добавления в документирующие комментарии ссылок на другие элементы, упоминаемые при описании взаимосвязи. Если раньше ссылки на файлы с описанием дополнительных элементов выставлялись вручную, то теперь rustdoc определяет упоминание типа и автоматически генерирует URL. Например, в примере ниже показано как разместить ссылку на структуру Bar, в первом случае с текстом ссылки "Bar", а во втором "crate::foo::Bar": pub mod foo { /// Some docs for `Foo` /// /// You may want to use `Foo` with [`Bar`](crate::bar::Bar). /// You may want to use `Foo` with [`crate::foo::Bar`]. pub struct Foo; } В rustdoc также добавлена возможность добавления псевдонимов при помощи аннотации #[doc(alias = "<alias>")], которые становятся доступны при поиске через интерфейс rustdoc. Например, указанная возможность позволяет ассоциировать Rust-функции с Си-функциями в пакетах с FFI-обвязками для поиска по именам функций из лежащей в основе Си-библиотеки. В примере ниже к структуре "Foo" привязывается псевдоним "bar", после чего поиск "bar" приведёт к упоминанию "Foo" в результатах поиска. #[doc(alias = "bar")] struct Foo; В стандартной библиотеке стабилизировано применение константных дженериков ("const generics") "[T; N]: TryFrom<Vec<T>>" для превращения вектора в массив заданной длины. Все массивы любого размера теперь поддерживают "TryFrom<Vec<T>>". use std::convert::TryInto; let v1: Vec<u32> = vec![1, 2, 3]; let a1: [u32; 3] = v1.try_into().expect("wrong length"); В разряд стабильных переведена новая порция API, в том числе стабилизированы slice::as_ptr_range, slice::as_mut_ptr_range, VecDeque::make_contiguous, future::pending, future::ready. Признак "const", определяющий возможность использования в любом контексте вместо констант, применён в методах: Option::is_some Option::is_none Option::as_ref Result::is_ok Result::is_err Result::as_ref Ordering::reverse Ordering::then В модулях синтаксически разрешено использование ключевого слова unsafe (семантически данное ключевое слово по-прежнему не принимается, но теперь может быть разобрано в процедурных макросах). В компиляторе стабилизирован флаг "-C link-self-contained=<yes|no>, позволяющий управлять связыванием с собственными Си-runtime и библиотеками при использовании платформ windows-gnu, linux-musl и wasi. Для платформ linux-gnu добавлена поддержка флага "-C target-feature=+crt-static". Обеспечен второй уровень поддержки для платформы aarch64-unknown-linux-musl.