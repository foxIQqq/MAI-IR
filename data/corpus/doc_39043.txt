Выход системной библиотеки Glibc 2.19

Представлен релиз системной библиотеки GNU C Library (glibc) 2.19, которая полностью следует требованиям стандартов ISO C11 и POSIX.1-2008. В подготовке нового выпуска использованы патчи от 78 разработчиков. Glibc является основой большинства Linux-дистрибутивов за исключением OpenWrt, Mandriva, Debian и Ubuntu, которые перешли на использование системной библиотеки Eglibc. Библиотека Eglibc развивается синхронно с Glibc, построена на актуальной кодовой базе Glibc и полностью совместима с ней на уровне API и ABI, отличаясь интеграцией некоторых дополнительных наработок для встраиваемых систем, более низкими системными требованиями, возможностью гибкой настройки компонентов, улучшенной поддержкой кросс-компиляции и кросс-тестирования. Одновременно с релизом Glibc 2.19 сформирована новая ветка Eglibc 2.19. Из добавленных в Glibc 2.19 улучшений можно отметить: Поддержка компиляции с использованием Clang-расширения "-fblock" и сборки программ из кодовой базы BSD-систем, за счёт прекращения использования в публичных заголовочных файлах конструкций "__unused" и "__block"; Улучшения, связанные с процессорами Power: поддержка архитектуры powerpc64le; в soft-float порт powerpc добавлена поддержка процессоров e500; для архитектур ppc32/power4+ и ppc64 добавлена поддержка символов STT_GNU_IFUNC; Улучшения, связанные с локализацией: Для почти всех поддерживаемых локалей в поле LC_ADDRESS добавлена поддержка указания аббревиатуры страны, используемой в автомобильных номерах (country_car). Например, ru_RU соответствует аббревиатура RUS; Добавлена поддержка определений ISO 1427 и ISO 3166 (кодовые обозначения государств); В утилиту localedef добавлены опции "--big-endian" и "--little-endian" для генерации локалей для различных типов систем, отличных от текущей системы; Бинарные файлы с параметрами локалей теперь зависят только от порядка следования байтов в системах и ни от каких других параметров. Бинарные файлы, созданные новой версией localedef, могут оказаться несовместимыми с прошлыми выпусками Glibc, и наоборот, созданные старыми версиями localedef бинарные файлы могут оказаться несовместимыми с новой версией Glibc, при следующих условиях: Возможно нарушение совместимости файлов с локалями для архитектуры m68k; Возможно нарушение совместимости архивов с локалями (не отдельных файлов) на системах в которых символ определяется знаковым типом; Поддержка контрольных вызовов SystemTap для функции malloc и медленных методов трансцендентных математических функций; Добавлен тестовый макрос _DEFAULT_SOURCE для активации объявлений в заголовочных файлах, аналогичных тем, что включены по умолчанию, даже если при сборке используются опции компилятора или макросы, отключающие некоторые объявления (например, -std=c99); Тестовый макрос _BSD_SOURCE отныне не активирует интерфейсы BSD, которые конфликтуют с POSIX. Удалена библиотека libbsd-compat; Из скрипта configure удалена поддержка опции "--disable-versioning", сборка с которой не работает уже несколько лет; Исправлено 179 ошибок, в том числе устранено 6 уязвимостей: CVE-2012-4412, CVE-2012-4424 - переполнение буфера и стека в коде кэширования индексов для функции strcoll при сопоставлении последовательностей большого размера. Проблемы решены через использование более медленного алгоритма без кэширования в ситуациях когда размер данных слишком велик и может привести к целочисленному переполнению счётчика индекса или нехватке памяти; CVE-2013-4788 - система защиты указателей pointer guard не работала для статических приложений. Отныне для инициализации pointer guard для статически связанных приложений используются случайные значения; CVE-2013-4237 - функция "readdir_r" могла записать в поле "d_name" структуры "dirent" больше данных, чем определено лимитом NAME_MAX или потерять завершающий строку нулевой символ; CVE-2013-4332 - функции pvalloc, valloc, memalign, posix_memalign и aligned_alloc могли выделить меньше памяти, чем необходимо, или повредить содержимое кучи при указании слишком большого размера запрошенной памяти; CVE-2013-4458 - переполнение стека при получении функцией getaddrinfo слишком большого числа результатов запроса при использовании протокола AF_INET6.