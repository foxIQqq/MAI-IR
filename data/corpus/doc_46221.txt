Доступен язык программирования Rust 1.16

Подготовлен релиз языка программирования Rust 1.16, развиваемого проектом Mozilla, обеспечивающего автоматическое управление памятью и предоставляющего средства для высокого параллелизма выполнения заданий, при этом обходясь без использования сборщика мусора и runtime. Параллельно с Rust совместно с компанией Samsung развивается экспериментальный браузерный движок Servo, написанный на языке Rust и отличающийся поддержкой многопоточного рендеринга web-страниц и распараллеливанием операций с DOM (Document Object Model). На Rust также разрабатывается операционная система Redox, использующая концепцию экзоядра и продвигающая принцип "все есть URL". В подготовке нового выпуска приняли участие 137 разработчиков. Основные новшества: В пакетном менеджере Cargo реализована команда "cargo check", при указании которой компилятором выполняются все совершаемые при сборке проверки кода, но пропускаются достаточно ресурсоёмкие стадии, связанные с генерацией исполняемых файлов. Для некоторых проектов "cargo check" может выполняться в несколько раз быстрее обычной сборки, что позволяет значительно сэкономить время разработчика при выполнении тестовых пересборок, обычно используемые в процессе разработки чтобы убедиться, что добавленный код компилируется; В команды "cargo build" и "cargo doc" добавлен флаг "--all" для сборки и документирования всех исполняемых контейнеров (crate) одной командой. По аналогии с rustc в cargo также добавлены флаги "--version" и "--verbose"; В cargo и репозиторий crates.io добавлена возможность использования не только заданных в произвольной форме ключевых слов, но и предопределённых фиксированных категорий; Для обеспечения работы "cargo check" в компилятор rustc добавлена поддержка нового типа файлов ".rmeta", в которых сохраняются только метаданные об исполняемых контейнерах (crate), необходимые для проверки типов и сопутствующей сборке информации о зависимостях. В будущем файлы ".rmeta" планируется задействовать в сборочном сервере Rust Language Server и возможно в некоторых других утилитах; Удалена диагностическая подсказка "consider using an explicit lifetime parameter", выводимая при проблемах с lifetime-аннотациями, которая только запутывала новичков, в некоторых ситуациях давая ложный совет, не приводящий к устранению проблемы; Диагностические подсказки об опечатках в именах теперь не ограничены именами функций, локальными переменными и полями в структурах, и также применяются для имён импортируемых модулей, crate и inline-блоков; В разряд стабильных переведена новая порция функций и методов. В том числе стабилизированы VecDeque::truncate, VecDeque::resize, String::insert_str, Duration::checked_*, str::replacen, str::repeat, SocketAddr::is_ipv4/6, IpAddr::is_ipv4/6, Vec::dedup_by*, File::set_permissions, String::split_off и т.д. По аналогии с "println!" добавлена новая форма "writeln!" без указания аргументов, выводящая перевод строки; Все структуры стандартной библиотеки поддерживают трейт fmt::Debug, то есть могут быть выведены на печать при помощи `println("{:?}", strct)`. Напомним, что язык Rust сфокусирован на безопасной работе с памятью и обеспечении высокого параллелизма выполнения заданий. При этом Rust обходится без использования сборщика мусора или runtime, что делает возможным создания на Rust библиотек, которые могут выступать в роли прозрачной замены библиотекам для языка Си. Для распространения библиотек на языке Rust, обеспечения сборки и управления зависимостями проектом развивается пакетный менеджер Cargo, позволяющий получить нужные для программы библиотеки в один клик. Для размещения библиотек введён в строй репозиторий crates.io. По структуре язык Rust напоминает C++, но существенно отличается в некоторых деталях реализации синтаксиса и семантики. Автоматическое управление памятью избавляет разработчика от манипулирования указателями и защищает от проблем, возникающих из-за низкоуровневой работы с памятью, таких как обращение к области памяти после её освобождения, разыменование нулевых указателей, выход за границы буфера и т.п. Rust поддерживает смесь императивных, процедурных и объектно-ориентированных методов с такими парадигмами, как функциональное программирование, обобщённое программирование и метапрограммирование, в статических и динамических стилях.