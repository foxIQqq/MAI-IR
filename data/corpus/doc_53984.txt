Выпуск пакетного фильтра nftables 0.9.7

Опубликован выпуск пакетного фильтра nftables 0.9.7, развивающегося в качестве замены iptables, ip6table, arptables и ebtables за счёт унификации интерфейсов фильтрации пакетов для IPv4, IPv6, ARP и сетевых мостов. В пакет nftables входят компоненты пакетного фильтра, работающие в пространстве пользователя, в то время как на уровне ядра работу обеспечивает подсистема nf_tables, входящая в состав ядра Linux начиная с выпуска 3.13. Необходимые для работы выпуска nftables 0.9.7 изменения включены в состав ядра Linux 5.10-rc1. На уровне ядра предоставляется лишь общий интерфейс, не зависящий от конкретного протокола и предоставляющий базовые функции извлечения данных из пакетов, выполнения операций с данными и управления потоком. Непосредственно правила фильтрации и специфичные для протоколов обработчики компилируются в байткод в пространстве пользователя, после чего данный байткод загружается в ядро при помощи интерфейса Netlink и выполняется в ядре в специальной виртуальной машине, напоминающей BPF (Berkeley Packet Filters). Подобный подход позволяет значительно сократить размер кода фильтрации, работающего на уровне ядра и вынести все функции разбора правил и логики работы с протоколами в пространство пользователя. Основные новшества: Поддержка неявных цепочек, которые создаются динамически. При удалении связанного с неявной цепочкой правила автоматически удаляется и сама цепочка. Например, теперь можно группировать правила без необходимости отдельного определения цепочек: table inet x { chain y { type filter hook input priority 0; tcp dport 22 jump { ip saddr { 127.0.0.0/8, 172.23.0.0/16, 192.168.13.0/24 } accept ip6 saddr ::1/128 accept; } } } Поддержка цепочек "ingress" для семейства протоколов inet (охватывает сразу IPv4 и IPv6), позволяющих фильтровать пакеты IPv4 и IPv6 на том же уровне, что ingress-обработчик в цепочке netdev (hook ingress), т.е. на стадии когда драйвер передаёт пакет сетевому стеку ядра. Для использования ingress-цепочек требуется ядро 5.10-rc1, в котором появились необходимые обработчики. Предоставленная возможность позволяет использовать общие set- и map-списки с цепочками prerouting, input, forward, output и postrouting, например: table inet filter { chain ingress { type filter hook ingress device "veth0" priority filter; policy accept; } chain input { type filter hook input priority filter; policy accept; } chain forward { type filter hook forward priority filter; policy accept; } } Добавлена возможность отклонения пакетов на стадии до проверки маршрутизации - выражение REJECT теперь может использоваться не только в цепочках INPUT, FORWARD и OUTPUT, но и на стадии PREROUTING: table inet x { chain y { type filter hook prerouting priority 0; policy accept; tcp dport 22 reject with tcp reset } } Добавлен режим сокращённого вывода в формате JSON, активируемый при указании опции "--terse" (исключает элементы set-списков при отображении правил): nft --terse -j list ruleset При выводе в JSON ("-j") обеспечено отображение значений счётчиков для set-списков: nft -j list set Добавлена возможность сброса счётчиков командой "reset" вместе с выводом в формате JSON: nft -j reset counters Предоставления возможность сопоставления слушающих сокетов по маске (socket wildcard): table inet x { chain y { type filter hook prerouting priority -150; policy accept; socket transparent 1 socket wildcard 0 mark set 0x00000001 } } Добавлена возможность извлечения элементов map-списка: nft get element inet filter test "{ 18.51.100.17 . ad:c1:ac:c0:ce:c0 . 3761 : 0x42 }" table inet filter { map test { type ipv4_addr . ether_addr . inet_service : mark flags interval,timeout elements = { 18.51.100.17 . ad:c1:ac:c0:ce:c0 . 3761 : 0x00000042 } } } Добавлена поддержка комментариев в set-списках, так же как в таблицах и stateful-объектах (квоты, ограничения, счётчики): table ip x { set s { type ipv4_addr; comment "list of unwanted traffic by IP address" elements = { 1.1.1.1, 1.2.3.4 } } } Реализована возможность определения пустых set-списков в переменных: define BASE_ALLOWED_INCOMING_TCP_PORTS = {22, 80, 443} define EXTRA_ALLOWED_INCOMING_TCP_PORTS = {} table inet x { chain y { type filter hook input priority 0; policy drop; ct state new tcp dport { $BASE_ALLOWED_INCOMING_TCP_PORTS, $EXTRA_ALLOWED_INCOMING_TCP_PORTS } counter accept } } Предоставлена возможность использования переменных в строках, определяющих префикс записей в логе: define foo= "state" define bar = "match" table x { chain y { ct state invalid log prefix "invalid $foo $bar:" } } Предоставлена возможность использования переменных в определениях цепочек и flowtable: define if_main = lo table netdev x { chain y { type filter hook ingress device $if_main priority -500; policy accept; } } Разрешено указание отрицательных значений в переменных: define post = -10 define for = "filter - 100" table inet global { chain forward { type filter hook prerouting priority $for policy accept } chain postrouting { type filter hook postrouting priority $post policy accept } } Улучшена пометка ошибок в выражениях. Например, при отсутствии цепочки будет подсвечено проблемное имя: # nft add rule x y jump test Error: Could not process rule: No such file or directory add rule x y jump test ^^^^ Реализована поддержка трансляции адресов (NAT) для SCTP, не учитывающая состояние соединения (stateless).