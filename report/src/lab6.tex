\section{Булев индекс}

\subsection{Описание}
Инвертированный индекс — это основная структура для булевого поиска: для каждого терма хранится список документов, в которых он встречается, что позволяет быстро вычислять булевы выражения. В проекте индекс реализован с нуля, без использования STL: собственная строка, динамический массив и хэш-таблица с цепочками обеспечивают полный контроль представления и сериализации. Такое решение полезно для учебной задачи, поскольку демонстрирует внутренние механизмы и даёт возможность оптимизировать конкретные узкие места. Индекс сохраняется в бинарном формате, что даёт быструю загрузку в память при запуске поисковой утилиты. Помимо базовой структуры, предусмотрены мероприятия по предотвращению дубликатов внутри posting lists и сортировка списков перед сохранением для корректной работы алгоритмов пересечения.

\subsection{Структуры и реализация}
Ключевой тип \code{SchString} инкапсулирует управление памятью строк, а \code{SchVector<T>} реализует динамический массив с изменяемой ёмкостью. Хэш-таблица выполнена методом цепочек, где узлы содержат C-строки ключей и значение — posting list. Posting list — это \code{SchVector<int>}, хранящий id документов; при добавлении мы проверяем последний элемент, чтобы не добавлять один и тот же id дважды. Сохранение индекса организовано детерминированно: сначала запись списка имён документов, затем запись термов и их posting lists. Такая схема облегчает восстановление индекса и делает формат стабильным.

\subsection{Диаграмма структуры posting list}
\begin{center}
\begin{tikzpicture}[node distance=6mm,font=\small]
  \node (term) [draw,rounded corners,fill=gray!10] {term: \texttt{kernel}};
  \node[right=of term] (pl) [draw,rounded corners,fill=gray!10] {PostingList: [2,5,8,12,20]};
  \draw[->] (term) -- (pl);
  \node[below=6mm of pl] (note) {PostingList хранит отсортированные id документов; пересечение — два указателя.};
\end{tikzpicture}
\end{center}

\subsection{Проблемы масштаба и компрессии}
При больших корпусов хранение списков в виде массивов int может занимать много памяти; для реального проекта следует применить дельта-кодирование и переменную длину кодирования (variable-byte), а также skip-поинтеры для ускорения пересечений. Кроме того, имеет смысл разделять индекс на сегменты и загружать только активные части при обслуживании запросов. В учебной реализации эти оптимизации отложены как дальнейшая работа, но архитектура рассчитана на их последующую интеграцию.

\subsection{Тестирование и валидность индекса}
При тестировании индекса проверяется корректность добавления документов, отсутствие дубликатов, корректность сортировки posting lists и корректная сериализация/десериализация. Также проверяется работоспособность базовых операций: получение posting list по терму, пересечение и объединение списков, и целостность данных после сохранения и повторной загрузки. Эти тесты помогают гарантировать, что индекс готов к использованию поисковой утилитой.
\pagebreak
